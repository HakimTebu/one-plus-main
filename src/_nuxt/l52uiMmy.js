const __vite__mapDeps = (i, m = __vite__mapDeps, d = (m.f || (m.f = ["./Hs4KDZfb.js", "./DgDwn7Ps.js", "./DlAUqK2U.js", "./Header.ZId7YcTX.css", "./DU51NzWg.js", "./UkgSXXPe.js", "./about.kRDmxbN6.css", "./BN0LOnJ0.js", "./CMil2AtK.js", "./index.CwwLFNGd.css", "./qqrkwCeT.js", "./BP1d2kDa.js", "./BaPOtJa_.js", "./CasmIQa0.js", "./BJFuLHGv.js", "./CsWJY3Sa.js", "./CUL8VHWe.js", "./iW-S33yr.js", "./MessageDialog.DIzvdF6O.css", "./D_D6d7w8.js", "./BAXUfs15.js", "./Description.DSCBIP0p.css", "./deleteaccount.C7YGzyxt.css", "./CSy9Gn0u.js", "./developers.CmP8kHVt.css", "./xp5mA54X.js", "./DwB8LVhX.js", "./faq.7DwZoUnU.css", "./BUj3ONqt.js", "./CvHy5JMd.js", "./index.BXtUSax5.css", "./CRPEHUN9.js", "./Modal.QlwoaAsN.css", "./D0LFJQTz.js", "./index.B8hhfwGU.css", "./C3qahrz_.js", "./locations.erUmJwDp.css", "./CWzil_Hb.js", "./service-provider.C3oCKYu1.css", "./aj6_LuUv.js", "./B1Uq3l9O.js", "./support.CAPmGF_4.css", "./CJzAXa1o.js", "./BqdLsTte.js", "./ReadMore.D6jBDnDJ.css", "./DQQXC2SP.js", "./CVsSjztH.js", "./DfTI8JQj.js", "./BPD5qkZX.js", "./DOrJb-DD.js", "./default.CXQ-E6Yu.css", "./Y4_1m0aC.js", "./public.EIOfIw9C.css", "./DCY82DFH.js", "./error-404.CjGVuf6H.css", "./Dr2is14k.js", "./error-500.DFBAsgKS.css"]))) => i.map(i => d[i]);
/**
 * @vue/shared v3.4.21
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
function PC(e, t) {
    const n = new Set(e.split(","));
    return a => n.has(a)
}
const sb = () => {},
    EC = Object.assign,
    IC = Object.prototype.hasOwnProperty,
    as = (e, t) => IC.call(e, t),
    za = Array.isArray,
    zi = e => ub(e) === "[object Map]",
    Cf = e => typeof e == "function",
    TC = e => typeof e == "string",
    Hs = e => typeof e == "symbol",
    Zo = e => e !== null && typeof e == "object",
    VC = Object.prototype.toString,
    ub = e => VC.call(e),
    AC = e => ub(e).slice(8, -1),
    xf = e => TC(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e,
    Nr = (e, t) => !Object.is(e, t),
    LC = (e, t, n) => {
        Object.defineProperty(e, t, {
            configurable: !0,
            enumerable: !1,
            value: n
        })
    };
/**
 * @vue/reactivity v3.4.21
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
let sn;
class Pf {
    constructor(t = !1) {
        this.detached = t, this._active = !0, this.effects = [], this.cleanups = [], this.parent = sn, !t && sn && (this.index = (sn.scopes || (sn.scopes = [])).push(this) - 1)
    }
    get active() {
        return this._active
    }
    run(t) {
        if (this._active) {
            const n = sn;
            try {
                return sn = this, t()
            } finally {
                sn = n
            }
        }
    }
    on() {
        sn = this
    }
    off() {
        sn = this.parent
    }
    stop(t) {
        if (this._active) {
            let n, a;
            for (n = 0, a = this.effects.length; n < a; n++) this.effects[n].stop();
            for (n = 0, a = this.cleanups.length; n < a; n++) this.cleanups[n]();
            if (this.scopes)
                for (n = 0, a = this.scopes.length; n < a; n++) this.scopes[n].stop(!0);
            if (!this.detached && this.parent && !t) {
                const l = this.parent.scopes.pop();
                l && l !== this && (this.parent.scopes[this.index] = l, l.index = this.index)
            }
            this.parent = void 0, this._active = !1
        }
    }
}

function xa(e) {
    return new Pf(e)
}

function cb(e, t = sn) {
    t && t.active && t.effects.push(e)
}

function $r() {
    return sn
}

function kt(e) {
    sn && sn.cleanups.push(e)
}
let pl;
class Sr {
    constructor(t, n, a, l) {
        this.fn = t, this.trigger = n, this.scheduler = a, this.active = !0, this.deps = [], this._dirtyLevel = 4, this._trackId = 0, this._runnings = 0, this._shouldSchedule = !1, this._depsLength = 0, cb(this, l)
    }
    get dirty() {
        if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
            this._dirtyLevel = 1, Bl();
            for (let t = 0; t < this._depsLength; t++) {
                const n = this.deps[t];
                if (n.computed && (OC(n.computed), this._dirtyLevel >= 4)) break
            }
            this._dirtyLevel === 1 && (this._dirtyLevel = 0), Fl()
        }
        return this._dirtyLevel >= 4
    }
    set dirty(t) {
        this._dirtyLevel = t ? 4 : 0
    }
    run() {
        if (this._dirtyLevel = 0, !this.active) return this.fn();
        let t = Ka,
            n = pl;
        try {
            return Ka = !0, pl = this, this._runnings++, Am(this), this.fn()
        } finally {
            Lm(this), this._runnings--, pl = n, Ka = t
        }
    }
    stop() {
        var t;
        this.active && (Am(this), Lm(this), (t = this.onStop) == null || t.call(this), this.active = !1)
    }
}

function OC(e) {
    return e.value
}

function Am(e) {
    e._trackId++, e._depsLength = 0
}

function Lm(e) {
    if (e.deps.length > e._depsLength) {
        for (let t = e._depsLength; t < e.deps.length; t++) db(e.deps[t], e);
        e.deps.length = e._depsLength
    }
}

function db(e, t) {
    const n = e.get(t);
    n !== void 0 && t._trackId !== n && (e.delete(t), e.size === 0 && e.cleanup())
}

function RC(e, t) {
    e.effect instanceof Sr && (e = e.effect.fn);
    const n = new Sr(e, sb, () => {
        n.dirty && n.run()
    });
    t && (EC(n, t), t.scope && cb(n, t.scope)), (!t || !t.lazy) && n.run();
    const a = n.run.bind(n);
    return a.effect = n, a
}

function DC(e) {
    e.effect.stop()
}
let Ka = !0,
    Vc = 0;
const fb = [];

function Bl() {
    fb.push(Ka), Ka = !1
}

function Fl() {
    const e = fb.pop();
    Ka = e === void 0 ? !0 : e
}

function Ef() {
    Vc++
}

function If() {
    for (Vc--; !Vc && Ac.length;) Ac.shift()()
}

function vb(e, t, n) {
    if (t.get(e) !== e._trackId) {
        t.set(e, e._trackId);
        const a = e.deps[e._depsLength];
        a !== t ? (a && db(a, e), e.deps[e._depsLength++] = t) : e._depsLength++
    }
}
const Ac = [];

function mb(e, t, n) {
    Ef();
    for (const a of e.keys()) {
        let l;
        a._dirtyLevel < t && (l ? ? (l = e.get(a) === a._trackId)) && (a._shouldSchedule || (a._shouldSchedule = a._dirtyLevel === 0), a._dirtyLevel = t), a._shouldSchedule && (l ? ? (l = e.get(a) === a._trackId)) && (a.trigger(), (!a._runnings || a.allowRecurse) && a._dirtyLevel !== 2 && (a._shouldSchedule = !1, a.scheduler && Ac.push(a.scheduler)))
    }
    If()
}
const hb = (e, t) => {
        const n = new Map;
        return n.cleanup = e, n.computed = t, n
    },
    ls = new WeakMap,
    _l = Symbol(""),
    Lc = Symbol("");

function Zt(e, t, n) {
    if (Ka && pl) {
        let a = ls.get(e);
        a || ls.set(e, a = new Map);
        let l = a.get(n);
        l || a.set(n, l = hb(() => a.delete(n))), vb(pl, l)
    }
}

function ba(e, t, n, a, l, r) {
    const o = ls.get(e);
    if (!o) return;
    let i = [];
    if (t === "clear") i = [...o.values()];
    else if (n === "length" && za(e)) {
        const s = Number(a);
        o.forEach((u, c) => {
            (c === "length" || !Hs(c) && c >= s) && i.push(u)
        })
    } else switch (n !== void 0 && i.push(o.get(n)), t) {
        case "add":
            za(e) ? xf(n) && i.push(o.get("length")) : (i.push(o.get(_l)), zi(e) && i.push(o.get(Lc)));
            break;
        case "delete":
            za(e) || (i.push(o.get(_l)), zi(e) && i.push(o.get(Lc)));
            break;
        case "set":
            zi(e) && i.push(o.get(_l));
            break
    }
    Ef();
    for (const s of i) s && mb(s, 4);
    If()
}

function MC(e, t) {
    var n;
    return (n = ls.get(e)) == null ? void 0 : n.get(t)
}
const NC = PC("__proto__,__v_isRef,__isVue"),
    gb = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(Hs)),
    Om = $C();

function $C() {
    const e = {};
    return ["includes", "indexOf", "lastIndexOf"].forEach(t => {
        e[t] = function(...n) {
            const a = xe(this);
            for (let r = 0, o = this.length; r < o; r++) Zt(a, "get", r + "");
            const l = a[t](...n);
            return l === -1 || l === !1 ? a[t](...n.map(xe)) : l
        }
    }), ["push", "pop", "shift", "unshift", "splice"].forEach(t => {
        e[t] = function(...n) {
            Bl(), Ef();
            const a = xe(this)[t].apply(this, n);
            return If(), Fl(), a
        }
    }), e
}

function BC(e) {
    const t = xe(this);
    return Zt(t, "has", e), t.hasOwnProperty(e)
}
class yb {
    constructor(t = !1, n = !1) {
        this._isReadonly = t, this._isShallow = n
    }
    get(t, n, a) {
        const l = this._isReadonly,
            r = this._isShallow;
        if (n === "__v_isReactive") return !l;
        if (n === "__v_isReadonly") return l;
        if (n === "__v_isShallow") return r;
        if (n === "__v_raw") return a === (l ? r ? kb : wb : r ? Sb : _b).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(a) ? t : void 0;
        const o = za(t);
        if (!l) {
            if (o && as(Om, n)) return Reflect.get(Om, n, a);
            if (n === "hasOwnProperty") return BC
        }
        const i = Reflect.get(t, n, a);
        return (Hs(n) ? gb.has(n) : NC(n)) || (l || Zt(t, "get", n), r) ? i : Ge(i) ? o && xf(n) ? i : i.value : Zo(i) ? l ? Br(i) : mt(i) : i
    }
}
class bb extends yb {
    constructor(t = !1) {
        super(!1, t)
    }
    set(t, n, a, l) {
        let r = t[n];
        if (!this._isShallow) {
            const s = Ya(r);
            if (!_o(a) && !Ya(a) && (r = xe(r), a = xe(a)), !za(t) && Ge(r) && !Ge(a)) return s ? !1 : (r.value = a, !0)
        }
        const o = za(t) && xf(n) ? Number(n) < t.length : as(t, n),
            i = Reflect.set(t, n, a, l);
        return t === xe(l) && (o ? Nr(a, r) && ba(t, "set", n, a) : ba(t, "add", n, a)), i
    }
    deleteProperty(t, n) {
        const a = as(t, n);
        t[n];
        const l = Reflect.deleteProperty(t, n);
        return l && a && ba(t, "delete", n, void 0), l
    }
    has(t, n) {
        const a = Reflect.has(t, n);
        return (!Hs(n) || !gb.has(n)) && Zt(t, "has", n), a
    }
    ownKeys(t) {
        return Zt(t, "iterate", za(t) ? "length" : _l), Reflect.ownKeys(t)
    }
}
class pb extends yb {
    constructor(t = !1) {
        super(!0, t)
    }
    set(t, n) {
        return !0
    }
    deleteProperty(t, n) {
        return !0
    }
}
const FC = new bb,
    HC = new pb,
    jC = new bb(!0),
    UC = new pb(!0),
    Tf = e => e,
    js = e => Reflect.getPrototypeOf(e);

function _i(e, t, n = !1, a = !1) {
    e = e.__v_raw;
    const l = xe(e),
        r = xe(t);
    n || (Nr(t, r) && Zt(l, "get", t), Zt(l, "get", r));
    const {
        has: o
    } = js(l), i = a ? Tf : n ? Af : So;
    if (o.call(l, t)) return i(e.get(t));
    if (o.call(l, r)) return i(e.get(r));
    e !== l && e.get(t)
}

function Si(e, t = !1) {
    const n = this.__v_raw,
        a = xe(n),
        l = xe(e);
    return t || (Nr(e, l) && Zt(a, "has", e), Zt(a, "has", l)), e === l ? n.has(e) : n.has(e) || n.has(l)
}

function wi(e, t = !1) {
    return e = e.__v_raw, !t && Zt(xe(e), "iterate", _l), Reflect.get(e, "size", e)
}

function Rm(e) {
    e = xe(e);
    const t = xe(this);
    return js(t).has.call(t, e) || (t.add(e), ba(t, "add", e, e)), this
}

function Dm(e, t) {
    t = xe(t);
    const n = xe(this),
        {
            has: a,
            get: l
        } = js(n);
    let r = a.call(n, e);
    r || (e = xe(e), r = a.call(n, e));
    const o = l.call(n, e);
    return n.set(e, t), r ? Nr(t, o) && ba(n, "set", e, t) : ba(n, "add", e, t), this
}

function Mm(e) {
    const t = xe(this),
        {
            has: n,
            get: a
        } = js(t);
    let l = n.call(t, e);
    l || (e = xe(e), l = n.call(t, e)), a && a.call(t, e);
    const r = t.delete(e);
    return l && ba(t, "delete", e, void 0), r
}

function Nm() {
    const e = xe(this),
        t = e.size !== 0,
        n = e.clear();
    return t && ba(e, "clear", void 0, void 0), n
}

function ki(e, t) {
    return function(a, l) {
        const r = this,
            o = r.__v_raw,
            i = xe(o),
            s = t ? Tf : e ? Af : So;
        return !e && Zt(i, "iterate", _l), o.forEach((u, c) => a.call(l, s(u), s(c), r))
    }
}

function Ci(e, t, n) {
    return function(...a) {
        const l = this.__v_raw,
            r = xe(l),
            o = zi(r),
            i = e === "entries" || e === Symbol.iterator && o,
            s = e === "keys" && o,
            u = l[e](...a),
            c = n ? Tf : t ? Af : So;
        return !t && Zt(r, "iterate", s ? Lc : _l), {
            next() {
                const {
                    value: d,
                    done: f
                } = u.next();
                return f ? {
                    value: d,
                    done: f
                } : {
                    value: i ? [c(d[0]), c(d[1])] : c(d),
                    done: f
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}

function Va(e) {
    return function(...t) {
        return e === "delete" ? !1 : e === "clear" ? void 0 : this
    }
}

function WC() {
    const e = {
            get(r) {
                return _i(this, r)
            },
            get size() {
                return wi(this)
            },
            has: Si,
            add: Rm,
            set: Dm,
            delete: Mm,
            clear: Nm,
            forEach: ki(!1, !1)
        },
        t = {
            get(r) {
                return _i(this, r, !1, !0)
            },
            get size() {
                return wi(this)
            },
            has: Si,
            add: Rm,
            set: Dm,
            delete: Mm,
            clear: Nm,
            forEach: ki(!1, !0)
        },
        n = {
            get(r) {
                return _i(this, r, !0)
            },
            get size() {
                return wi(this, !0)
            },
            has(r) {
                return Si.call(this, r, !0)
            },
            add: Va("add"),
            set: Va("set"),
            delete: Va("delete"),
            clear: Va("clear"),
            forEach: ki(!0, !1)
        },
        a = {
            get(r) {
                return _i(this, r, !0, !0)
            },
            get size() {
                return wi(this, !0)
            },
            has(r) {
                return Si.call(this, r, !0)
            },
            add: Va("add"),
            set: Va("set"),
            delete: Va("delete"),
            clear: Va("clear"),
            forEach: ki(!0, !0)
        };
    return ["keys", "values", "entries", Symbol.iterator].forEach(r => {
        e[r] = Ci(r, !1, !1), n[r] = Ci(r, !0, !1), t[r] = Ci(r, !1, !0), a[r] = Ci(r, !0, !0)
    }), [e, n, t, a]
}
const [zC, KC, GC, YC] = WC();

function Us(e, t) {
    const n = t ? e ? YC : GC : e ? KC : zC;
    return (a, l, r) => l === "__v_isReactive" ? !e : l === "__v_isReadonly" ? e : l === "__v_raw" ? a : Reflect.get(as(n, l) && l in a ? n : a, l, r)
}
const qC = {
        get: Us(!1, !1)
    },
    XC = {
        get: Us(!1, !0)
    },
    JC = {
        get: Us(!0, !1)
    },
    ZC = {
        get: Us(!0, !0)
    },
    _b = new WeakMap,
    Sb = new WeakMap,
    wb = new WeakMap,
    kb = new WeakMap;

function QC(e) {
    switch (e) {
        case "Object":
        case "Array":
            return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
            return 2;
        default:
            return 0
    }
}

function e1(e) {
    return e.__v_skip || !Object.isExtensible(e) ? 0 : QC(AC(e))
}

function mt(e) {
    return Ya(e) ? e : Ws(e, !1, FC, qC, _b)
}

function Jn(e) {
    return Ws(e, !1, jC, XC, Sb)
}

function Br(e) {
    return Ws(e, !0, HC, JC, wb)
}

function t1(e) {
    return Ws(e, !0, UC, ZC, kb)
}

function Ws(e, t, n, a, l) {
    if (!Zo(e) || e.__v_raw && !(t && e.__v_isReactive)) return e;
    const r = l.get(e);
    if (r) return r;
    const o = e1(e);
    if (o === 0) return e;
    const i = new Proxy(e, o === 2 ? a : n);
    return l.set(e, i), i
}

function pa(e) {
    return Ya(e) ? pa(e.__v_raw) : !!(e && e.__v_isReactive)
}

function Ya(e) {
    return !!(e && e.__v_isReadonly)
}

function _o(e) {
    return !!(e && e.__v_isShallow)
}

function Vf(e) {
    return pa(e) || Ya(e)
}

function xe(e) {
    const t = e && e.__v_raw;
    return t ? xe(t) : e
}

function Fr(e) {
    return Object.isExtensible(e) && LC(e, "__v_skip", !0), e
}
const So = e => Zo(e) ? mt(e) : e,
    Af = e => Zo(e) ? Br(e) : e;
class Cb {
    constructor(t, n, a, l) {
        this.getter = t, this._setter = n, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this.effect = new Sr(() => t(this._value), () => mr(this, this.effect._dirtyLevel === 2 ? 2 : 3)), this.effect.computed = this, this.effect.active = this._cacheable = !l, this.__v_isReadonly = a
    }
    get value() {
        const t = xe(this);
        return (!t._cacheable || t.effect.dirty) && Nr(t._value, t._value = t.effect.run()) && mr(t, 4), Lf(t), t.effect._dirtyLevel >= 2 && mr(t, 2), t._value
    }
    set value(t) {
        this._setter(t)
    }
    get _dirty() {
        return this.effect.dirty
    }
    set _dirty(t) {
        this.effect.dirty = t
    }
}

function n1(e, t, n = !1) {
    let a, l;
    const r = Cf(e);
    return r ? (a = e, l = sb) : (a = e.get, l = e.set), new Cb(a, l, r || !l, n)
}

function Lf(e) {
    var t;
    Ka && pl && (e = xe(e), vb(pl, (t = e.dep) != null ? t : e.dep = hb(() => e.dep = void 0, e instanceof Cb ? e : void 0)))
}

function mr(e, t = 4, n) {
    e = xe(e);
    const a = e.dep;
    a && mb(a, t)
}

function Ge(e) {
    return !!(e && e.__v_isRef === !0)
}

function Q(e) {
    return xb(e, !1)
}

function fe(e) {
    return xb(e, !0)
}

function xb(e, t) {
    return Ge(e) ? e : new a1(e, t)
}
class a1 {
    constructor(t, n) {
        this.__v_isShallow = n, this.dep = void 0, this.__v_isRef = !0, this._rawValue = n ? t : xe(t), this._value = n ? t : So(t)
    }
    get value() {
        return Lf(this), this._value
    }
    set value(t) {
        const n = this.__v_isShallow || _o(t) || Ya(t);
        t = n ? t : xe(t), Nr(t, this._rawValue) && (this._rawValue = t, this._value = n ? t : So(t), mr(this, 4))
    }
}

function l1(e) {
    mr(e, 4)
}

function Ie(e) {
    return Ge(e) ? e.value : e
}

function r1(e) {
    return Cf(e) ? e() : Ie(e)
}
const o1 = {
    get: (e, t, n) => Ie(Reflect.get(e, t, n)),
    set: (e, t, n, a) => {
        const l = e[t];
        return Ge(l) && !Ge(n) ? (l.value = n, !0) : Reflect.set(e, t, n, a)
    }
};

function Of(e) {
    return pa(e) ? e : new Proxy(e, o1)
}
class i1 {
    constructor(t) {
        this.dep = void 0, this.__v_isRef = !0;
        const {
            get: n,
            set: a
        } = t(() => Lf(this), () => mr(this));
        this._get = n, this._set = a
    }
    get value() {
        return this._get()
    }
    set value(t) {
        this._set(t)
    }
}

function Rf(e) {
    return new i1(e)
}

function ta(e) {
    const t = za(e) ? new Array(e.length) : {};
    for (const n in e) t[n] = Pb(e, n);
    return t
}
class s1 {
    constructor(t, n, a) {
        this._object = t, this._key = n, this._defaultValue = a, this.__v_isRef = !0
    }
    get value() {
        const t = this._object[this._key];
        return t === void 0 ? this._defaultValue : t
    }
    set value(t) {
        this._object[this._key] = t
    }
    get dep() {
        return MC(xe(this._object), this._key)
    }
}
class u1 {
    constructor(t) {
        this._getter = t, this.__v_isRef = !0, this.__v_isReadonly = !0
    }
    get value() {
        return this._getter()
    }
}

function Y(e, t, n) {
    return Ge(e) ? e : Cf(e) ? new u1(e) : Zo(e) && arguments.length > 1 ? Pb(e, t, n) : Q(e)
}

function Pb(e, t, n) {
    const a = e[t];
    return Ge(a) ? a : new s1(e, t, n)
}
const c1 = {
        GET: "get",
        HAS: "has",
        ITERATE: "iterate"
    },
    d1 = {
        SET: "set",
        ADD: "add",
        DELETE: "delete",
        CLEAR: "clear"
    };
/**
 * @vue/shared v3.4.21
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
function Eb(e, t) {
    const n = new Set(e.split(","));
    return a => n.has(a)
}
const tt = {},
    hr = [],
    Pn = () => {},
    f1 = () => !1,
    zs = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97),
    Ib = e => e.startsWith("onUpdate:"),
    Lt = Object.assign,
    Df = (e, t) => {
        const n = e.indexOf(t);
        n > -1 && e.splice(n, 1)
    },
    v1 = Object.prototype.hasOwnProperty,
    Xe = (e, t) => v1.call(e, t),
    Me = Array.isArray,
    Tb = e => Ks(e) === "[object Map]",
    Vb = e => Ks(e) === "[object Set]",
    m1 = e => Ks(e) === "[object RegExp]",
    De = e => typeof e == "function",
    Tt = e => typeof e == "string",
    Ab = e => typeof e == "symbol",
    wt = e => e !== null && typeof e == "object",
    Mf = e => (wt(e) || De(e)) && De(e.then) && De(e.catch),
    Lb = Object.prototype.toString,
    Ks = e => Lb.call(e),
    Ob = e => Ks(e) === "[object Object]",
    gr = Eb(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
    Gs = e => {
        const t = Object.create(null);
        return n => t[n] || (t[n] = e(n))
    },
    h1 = /-(\w)/g,
    Qt = Gs(e => e.replace(h1, (t, n) => n ? n.toUpperCase() : "")),
    g1 = /\B([A-Z])/g,
    Qo = Gs(e => e.replace(g1, "-$1").toLowerCase()),
    na = Gs(e => e.charAt(0).toUpperCase() + e.slice(1)),
    so = Gs(e => e ? `on${na(e)}` : ""),
    wo = (e, t) => !Object.is(e, t),
    uo = (e, t) => {
        for (let n = 0; n < e.length; n++) e[n](t)
    },
    Oc = (e, t, n) => {
        Object.defineProperty(e, t, {
            configurable: !0,
            enumerable: !1,
            value: n
        })
    },
    y1 = e => {
        const t = parseFloat(e);
        return isNaN(t) ? e : t
    },
    b1 = e => {
        const t = Tt(e) ? Number(e) : NaN;
        return isNaN(t) ? e : t
    };
let $m;
const Rb = () => $m || ($m = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}),
    p1 = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error",
    _1 = Eb(p1);

function ei(e) {
    if (Me(e)) {
        const t = {};
        for (let n = 0; n < e.length; n++) {
            const a = e[n],
                l = Tt(a) ? C1(a) : ei(a);
            if (l)
                for (const r in l) t[r] = l[r]
        }
        return t
    } else if (Tt(e) || wt(e)) return e
}
const S1 = /;(?![^(]*\))/g,
    w1 = /:([^]+)/,
    k1 = /\/\*[^]*?\*\//g;

function C1(e) {
    const t = {};
    return e.replace(k1, "").split(S1).forEach(n => {
        if (n) {
            const a = n.split(w1);
            a.length > 1 && (t[a[0].trim()] = a[1].trim())
        }
    }), t
}

function Hr(e) {
    let t = "";
    if (Tt(e)) t = e;
    else if (Me(e))
        for (let n = 0; n < e.length; n++) {
            const a = Hr(e[n]);
            a && (t += a + " ")
        } else if (wt(e))
            for (const n in e) e[n] && (t += n + " ");
    return t.trim()
}

function Db(e) {
    if (!e) return null;
    let {
        class: t,
        style: n
    } = e;
    return t && !Tt(t) && (e.class = Hr(t)), n && (e.style = ei(n)), e
}
const Mb = e => Tt(e) ? e : e == null ? "" : Me(e) || wt(e) && (e.toString === Lb || !De(e.toString)) ? JSON.stringify(e, Nb, 2) : String(e),
    Nb = (e, t) => t && t.__v_isRef ? Nb(e, t.value) : Tb(t) ? {
        [`Map(${t.size})`]: [...t.entries()].reduce((n, [a, l], r) => (n[Ju(a, r) + " =>"] = l, n), {})
    } : Vb(t) ? {
        [`Set(${t.size})`]: [...t.values()].map(n => Ju(n))
    } : Ab(t) ? Ju(t) : wt(t) && !Me(t) && !Ob(t) ? String(t) : t,
    Ju = (e, t = "") => {
        var n;
        return Ab(e) ? `Symbol(${(n=e.description)!=null?n:t})` : e
    };
/**
 * @vue/runtime-core v3.4.21
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
function x1(e, t) {}
const P1 = {
        SETUP_FUNCTION: 0,
        0: "SETUP_FUNCTION",
        RENDER_FUNCTION: 1,
        1: "RENDER_FUNCTION",
        WATCH_GETTER: 2,
        2: "WATCH_GETTER",
        WATCH_CALLBACK: 3,
        3: "WATCH_CALLBACK",
        WATCH_CLEANUP: 4,
        4: "WATCH_CLEANUP",
        NATIVE_EVENT_HANDLER: 5,
        5: "NATIVE_EVENT_HANDLER",
        COMPONENT_EVENT_HANDLER: 6,
        6: "COMPONENT_EVENT_HANDLER",
        VNODE_HOOK: 7,
        7: "VNODE_HOOK",
        DIRECTIVE_HOOK: 8,
        8: "DIRECTIVE_HOOK",
        TRANSITION_HOOK: 9,
        9: "TRANSITION_HOOK",
        APP_ERROR_HANDLER: 10,
        10: "APP_ERROR_HANDLER",
        APP_WARN_HANDLER: 11,
        11: "APP_WARN_HANDLER",
        FUNCTION_REF: 12,
        12: "FUNCTION_REF",
        ASYNC_COMPONENT_LOADER: 13,
        13: "ASYNC_COMPONENT_LOADER",
        SCHEDULER: 14,
        14: "SCHEDULER"
    },
    E1 = {
        sp: "serverPrefetch hook",
        bc: "beforeCreate hook",
        c: "created hook",
        bm: "beforeMount hook",
        m: "mounted hook",
        bu: "beforeUpdate hook",
        u: "updated",
        bum: "beforeUnmount hook",
        um: "unmounted hook",
        a: "activated hook",
        da: "deactivated hook",
        ec: "errorCaptured hook",
        rtc: "renderTracked hook",
        rtg: "renderTriggered hook",
        0: "setup function",
        1: "render function",
        2: "watcher getter",
        3: "watcher callback",
        4: "watcher cleanup function",
        5: "native event handler",
        6: "component event handler",
        7: "vnode hook",
        8: "directive hook",
        9: "transition hook",
        10: "app errorHandler",
        11: "app warnHandler",
        12: "ref function",
        13: "async component loader",
        14: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://github.com/vuejs/core ."
    };

function _a(e, t, n, a) {
    try {
        return a ? e(...a) : e()
    } catch (l) {
        Hl(l, t, n)
    }
}

function vn(e, t, n, a) {
    if (De(e)) {
        const r = _a(e, t, n, a);
        return r && Mf(r) && r.catch(o => {
            Hl(o, t, n)
        }), r
    }
    const l = [];
    for (let r = 0; r < e.length; r++) l.push(vn(e[r], t, n, a));
    return l
}

function Hl(e, t, n, a = !0) {
    const l = t ? t.vnode : null;
    if (t) {
        let r = t.parent;
        const o = t.proxy,
            i = `https://vuejs.org/error-reference/#runtime-${n}`;
        for (; r;) {
            const u = r.ec;
            if (u) {
                for (let c = 0; c < u.length; c++)
                    if (u[c](e, o, i) === !1) return
            }
            r = r.parent
        }
        const s = t.appContext.config.errorHandler;
        if (s) {
            _a(s, null, 10, [e, o, i]);
            return
        }
    }
    I1(e, n, l, a)
}

function I1(e, t, n, a = !0) {
    console.error(e)
}
let ko = !1,
    Rc = !1;
const Ft = [];
let Yn = 0;
const yr = [];
let Na = null,
    ml = 0;
const $b = Promise.resolve();
let Nf = null;

function Re(e) {
    const t = Nf || $b;
    return e ? t.then(this ? e.bind(this) : e) : t
}

function T1(e) {
    let t = Yn + 1,
        n = Ft.length;
    for (; t < n;) {
        const a = t + n >>> 1,
            l = Ft[a],
            r = Co(l);
        r < e || r === e && l.pre ? t = a + 1 : n = a
    }
    return t
}

function Ys(e) {
    (!Ft.length || !Ft.includes(e, ko && e.allowRecurse ? Yn + 1 : Yn)) && (e.id == null ? Ft.push(e) : Ft.splice(T1(e.id), 0, e), Bb())
}

function Bb() {
    !ko && !Rc && (Rc = !0, Nf = $b.then(Fb))
}

function V1(e) {
    const t = Ft.indexOf(e);
    t > Yn && Ft.splice(t, 1)
}

function rs(e) {
    Me(e) ? yr.push(...e) : (!Na || !Na.includes(e, e.allowRecurse ? ml + 1 : ml)) && yr.push(e), Bb()
}

function Bm(e, t, n = ko ? Yn + 1 : 0) {
    for (; n < Ft.length; n++) {
        const a = Ft[n];
        if (a && a.pre) {
            if (e && a.id !== e.uid) continue;
            Ft.splice(n, 1), n--, a()
        }
    }
}

function os(e) {
    if (yr.length) {
        const t = [...new Set(yr)].sort((n, a) => Co(n) - Co(a));
        if (yr.length = 0, Na) {
            Na.push(...t);
            return
        }
        for (Na = t, ml = 0; ml < Na.length; ml++) Na[ml]();
        Na = null, ml = 0
    }
}
const Co = e => e.id == null ? 1 / 0 : e.id,
    A1 = (e, t) => {
        const n = Co(e) - Co(t);
        if (n === 0) {
            if (e.pre && !t.pre) return -1;
            if (t.pre && !e.pre) return 1
        }
        return n
    };

function Fb(e) {
    Rc = !1, ko = !0, Ft.sort(A1);
    try {
        for (Yn = 0; Yn < Ft.length; Yn++) {
            const t = Ft[Yn];
            t && t.active !== !1 && _a(t, null, 14)
        }
    } finally {
        Yn = 0, Ft.length = 0, os(), ko = !1, Nf = null, (Ft.length || yr.length) && Fb()
    }
}
let ir, xi = [];

function Hb(e, t) {
    var n, a;
    ir = e, ir ? (ir.enabled = !0, xi.forEach(({
        event: l,
        args: r
    }) => ir.emit(l, ...r)), xi = []) : typeof window < "u" && window.HTMLElement && !((a = (n = window.navigator) == null ? void 0 : n.userAgent) != null && a.includes("jsdom")) ? ((t.__VUE_DEVTOOLS_HOOK_REPLAY__ = t.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push(r => {
        Hb(r, t)
    }), setTimeout(() => {
        ir || (t.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, xi = [])
    }, 3e3)) : xi = []
}

function L1(e, t, ...n) {
    if (e.isUnmounted) return;
    const a = e.vnode.props || tt;
    let l = n;
    const r = t.startsWith("update:"),
        o = r && t.slice(7);
    if (o && o in a) {
        const c = `${o==="modelValue"?"model":o}Modifiers`,
            {
                number: d,
                trim: f
            } = a[c] || tt;
        f && (l = n.map(v => Tt(v) ? v.trim() : v)), d && (l = n.map(y1))
    }
    let i, s = a[i = so(t)] || a[i = so(Qt(t))];
    !s && r && (s = a[i = so(Qo(t))]), s && vn(s, e, 6, l);
    const u = a[i + "Once"];
    if (u) {
        if (!e.emitted) e.emitted = {};
        else if (e.emitted[i]) return;
        e.emitted[i] = !0, vn(u, e, 6, l)
    }
}

function jb(e, t, n = !1) {
    const a = t.emitsCache,
        l = a.get(e);
    if (l !== void 0) return l;
    const r = e.emits;
    let o = {},
        i = !1;
    if (!De(e)) {
        const s = u => {
            const c = jb(u, t, !0);
            c && (i = !0, Lt(o, c))
        };
        !n && t.mixins.length && t.mixins.forEach(s), e.extends && s(e.extends), e.mixins && e.mixins.forEach(s)
    }
    return !r && !i ? (wt(e) && a.set(e, null), null) : (Me(r) ? r.forEach(s => o[s] = null) : Lt(o, r), wt(e) && a.set(e, o), o)
}

function qs(e, t) {
    return !e || !zs(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), Xe(e, t[0].toLowerCase() + t.slice(1)) || Xe(e, Qo(t)) || Xe(e, t))
}
let St = null,
    Xs = null;

function xo(e) {
    const t = St;
    return St = e, Xs = e && e.type.__scopeId || null, t
}

function O1(e) {
    Xs = e
}

function R1() {
    Xs = null
}
const D1 = e => Js;

function Js(e, t = St, n) {
    if (!t || e._n) return e;
    const a = (...l) => {
        a._d && jc(-1);
        const r = xo(t);
        let o;
        try {
            o = e(...l)
        } finally {
            xo(r), a._d && jc(1)
        }
        return o
    };
    return a._n = !0, a._c = !0, a._d = !0, a
}

function Ki(e) {
    const {
        type: t,
        vnode: n,
        proxy: a,
        withProxy: l,
        props: r,
        propsOptions: [o],
        slots: i,
        attrs: s,
        emit: u,
        render: c,
        renderCache: d,
        data: f,
        setupState: v,
        ctx: g,
        inheritAttrs: h
    } = e;
    let y, S;
    const b = xo(e);
    try {
        if (n.shapeFlag & 4) {
            const _ = l || a,
                w = _;
            y = cn(c.call(w, _, d, r, v, f, g)), S = s
        } else {
            const _ = t;
            y = cn(_.length > 1 ? _(r, {
                attrs: s,
                slots: i,
                emit: u
            }) : _(r, null)), S = t.props ? s : N1(s)
        }
    } catch (_) {
        vo.length = 0, Hl(_, e, 1), y = m(Nt)
    }
    let p = y;
    if (S && h !== !1) {
        const _ = Object.keys(S),
            {
                shapeFlag: w
            } = p;
        _.length && w & 7 && (o && _.some(Ib) && (S = $1(S, o)), p = $n(p, S))
    }
    return n.dirs && (p = $n(p), p.dirs = p.dirs ? p.dirs.concat(n.dirs) : n.dirs), n.transition && (p.transition = n.transition), y = p, xo(b), y
}

function M1(e, t = !0) {
    let n;
    for (let a = 0; a < e.length; a++) {
        const l = e[a];
        if (wa(l)) {
            if (l.type !== Nt || l.children === "v-if") {
                if (n) return;
                n = l
            }
        } else return
    }
    return n
}
const N1 = e => {
        let t;
        for (const n in e)(n === "class" || n === "style" || zs(n)) && ((t || (t = {}))[n] = e[n]);
        return t
    },
    $1 = (e, t) => {
        const n = {};
        for (const a in e)(!Ib(a) || !(a.slice(9) in t)) && (n[a] = e[a]);
        return n
    };

function B1(e, t, n) {
    const {
        props: a,
        children: l,
        component: r
    } = e, {
        props: o,
        children: i,
        patchFlag: s
    } = t, u = r.emitsOptions;
    if (t.dirs || t.transition) return !0;
    if (n && s >= 0) {
        if (s & 1024) return !0;
        if (s & 16) return a ? Fm(a, o, u) : !!o;
        if (s & 8) {
            const c = t.dynamicProps;
            for (let d = 0; d < c.length; d++) {
                const f = c[d];
                if (o[f] !== a[f] && !qs(u, f)) return !0
            }
        }
    } else return (l || i) && (!i || !i.$stable) ? !0 : a === o ? !1 : a ? o ? Fm(a, o, u) : !0 : !!o;
    return !1
}

function Fm(e, t, n) {
    const a = Object.keys(t);
    if (a.length !== Object.keys(e).length) return !0;
    for (let l = 0; l < a.length; l++) {
        const r = a[l];
        if (t[r] !== e[r] && !qs(n, r)) return !0
    }
    return !1
}

function $f({
    vnode: e,
    parent: t
}, n) {
    for (; t;) {
        const a = t.subTree;
        if (a.suspense && a.suspense.activeBranch === e && (a.el = e.el), a === e)(e = t.vnode).el = n, t = t.parent;
        else break
    }
}
const Bf = "components",
    F1 = "directives";

function Ub(e, t) {
    return Hf(Bf, e, !0, t) || e
}
const Wb = Symbol.for("v-ndc");

function Ff(e) {
    return Tt(e) ? Hf(Bf, e, !1) || e : e || Wb
}

function tn(e) {
    return Hf(F1, e)
}

function Hf(e, t, n = !0, a = !1) {
    const l = St || Et;
    if (l) {
        const r = l.type;
        if (e === Bf) {
            const i = Gc(r, !1);
            if (i && (i === t || i === Qt(t) || i === na(Qt(t)))) return r
        }
        const o = Hm(l[e] || r[e], t) || Hm(l.appContext[e], t);
        return !o && a ? r : o
    }
}

function Hm(e, t) {
    return e && (e[t] || e[Qt(t)] || e[na(Qt(t))])
}
const zb = e => e.__isSuspense;
let Dc = 0;
const H1 = {
        name: "Suspense",
        __isSuspense: !0,
        process(e, t, n, a, l, r, o, i, s, u) {
            if (e == null) j1(t, n, a, l, r, o, i, s, u);
            else {
                if (r && r.deps > 0 && !e.suspense.isInFallback) {
                    t.suspense = e.suspense, t.suspense.vnode = t, t.el = e.el;
                    return
                }
                U1(e, t, n, a, l, o, i, s, u)
            }
        },
        hydrate: W1,
        create: Uf,
        normalize: z1
    },
    jf = H1;

function Po(e, t) {
    const n = e.props && e.props[t];
    De(n) && n()
}

function j1(e, t, n, a, l, r, o, i, s) {
    const {
        p: u,
        o: {
            createElement: c
        }
    } = s, d = c("div"), f = e.suspense = Uf(e, l, a, t, d, n, r, o, i, s);
    u(null, f.pendingBranch = e.ssContent, d, null, a, f, r, o), f.deps > 0 ? (Po(e, "onPending"), Po(e, "onFallback"), u(null, e.ssFallback, t, n, a, null, r, o), br(f, e.ssFallback)) : f.resolve(!1, !0)
}

function U1(e, t, n, a, l, r, o, i, {
    p: s,
    um: u,
    o: {
        createElement: c
    }
}) {
    const d = t.suspense = e.suspense;
    d.vnode = t, t.el = e.el;
    const f = t.ssContent,
        v = t.ssFallback,
        {
            activeBranch: g,
            pendingBranch: h,
            isInFallback: y,
            isHydrating: S
        } = d;
    if (h) d.pendingBranch = f, Nn(f, h) ? (s(h, f, d.hiddenContainer, null, l, d, r, o, i), d.deps <= 0 ? d.resolve() : y && (S || (s(g, v, n, a, l, null, r, o, i), br(d, v)))) : (d.pendingId = Dc++, S ? (d.isHydrating = !1, d.activeBranch = h) : u(h, l, d), d.deps = 0, d.effects.length = 0, d.hiddenContainer = c("div"), y ? (s(null, f, d.hiddenContainer, null, l, d, r, o, i), d.deps <= 0 ? d.resolve() : (s(g, v, n, a, l, null, r, o, i), br(d, v))) : g && Nn(f, g) ? (s(g, f, n, a, l, d, r, o, i), d.resolve(!0)) : (s(null, f, d.hiddenContainer, null, l, d, r, o, i), d.deps <= 0 && d.resolve()));
    else if (g && Nn(f, g)) s(g, f, n, a, l, d, r, o, i), br(d, f);
    else if (Po(t, "onPending"), d.pendingBranch = f, f.shapeFlag & 512 ? d.pendingId = f.component.suspenseId : d.pendingId = Dc++, s(null, f, d.hiddenContainer, null, l, d, r, o, i), d.deps <= 0) d.resolve();
    else {
        const {
            timeout: b,
            pendingId: p
        } = d;
        b > 0 ? setTimeout(() => {
            d.pendingId === p && d.fallback(v)
        }, b) : b === 0 && d.fallback(v)
    }
}

function Uf(e, t, n, a, l, r, o, i, s, u, c = !1) {
    const {
        p: d,
        m: f,
        um: v,
        n: g,
        o: {
            parentNode: h,
            remove: y
        }
    } = u;
    let S;
    const b = K1(e);
    b && t != null && t.pendingBranch && (S = t.pendingId, t.deps++);
    const p = e.props ? b1(e.props.timeout) : void 0,
        _ = r,
        w = {
            vnode: e,
            parent: t,
            parentComponent: n,
            namespace: o,
            container: a,
            hiddenContainer: l,
            deps: 0,
            pendingId: Dc++,
            timeout: typeof p == "number" ? p : -1,
            activeBranch: null,
            pendingBranch: null,
            isInFallback: !c,
            isHydrating: c,
            isUnmounted: !1,
            effects: [],
            resolve(k = !1, E = !1) {
                const {
                    vnode: P,
                    activeBranch: x,
                    pendingBranch: T,
                    pendingId: V,
                    effects: I,
                    parentComponent: R,
                    container: B
                } = w;
                let $ = !1;
                w.isHydrating ? w.isHydrating = !1 : k || ($ = x && T.transition && T.transition.mode === "out-in", $ && (x.transition.afterLeave = () => {
                    V === w.pendingId && (f(T, B, r === _ ? g(x) : r, 0), rs(I))
                }), x && (h(x.el) !== w.hiddenContainer && (r = g(x)), v(x, R, w, !0)), $ || f(T, B, r, 0)), br(w, T), w.pendingBranch = null, w.isInFallback = !1;
                let D = w.parent,
                    z = !1;
                for (; D;) {
                    if (D.pendingBranch) {
                        D.effects.push(...I), z = !0;
                        break
                    }
                    D = D.parent
                }!z && !$ && rs(I), w.effects = [], b && t && t.pendingBranch && S === t.pendingId && (t.deps--, t.deps === 0 && !E && t.resolve()), Po(P, "onResolve")
            },
            fallback(k) {
                if (!w.pendingBranch) return;
                const {
                    vnode: E,
                    activeBranch: P,
                    parentComponent: x,
                    container: T,
                    namespace: V
                } = w;
                Po(E, "onFallback");
                const I = g(P),
                    R = () => {
                        w.isInFallback && (d(null, k, T, I, x, null, V, i, s), br(w, k))
                    },
                    B = k.transition && k.transition.mode === "out-in";
                B && (P.transition.afterLeave = R), w.isInFallback = !0, v(P, x, null, !0), B || R()
            },
            move(k, E, P) {
                w.activeBranch && f(w.activeBranch, k, E, P), w.container = k
            },
            next() {
                return w.activeBranch && g(w.activeBranch)
            },
            registerDep(k, E) {
                const P = !!w.pendingBranch;
                P && w.deps++;
                const x = k.vnode.el;
                k.asyncDep.catch(T => {
                    Hl(T, k, 0)
                }).then(T => {
                    if (k.isUnmounted || w.isUnmounted || w.pendingId !== k.suspenseId) return;
                    k.asyncResolved = !0;
                    const {
                        vnode: V
                    } = k;
                    zc(k, T, !1), x && (V.el = x);
                    const I = !x && k.subTree.el;
                    E(k, V, h(x || k.subTree.el), x ? null : g(k.subTree), w, o, s), I && y(I), $f(k, V.el), P && --w.deps === 0 && w.resolve()
                })
            },
            unmount(k, E) {
                w.isUnmounted = !0, w.activeBranch && v(w.activeBranch, n, k, E), w.pendingBranch && v(w.pendingBranch, n, k, E)
            }
        };
    return w
}

function W1(e, t, n, a, l, r, o, i, s) {
    const u = t.suspense = Uf(t, a, n, e.parentNode, document.createElement("div"), null, l, r, o, i, !0),
        c = s(e, u.pendingBranch = t.ssContent, n, u, r, o);
    return u.deps === 0 && u.resolve(!1, !0), c
}

function z1(e) {
    const {
        shapeFlag: t,
        children: n
    } = e, a = t & 32;
    e.ssContent = jm(a ? n.default : n), e.ssFallback = a ? jm(n.fallback) : m(Nt)
}

function jm(e) {
    let t;
    if (De(e)) {
        const n = Tl && e._c;
        n && (e._d = !1, Cn()), e = e(), n && (e._d = !0, t = Jt, Sp())
    }
    return Me(e) && (e = M1(e)), e = cn(e), t && !e.dynamicChildren && (e.dynamicChildren = t.filter(n => n !== e)), e
}

function Kb(e, t) {
    t && t.pendingBranch ? Me(e) ? t.effects.push(...e) : t.effects.push(e) : rs(e)
}

function br(e, t) {
    e.activeBranch = t;
    const {
        vnode: n,
        parentComponent: a
    } = e;
    let l = t.el;
    for (; !l && t.component;) t = t.component.subTree, l = t.el;
    n.el = l, a && a.subTree === n && (a.vnode.el = l, $f(a, l))
}

function K1(e) {
    var t;
    return ((t = e.props) == null ? void 0 : t.suspensible) != null && e.props.suspensible !== !1
}
const Gb = Symbol.for("v-scx"),
    Yb = () => Te(Gb);

function st(e, t) {
    return ti(e, null, t)
}

function qb(e, t) {
    return ti(e, null, {
        flush: "post"
    })
}

function Xb(e, t) {
    return ti(e, null, {
        flush: "sync"
    })
}
const Pi = {};

function de(e, t, n) {
    return ti(e, t, n)
}

function ti(e, t, {
    immediate: n,
    deep: a,
    flush: l,
    once: r,
    onTrack: o,
    onTrigger: i
} = tt) {
    if (t && r) {
        const k = t;
        t = (...E) => {
            k(...E), w()
        }
    }
    const s = Et,
        u = k => a === !0 ? k : hl(k, a === !1 ? 1 : void 0);
    let c, d = !1,
        f = !1;
    if (Ge(e) ? (c = () => e.value, d = _o(e)) : pa(e) ? (c = () => u(e), d = !0) : Me(e) ? (f = !0, d = e.some(k => pa(k) || _o(k)), c = () => e.map(k => {
            if (Ge(k)) return k.value;
            if (pa(k)) return u(k);
            if (De(k)) return _a(k, s, 2)
        })) : De(e) ? t ? c = () => _a(e, s, 2) : c = () => (v && v(), vn(e, s, 3, [g])) : c = Pn, t && a) {
        const k = c;
        c = () => hl(k())
    }
    let v, g = k => {
            v = p.onStop = () => {
                _a(k, s, 4), v = p.onStop = void 0
            }
        },
        h;
    if (li)
        if (g = Pn, t ? n && vn(t, s, 3, [c(), f ? [] : void 0, g]) : c(), l === "sync") {
            const k = Yb();
            h = k.__watcherHandles || (k.__watcherHandles = [])
        } else return Pn;
    let y = f ? new Array(e.length).fill(Pi) : Pi;
    const S = () => {
        if (!(!p.active || !p.dirty))
            if (t) {
                const k = p.run();
                (a || d || (f ? k.some((E, P) => wo(E, y[P])) : wo(k, y))) && (v && v(), vn(t, s, 3, [k, y === Pi ? void 0 : f && y[0] === Pi ? [] : y, g]), y = k)
            } else p.run()
    };
    S.allowRecurse = !!t;
    let b;
    l === "sync" ? b = S : l === "post" ? b = () => Mt(S, s && s.suspense) : (S.pre = !0, s && (S.id = s.uid), b = () => Ys(S));
    const p = new Sr(c, Pn, b),
        _ = $r(),
        w = () => {
            p.stop(), _ && Df(_.effects, p)
        };
    return t ? n ? S() : y = p.run() : l === "post" ? Mt(p.run.bind(p), s && s.suspense) : p.run(), h && h.push(w), w
}

function G1(e, t, n) {
    const a = this.proxy,
        l = Tt(e) ? e.includes(".") ? Jb(a, e) : () => a[e] : e.bind(a, a);
    let r;
    De(t) ? r = t : (r = t.handler, n = t);
    const o = Vl(this),
        i = ti(l, r.bind(a), n);
    return o(), i
}

function Jb(e, t) {
    const n = t.split(".");
    return () => {
        let a = e;
        for (let l = 0; l < n.length && a; l++) a = a[n[l]];
        return a
    }
}

function hl(e, t, n = 0, a) {
    if (!wt(e) || e.__v_skip) return e;
    if (t && t > 0) {
        if (n >= t) return e;
        n++
    }
    if (a = a || new Set, a.has(e)) return e;
    if (a.add(e), Ge(e)) hl(e.value, t, n, a);
    else if (Me(e))
        for (let l = 0; l < e.length; l++) hl(e[l], t, n, a);
    else if (Vb(e) || Tb(e)) e.forEach(l => {
        hl(l, t, n, a)
    });
    else if (Ob(e))
        for (const l in e) hl(e[l], t, n, a);
    return e
}

function at(e, t) {
    if (St === null) return e;
    const n = lu(St) || St.proxy,
        a = e.dirs || (e.dirs = []);
    for (let l = 0; l < t.length; l++) {
        let [r, o, i, s = tt] = t[l];
        r && (De(r) && (r = {
            mounted: r,
            updated: r
        }), r.deep && hl(o), a.push({
            dir: r,
            instance: n,
            value: o,
            oldValue: void 0,
            arg: i,
            modifiers: s
        }))
    }
    return e
}

function Gn(e, t, n, a) {
    const l = e.dirs,
        r = t && t.dirs;
    for (let o = 0; o < l.length; o++) {
        const i = l[o];
        r && (i.oldValue = r[o].value);
        let s = i.dir[a];
        s && (Bl(), vn(s, n, 8, [e.el, i, e, t]), Fl())
    }
}
const $a = Symbol("_leaveCb"),
    Ei = Symbol("_enterCb");

function Wf() {
    const e = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return it(() => {
        e.isMounted = !0
    }), Ct(() => {
        e.isUnmounting = !0
    }), e
}
const kn = [Function, Array],
    zf = {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        onBeforeEnter: kn,
        onEnter: kn,
        onAfterEnter: kn,
        onEnterCancelled: kn,
        onBeforeLeave: kn,
        onLeave: kn,
        onAfterLeave: kn,
        onLeaveCancelled: kn,
        onBeforeAppear: kn,
        onAppear: kn,
        onAfterAppear: kn,
        onAppearCancelled: kn
    },
    Y1 = {
        name: "BaseTransition",
        props: zf,
        setup(e, {
            slots: t
        }) {
            const n = nn(),
                a = Wf();
            return () => {
                const l = t.default && Zs(t.default(), !0);
                if (!l || !l.length) return;
                let r = l[0];
                if (l.length > 1) {
                    for (const f of l)
                        if (f.type !== Nt) {
                            r = f;
                            break
                        }
                }
                const o = xe(e),
                    {
                        mode: i
                    } = o;
                if (a.isLeaving) return Zu(r);
                const s = Um(r);
                if (!s) return Zu(r);
                const u = wr(s, o, a, n);
                Il(s, u);
                const c = n.subTree,
                    d = c && Um(c);
                if (d && d.type !== Nt && !Nn(s, d)) {
                    const f = wr(d, o, a, n);
                    if (Il(d, f), i === "out-in") return a.isLeaving = !0, f.afterLeave = () => {
                        a.isLeaving = !1, n.update.active !== !1 && (n.effect.dirty = !0, n.update())
                    }, Zu(r);
                    i === "in-out" && s.type !== Nt && (f.delayLeave = (v, g, h) => {
                        const y = Qb(a, d);
                        y[String(d.key)] = d, v[$a] = () => {
                            g(), v[$a] = void 0, delete u.delayedLeave
                        }, u.delayedLeave = h
                    })
                }
                return r
            }
        }
    },
    Zb = Y1;

function Qb(e, t) {
    const {
        leavingVNodes: n
    } = e;
    let a = n.get(t.type);
    return a || (a = Object.create(null), n.set(t.type, a)), a
}

function wr(e, t, n, a) {
    const {
        appear: l,
        mode: r,
        persisted: o = !1,
        onBeforeEnter: i,
        onEnter: s,
        onAfterEnter: u,
        onEnterCancelled: c,
        onBeforeLeave: d,
        onLeave: f,
        onAfterLeave: v,
        onLeaveCancelled: g,
        onBeforeAppear: h,
        onAppear: y,
        onAfterAppear: S,
        onAppearCancelled: b
    } = t, p = String(e.key), _ = Qb(n, e), w = (P, x) => {
        P && vn(P, a, 9, x)
    }, k = (P, x) => {
        const T = x[1];
        w(P, x), Me(P) ? P.every(V => V.length <= 1) && T() : P.length <= 1 && T()
    }, E = {
        mode: r,
        persisted: o,
        beforeEnter(P) {
            let x = i;
            if (!n.isMounted)
                if (l) x = h || i;
                else return;
            P[$a] && P[$a](!0);
            const T = _[p];
            T && Nn(e, T) && T.el[$a] && T.el[$a](), w(x, [P])
        },
        enter(P) {
            let x = s,
                T = u,
                V = c;
            if (!n.isMounted)
                if (l) x = y || s, T = S || u, V = b || c;
                else return;
            let I = !1;
            const R = P[Ei] = B => {
                I || (I = !0, B ? w(V, [P]) : w(T, [P]), E.delayedLeave && E.delayedLeave(), P[Ei] = void 0)
            };
            x ? k(x, [P, R]) : R()
        },
        leave(P, x) {
            const T = String(e.key);
            if (P[Ei] && P[Ei](!0), n.isUnmounting) return x();
            w(d, [P]);
            let V = !1;
            const I = P[$a] = R => {
                V || (V = !0, x(), R ? w(g, [P]) : w(v, [P]), P[$a] = void 0, _[T] === e && delete _[T])
            };
            _[T] = e, f ? k(f, [P, I]) : I()
        },
        clone(P) {
            return wr(P, t, n, a)
        }
    };
    return E
}

function Zu(e) {
    if (ni(e)) return e = $n(e), e.children = null, e
}

function Um(e) {
    return ni(e) ? e.children ? e.children[0] : void 0 : e
}

function Il(e, t) {
    e.shapeFlag & 6 && e.component ? Il(e.component.subTree, t) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t
}

function Zs(e, t = !1, n) {
    let a = [],
        l = 0;
    for (let r = 0; r < e.length; r++) {
        let o = e[r];
        const i = n == null ? o.key : String(n) + String(o.key != null ? o.key : r);
        o.type === ye ? (o.patchFlag & 128 && l++, a = a.concat(Zs(o.children, t, i))) : (t || o.type !== Nt) && a.push(i != null ? $n(o, {
            key: i
        }) : o)
    }
    if (l > 1)
        for (let r = 0; r < a.length; r++) a[r].patchFlag = -2;
    return a
} /*! #__NO_SIDE_EFFECTS__ */
function Ln(e, t) {
    return De(e) ? Lt({
        name: e.name
    }, t, {
        setup: e
    }) : e
}
const Sl = e => !!e.type.__asyncLoader; /*! #__NO_SIDE_EFFECTS__ */
function mn(e) {
    De(e) && (e = {
        loader: e
    });
    const {
        loader: t,
        loadingComponent: n,
        errorComponent: a,
        delay: l = 200,
        timeout: r,
        suspensible: o = !0,
        onError: i
    } = e;
    let s = null,
        u, c = 0;
    const d = () => (c++, s = null, f()),
        f = () => {
            let v;
            return s || (v = s = t().catch(g => {
                if (g = g instanceof Error ? g : new Error(String(g)), i) return new Promise((h, y) => {
                    i(g, () => h(d()), () => y(g), c + 1)
                });
                throw g
            }).then(g => v !== s && s ? s : (g && (g.__esModule || g[Symbol.toStringTag] === "Module") && (g = g.default), u = g, g)))
        };
    return Ln({
        name: "AsyncComponentWrapper",
        __asyncLoader: f,
        get __asyncResolved() {
            return u
        },
        setup() {
            const v = Et;
            if (u) return () => Qu(u, v);
            const g = b => {
                s = null, Hl(b, v, 13, !a)
            };
            if (o && v.suspense || li) return f().then(b => () => Qu(b, v)).catch(b => (g(b), () => a ? m(a, {
                error: b
            }) : null));
            const h = Q(!1),
                y = Q(),
                S = Q(!!l);
            return l && setTimeout(() => {
                S.value = !1
            }, l), r != null && setTimeout(() => {
                if (!h.value && !y.value) {
                    const b = new Error(`Async component timed out after ${r}ms.`);
                    g(b), y.value = b
                }
            }, r), f().then(() => {
                h.value = !0, v.parent && ni(v.parent.vnode) && (v.parent.effect.dirty = !0, Ys(v.parent.update))
            }).catch(b => {
                g(b), y.value = b
            }), () => {
                if (h.value && u) return Qu(u, v);
                if (y.value && a) return m(a, {
                    error: y.value
                });
                if (n && !S.value) return m(n)
            }
        }
    })
}

function Qu(e, t) {
    const {
        ref: n,
        props: a,
        children: l,
        ce: r
    } = t.vnode, o = m(e, a, l);
    return o.ref = n, o.ce = r, delete t.vnode.ce, o
}
const ni = e => e.type.__isKeepAlive,
    q1 = {
        name: "KeepAlive",
        __isKeepAlive: !0,
        props: {
            include: [String, RegExp, Array],
            exclude: [String, RegExp, Array],
            max: [String, Number]
        },
        setup(e, {
            slots: t
        }) {
            const n = nn(),
                a = n.ctx;
            if (!a.renderer) return () => {
                const b = t.default && t.default();
                return b && b.length === 1 ? b[0] : b
            };
            const l = new Map,
                r = new Set;
            let o = null;
            const i = n.suspense,
                {
                    renderer: {
                        p: s,
                        m: u,
                        um: c,
                        o: {
                            createElement: d
                        }
                    }
                } = a,
                f = d("div");
            a.activate = (b, p, _, w, k) => {
                const E = b.component;
                u(b, p, _, 0, i), s(E.vnode, b, p, _, E, i, w, b.slotScopeIds, k), Mt(() => {
                    E.isDeactivated = !1, E.a && uo(E.a);
                    const P = b.props && b.props.onVnodeMounted;
                    P && Xt(P, E.parent, b)
                }, i)
            }, a.deactivate = b => {
                const p = b.component;
                u(b, f, null, 1, i), Mt(() => {
                    p.da && uo(p.da);
                    const _ = b.props && b.props.onVnodeUnmounted;
                    _ && Xt(_, p.parent, b), p.isDeactivated = !0
                }, i)
            };

            function v(b) {
                ec(b), c(b, n, i, !0)
            }

            function g(b) {
                l.forEach((p, _) => {
                    const w = Gc(p.type);
                    w && (!b || !b(w)) && h(_)
                })
            }

            function h(b) {
                const p = l.get(b);
                !o || !Nn(p, o) ? v(p) : o && ec(o), l.delete(b), r.delete(b)
            }
            de(() => [e.include, e.exclude], ([b, p]) => {
                b && g(_ => ro(b, _)), p && g(_ => !ro(p, _))
            }, {
                flush: "post",
                deep: !0
            });
            let y = null;
            const S = () => {
                y != null && l.set(y, tc(n.subTree))
            };
            return it(S), ai(S), Ct(() => {
                l.forEach(b => {
                    const {
                        subTree: p,
                        suspense: _
                    } = n, w = tc(p);
                    if (b.type === w.type && b.key === w.key) {
                        ec(w);
                        const k = w.component.da;
                        k && Mt(k, _);
                        return
                    }
                    v(b)
                })
            }), () => {
                if (y = null, !t.default) return null;
                const b = t.default(),
                    p = b[0];
                if (b.length > 1) return o = null, b;
                if (!wa(p) || !(p.shapeFlag & 4) && !(p.shapeFlag & 128)) return o = null, p;
                let _ = tc(p);
                const w = _.type,
                    k = Gc(Sl(_) ? _.type.__asyncResolved || {} : w),
                    {
                        include: E,
                        exclude: P,
                        max: x
                    } = e;
                if (E && (!k || !ro(E, k)) || P && k && ro(P, k)) return o = _, p;
                const T = _.key == null ? w : _.key,
                    V = l.get(T);
                return _.el && (_ = $n(_), p.shapeFlag & 128 && (p.ssContent = _)), y = T, V ? (_.el = V.el, _.component = V.component, _.transition && Il(_, _.transition), _.shapeFlag |= 512, r.delete(T), r.add(T)) : (r.add(T), x && r.size > parseInt(x, 10) && h(r.values().next().value)), _.shapeFlag |= 256, o = _, zb(p.type) ? p : _
            }
        }
    },
    ep = q1;

function ro(e, t) {
    return Me(e) ? e.some(n => ro(n, t)) : Tt(e) ? e.split(",").includes(t) : m1(e) ? e.test(t) : !1
}

function Kf(e, t) {
    tp(e, "a", t)
}

function Qs(e, t) {
    tp(e, "da", t)
}

function tp(e, t, n = Et) {
    const a = e.__wdc || (e.__wdc = () => {
        let l = n;
        for (; l;) {
            if (l.isDeactivated) return;
            l = l.parent
        }
        return e()
    });
    if (eu(t, a, n), n) {
        let l = n.parent;
        for (; l && l.parent;) ni(l.parent.vnode) && X1(a, t, n, l), l = l.parent
    }
}

function X1(e, t, n, a) {
    const l = eu(t, e, a, !0);
    jr(() => {
        Df(a[t], l)
    }, n)
}

function ec(e) {
    e.shapeFlag &= -257, e.shapeFlag &= -513
}

function tc(e) {
    return e.shapeFlag & 128 ? e.ssContent : e
}

function eu(e, t, n = Et, a = !1) {
    if (n) {
        const l = n[e] || (n[e] = []),
            r = t.__weh || (t.__weh = (...o) => {
                if (n.isUnmounted) return;
                Bl();
                const i = Vl(n),
                    s = vn(t, n, e, o);
                return i(), Fl(), s
            });
        return a ? l.unshift(r) : l.push(r), r
    }
}
const Pa = e => (t, n = Et) => (!li || e === "sp") && eu(e, (...a) => t(...a), n),
    tu = Pa("bm"),
    it = Pa("m"),
    Gf = Pa("bu"),
    ai = Pa("u"),
    Ct = Pa("bum"),
    jr = Pa("um"),
    np = Pa("sp"),
    ap = Pa("rtg"),
    lp = Pa("rtc");

function Yf(e, t = Et) {
    eu("ec", e, t)
}

function J1(e, t, n, a) {
    let l;
    const r = n && n[a];
    if (Me(e) || Tt(e)) {
        l = new Array(e.length);
        for (let o = 0, i = e.length; o < i; o++) l[o] = t(e[o], o, void 0, r && r[o])
    } else if (typeof e == "number") {
        l = new Array(e);
        for (let o = 0; o < e; o++) l[o] = t(o + 1, o, void 0, r && r[o])
    } else if (wt(e))
        if (e[Symbol.iterator]) l = Array.from(e, (o, i) => t(o, i, void 0, r && r[i]));
        else {
            const o = Object.keys(e);
            l = new Array(o.length);
            for (let i = 0, s = o.length; i < s; i++) {
                const u = o[i];
                l[i] = t(e[u], u, i, r && r[i])
            }
        }
    else l = [];
    return n && (n[a] = l), l
}

function Z1(e, t) {
    for (let n = 0; n < t.length; n++) {
        const a = t[n];
        if (Me(a))
            for (let l = 0; l < a.length; l++) e[a[l].name] = a[l].fn;
        else a && (e[a.name] = a.key ? (...l) => {
            const r = a.fn(...l);
            return r && (r.key = a.key), r
        } : a.fn)
    }
    return e
}

function Q1(e, t, n = {}, a, l) {
    if (St.isCE || St.parent && Sl(St.parent) && St.parent.isCE) return t !== "default" && (n.name = t), m("slot", n, a && a());
    let r = e[t];
    r && r._c && (r._d = !1), Cn();
    const o = r && rp(r(n)),
        i = qn(ye, {
            key: n.key || o && o.key || `_${t}`
        }, o || (a ? a() : []), o && e._ === 1 ? 64 : -2);
    return !l && i.scopeId && (i.slotScopeIds = [i.scopeId + "-s"]), r && r._c && (r._d = !0), i
}

function rp(e) {
    return e.some(t => wa(t) ? !(t.type === Nt || t.type === ye && !rp(t.children)) : !0) ? e : null
}

function ex(e, t) {
    const n = {};
    for (const a in e) n[t && /[A-Z]/.test(a) ? `on:${a}` : so(a)] = e[a];
    return n
}
const Mc = e => e ? Pp(e) ? lu(e) || e.proxy : Mc(e.parent) : null,
    co = Lt(Object.create(null), {
        $: e => e,
        $el: e => e.vnode.el,
        $data: e => e.data,
        $props: e => e.props,
        $attrs: e => e.attrs,
        $slots: e => e.slots,
        $refs: e => e.refs,
        $parent: e => Mc(e.parent),
        $root: e => Mc(e.root),
        $emit: e => e.emit,
        $options: e => qf(e),
        $forceUpdate: e => e.f || (e.f = () => {
            e.effect.dirty = !0, Ys(e.update)
        }),
        $nextTick: e => e.n || (e.n = Re.bind(e.proxy)),
        $watch: e => G1.bind(e)
    }),
    nc = (e, t) => e !== tt && !e.__isScriptSetup && Xe(e, t),
    Nc = {
        get({
            _: e
        }, t) {
            const {
                ctx: n,
                setupState: a,
                data: l,
                props: r,
                accessCache: o,
                type: i,
                appContext: s
            } = e;
            let u;
            if (t[0] !== "$") {
                const v = o[t];
                if (v !== void 0) switch (v) {
                    case 1:
                        return a[t];
                    case 2:
                        return l[t];
                    case 4:
                        return n[t];
                    case 3:
                        return r[t]
                } else {
                    if (nc(a, t)) return o[t] = 1, a[t];
                    if (l !== tt && Xe(l, t)) return o[t] = 2, l[t];
                    if ((u = e.propsOptions[0]) && Xe(u, t)) return o[t] = 3, r[t];
                    if (n !== tt && Xe(n, t)) return o[t] = 4, n[t];
                    $c && (o[t] = 0)
                }
            }
            const c = co[t];
            let d, f;
            if (c) return t === "$attrs" && Zt(e, "get", t), c(e);
            if ((d = i.__cssModules) && (d = d[t])) return d;
            if (n !== tt && Xe(n, t)) return o[t] = 4, n[t];
            if (f = s.config.globalProperties, Xe(f, t)) return f[t]
        },
        set({
            _: e
        }, t, n) {
            const {
                data: a,
                setupState: l,
                ctx: r
            } = e;
            return nc(l, t) ? (l[t] = n, !0) : a !== tt && Xe(a, t) ? (a[t] = n, !0) : Xe(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (r[t] = n, !0)
        },
        has({
            _: {
                data: e,
                setupState: t,
                accessCache: n,
                ctx: a,
                appContext: l,
                propsOptions: r
            }
        }, o) {
            let i;
            return !!n[o] || e !== tt && Xe(e, o) || nc(t, o) || (i = r[0]) && Xe(i, o) || Xe(a, o) || Xe(co, o) || Xe(l.config.globalProperties, o)
        },
        defineProperty(e, t, n) {
            return n.get != null ? e._.accessCache[t] = 0 : Xe(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n)
        }
    },
    tx = Lt({}, Nc, {
        get(e, t) {
            if (t !== Symbol.unscopables) return Nc.get(e, t, e)
        },
        has(e, t) {
            return t[0] !== "_" && !_1(t)
        }
    });

function nx() {
    return null
}

function ax() {
    return null
}

function lx(e) {}

function rx(e) {}

function ox() {
    return null
}

function ix() {}

function sx(e, t) {
    return null
}

function ux() {
    return op().slots
}

function cx() {
    return op().attrs
}

function op() {
    const e = nn();
    return e.setupContext || (e.setupContext = Tp(e))
}

function Eo(e) {
    return Me(e) ? e.reduce((t, n) => (t[n] = null, t), {}) : e
}

function dx(e, t) {
    const n = Eo(e);
    for (const a in t) {
        if (a.startsWith("__skip")) continue;
        let l = n[a];
        l ? Me(l) || De(l) ? l = n[a] = {
            type: l,
            default: t[a]
        } : l.default = t[a] : l === null && (l = n[a] = {
            default: t[a]
        }), l && t[`__skip_${a}`] && (l.skipFactory = !0)
    }
    return n
}

function fx(e, t) {
    return !e || !t ? e || t : Me(e) && Me(t) ? e.concat(t) : Lt({}, Eo(e), Eo(t))
}

function vx(e, t) {
    const n = {};
    for (const a in e) t.includes(a) || Object.defineProperty(n, a, {
        enumerable: !0,
        get: () => e[a]
    });
    return n
}

function mx(e) {
    const t = nn();
    let n = e();
    return Wc(), Mf(n) && (n = n.catch(a => {
        throw Vl(t), a
    })), [n, () => Vl(t)]
}
let $c = !0;

function hx(e) {
    const t = qf(e),
        n = e.proxy,
        a = e.ctx;
    $c = !1, t.beforeCreate && Wm(t.beforeCreate, e, "bc");
    const {
        data: l,
        computed: r,
        methods: o,
        watch: i,
        provide: s,
        inject: u,
        created: c,
        beforeMount: d,
        mounted: f,
        beforeUpdate: v,
        updated: g,
        activated: h,
        deactivated: y,
        beforeDestroy: S,
        beforeUnmount: b,
        destroyed: p,
        unmounted: _,
        render: w,
        renderTracked: k,
        renderTriggered: E,
        errorCaptured: P,
        serverPrefetch: x,
        expose: T,
        inheritAttrs: V,
        components: I,
        directives: R,
        filters: B
    } = t;
    if (u && gx(u, a, null), o)
        for (const z in o) {
            const N = o[z];
            De(N) && (a[z] = N.bind(n))
        }
    if (l) {
        const z = l.call(n, n);
        wt(z) && (e.data = mt(z))
    }
    if ($c = !0, r)
        for (const z in r) {
            const N = r[z],
                H = De(N) ? N.bind(n, n) : De(N.get) ? N.get.bind(n, n) : Pn,
                F = !De(N) && De(N.set) ? N.set.bind(n) : Pn,
                j = C({
                    get: H,
                    set: F
                });
            Object.defineProperty(a, z, {
                enumerable: !0,
                configurable: !0,
                get: () => j.value,
                set: ae => j.value = ae
            })
        }
    if (i)
        for (const z in i) ip(i[z], a, n, z);
    if (s) {
        const z = De(s) ? s.call(n) : s;
        Reflect.ownKeys(z).forEach(N => {
            He(N, z[N])
        })
    }
    c && Wm(c, e, "c");

    function D(z, N) {
        Me(N) ? N.forEach(H => z(H.bind(n))) : N && z(N.bind(n))
    }
    if (D(tu, d), D(it, f), D(Gf, v), D(ai, g), D(Kf, h), D(Qs, y), D(Yf, P), D(lp, k), D(ap, E), D(Ct, b), D(jr, _), D(np, x), Me(T))
        if (T.length) {
            const z = e.exposed || (e.exposed = {});
            T.forEach(N => {
                Object.defineProperty(z, N, {
                    get: () => n[N],
                    set: H => n[N] = H
                })
            })
        } else e.exposed || (e.exposed = {});
    w && e.render === Pn && (e.render = w), V != null && (e.inheritAttrs = V), I && (e.components = I), R && (e.directives = R)
}

function gx(e, t, n = Pn) {
    Me(e) && (e = Bc(e));
    for (const a in e) {
        const l = e[a];
        let r;
        wt(l) ? "default" in l ? r = Te(l.from || a, l.default, !0) : r = Te(l.from || a) : r = Te(l), Ge(r) ? Object.defineProperty(t, a, {
            enumerable: !0,
            configurable: !0,
            get: () => r.value,
            set: o => r.value = o
        }) : t[a] = r
    }
}

function Wm(e, t, n) {
    vn(Me(e) ? e.map(a => a.bind(t.proxy)) : e.bind(t.proxy), t, n)
}

function ip(e, t, n, a) {
    const l = a.includes(".") ? Jb(n, a) : () => n[a];
    if (Tt(e)) {
        const r = t[e];
        De(r) && de(l, r)
    } else if (De(e)) de(l, e.bind(n));
    else if (wt(e))
        if (Me(e)) e.forEach(r => ip(r, t, n, a));
        else {
            const r = De(e.handler) ? e.handler.bind(n) : t[e.handler];
            De(r) && de(l, r, e)
        }
}

function qf(e) {
    const t = e.type,
        {
            mixins: n,
            extends: a
        } = t,
        {
            mixins: l,
            optionsCache: r,
            config: {
                optionMergeStrategies: o
            }
        } = e.appContext,
        i = r.get(t);
    let s;
    return i ? s = i : !l.length && !n && !a ? s = t : (s = {}, l.length && l.forEach(u => is(s, u, o, !0)), is(s, t, o)), wt(t) && r.set(t, s), s
}

function is(e, t, n, a = !1) {
    const {
        mixins: l,
        extends: r
    } = t;
    r && is(e, r, n, !0), l && l.forEach(o => is(e, o, n, !0));
    for (const o in t)
        if (!(a && o === "expose")) {
            const i = yx[o] || n && n[o];
            e[o] = i ? i(e[o], t[o]) : t[o]
        }
    return e
}
const yx = {
    data: zm,
    props: Km,
    emits: Km,
    methods: oo,
    computed: oo,
    beforeCreate: Kt,
    created: Kt,
    beforeMount: Kt,
    mounted: Kt,
    beforeUpdate: Kt,
    updated: Kt,
    beforeDestroy: Kt,
    beforeUnmount: Kt,
    destroyed: Kt,
    unmounted: Kt,
    activated: Kt,
    deactivated: Kt,
    errorCaptured: Kt,
    serverPrefetch: Kt,
    components: oo,
    directives: oo,
    watch: px,
    provide: zm,
    inject: bx
};

function zm(e, t) {
    return t ? e ? function() {
        return Lt(De(e) ? e.call(this, this) : e, De(t) ? t.call(this, this) : t)
    } : t : e
}

function bx(e, t) {
    return oo(Bc(e), Bc(t))
}

function Bc(e) {
    if (Me(e)) {
        const t = {};
        for (let n = 0; n < e.length; n++) t[e[n]] = e[n];
        return t
    }
    return e
}

function Kt(e, t) {
    return e ? [...new Set([].concat(e, t))] : t
}

function oo(e, t) {
    return e ? Lt(Object.create(null), e, t) : t
}

function Km(e, t) {
    return e ? Me(e) && Me(t) ? [...new Set([...e, ...t])] : Lt(Object.create(null), Eo(e), Eo(t ? ? {})) : t
}

function px(e, t) {
    if (!e) return t;
    if (!t) return e;
    const n = Lt(Object.create(null), e);
    for (const a in t) n[a] = Kt(e[a], t[a]);
    return n
}

function sp() {
    return {
        app: null,
        config: {
            isNativeTag: f1,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let _x = 0;

function Sx(e, t) {
    return function(a, l = null) {
        De(a) || (a = Lt({}, a)), l != null && !wt(l) && (l = null);
        const r = sp(),
            o = new WeakSet;
        let i = !1;
        const s = r.app = {
            _uid: _x++,
            _component: a,
            _props: l,
            _container: null,
            _context: r,
            _instance: null,
            version: tv,
            get config() {
                return r.config
            },
            set config(u) {},
            use(u, ...c) {
                return o.has(u) || (u && De(u.install) ? (o.add(u), u.install(s, ...c)) : De(u) && (o.add(u), u(s, ...c))), s
            },
            mixin(u) {
                return r.mixins.includes(u) || r.mixins.push(u), s
            },
            component(u, c) {
                return c ? (r.components[u] = c, s) : r.components[u]
            },
            directive(u, c) {
                return c ? (r.directives[u] = c, s) : r.directives[u]
            },
            mount(u, c, d) {
                if (!i) {
                    const f = m(a, l);
                    return f.appContext = r, d === !0 ? d = "svg" : d === !1 && (d = void 0), c && t ? t(f, u) : e(f, u, d), i = !0, s._container = u, u.__vue_app__ = s, lu(f.component) || f.component.proxy
                }
            },
            unmount() {
                i && (e(null, s._container), delete s._container.__vue_app__)
            },
            provide(u, c) {
                return r.provides[u] = c, s
            },
            runWithContext(u) {
                const c = pr;
                pr = s;
                try {
                    return u()
                } finally {
                    pr = c
                }
            }
        };
        return s
    }
}
let pr = null;

function He(e, t) {
    if (Et) {
        let n = Et.provides;
        const a = Et.parent && Et.parent.provides;
        a === n && (n = Et.provides = Object.create(a)), n[e] = t
    }
}

function Te(e, t, n = !1) {
    const a = Et || St;
    if (a || pr) {
        const l = a ? a.parent == null ? a.vnode.appContext && a.vnode.appContext.provides : a.parent.provides : pr._context.provides;
        if (l && e in l) return l[e];
        if (arguments.length > 1) return n && De(t) ? t.call(a && a.proxy) : t
    }
}

function nu() {
    return !!(Et || St || pr)
}

function wx(e, t, n, a = !1) {
    const l = {},
        r = {};
    Oc(r, au, 1), e.propsDefaults = Object.create(null), up(e, t, l, r);
    for (const o in e.propsOptions[0]) o in l || (l[o] = void 0);
    n ? e.props = a ? l : Jn(l) : e.type.props ? e.props = l : e.props = r, e.attrs = r
}

function kx(e, t, n, a) {
    const {
        props: l,
        attrs: r,
        vnode: {
            patchFlag: o
        }
    } = e, i = xe(l), [s] = e.propsOptions;
    let u = !1;
    if ((a || o > 0) && !(o & 16)) {
        if (o & 8) {
            const c = e.vnode.dynamicProps;
            for (let d = 0; d < c.length; d++) {
                let f = c[d];
                if (qs(e.emitsOptions, f)) continue;
                const v = t[f];
                if (s)
                    if (Xe(r, f)) v !== r[f] && (r[f] = v, u = !0);
                    else {
                        const g = Qt(f);
                        l[g] = Fc(s, i, g, v, e, !1)
                    }
                else v !== r[f] && (r[f] = v, u = !0)
            }
        }
    } else {
        up(e, t, l, r) && (u = !0);
        let c;
        for (const d in i)(!t || !Xe(t, d) && ((c = Qo(d)) === d || !Xe(t, c))) && (s ? n && (n[d] !== void 0 || n[c] !== void 0) && (l[d] = Fc(s, i, d, void 0, e, !0)) : delete l[d]);
        if (r !== i)
            for (const d in r)(!t || !Xe(t, d)) && (delete r[d], u = !0)
    }
    u && ba(e, "set", "$attrs")
}

function up(e, t, n, a) {
    const [l, r] = e.propsOptions;
    let o = !1,
        i;
    if (t)
        for (let s in t) {
            if (gr(s)) continue;
            const u = t[s];
            let c;
            l && Xe(l, c = Qt(s)) ? !r || !r.includes(c) ? n[c] = u : (i || (i = {}))[c] = u : qs(e.emitsOptions, s) || (!(s in a) || u !== a[s]) && (a[s] = u, o = !0)
        }
    if (r) {
        const s = xe(n),
            u = i || tt;
        for (let c = 0; c < r.length; c++) {
            const d = r[c];
            n[d] = Fc(l, s, d, u[d], e, !Xe(u, d))
        }
    }
    return o
}

function Fc(e, t, n, a, l, r) {
    const o = e[n];
    if (o != null) {
        const i = Xe(o, "default");
        if (i && a === void 0) {
            const s = o.default;
            if (o.type !== Function && !o.skipFactory && De(s)) {
                const {
                    propsDefaults: u
                } = l;
                if (n in u) a = u[n];
                else {
                    const c = Vl(l);
                    a = u[n] = s.call(null, t), c()
                }
            } else a = s
        }
        o[0] && (r && !i ? a = !1 : o[1] && (a === "" || a === Qo(n)) && (a = !0))
    }
    return a
}

function cp(e, t, n = !1) {
    const a = t.propsCache,
        l = a.get(e);
    if (l) return l;
    const r = e.props,
        o = {},
        i = [];
    let s = !1;
    if (!De(e)) {
        const c = d => {
            s = !0;
            const [f, v] = cp(d, t, !0);
            Lt(o, f), v && i.push(...v)
        };
        !n && t.mixins.length && t.mixins.forEach(c), e.extends && c(e.extends), e.mixins && e.mixins.forEach(c)
    }
    if (!r && !s) return wt(e) && a.set(e, hr), hr;
    if (Me(r))
        for (let c = 0; c < r.length; c++) {
            const d = Qt(r[c]);
            Gm(d) && (o[d] = tt)
        } else if (r)
            for (const c in r) {
                const d = Qt(c);
                if (Gm(d)) {
                    const f = r[c],
                        v = o[d] = Me(f) || De(f) ? {
                            type: f
                        } : Lt({}, f);
                    if (v) {
                        const g = Xm(Boolean, v.type),
                            h = Xm(String, v.type);
                        v[0] = g > -1, v[1] = h < 0 || g < h, (g > -1 || Xe(v, "default")) && i.push(d)
                    }
                }
            }
    const u = [o, i];
    return wt(e) && a.set(e, u), u
}

function Gm(e) {
    return e[0] !== "$" && !gr(e)
}

function Ym(e) {
    return e === null ? "null" : typeof e == "function" ? e.name || "" : typeof e == "object" && e.constructor && e.constructor.name || ""
}

function qm(e, t) {
    return Ym(e) === Ym(t)
}

function Xm(e, t) {
    return Me(t) ? t.findIndex(n => qm(n, e)) : De(t) && qm(t, e) ? 0 : -1
}
const dp = e => e[0] === "_" || e === "$stable",
    Xf = e => Me(e) ? e.map(cn) : [cn(e)],
    Cx = (e, t, n) => {
        if (t._n) return t;
        const a = Js((...l) => Xf(t(...l)), n);
        return a._c = !1, a
    },
    fp = (e, t, n) => {
        const a = e._ctx;
        for (const l in e) {
            if (dp(l)) continue;
            const r = e[l];
            if (De(r)) t[l] = Cx(l, r, a);
            else if (r != null) {
                const o = Xf(r);
                t[l] = () => o
            }
        }
    },
    vp = (e, t) => {
        const n = Xf(t);
        e.slots.default = () => n
    },
    xx = (e, t) => {
        if (e.vnode.shapeFlag & 32) {
            const n = t._;
            n ? (e.slots = xe(t), Oc(t, "_", n)) : fp(t, e.slots = {})
        } else e.slots = {}, t && vp(e, t);
        Oc(e.slots, au, 1)
    },
    Px = (e, t, n) => {
        const {
            vnode: a,
            slots: l
        } = e;
        let r = !0,
            o = tt;
        if (a.shapeFlag & 32) {
            const i = t._;
            i ? n && i === 1 ? r = !1 : (Lt(l, t), !n && i === 1 && delete l._) : (r = !t.$stable, fp(t, l)), o = t
        } else t && (vp(e, t), o = {
            default: 1
        });
        if (r)
            for (const i in l) !dp(i) && o[i] == null && delete l[i]
    };

function ss(e, t, n, a, l = !1) {
    if (Me(e)) {
        e.forEach((f, v) => ss(f, t && (Me(t) ? t[v] : t), n, a, l));
        return
    }
    if (Sl(a) && !l) return;
    const r = a.shapeFlag & 4 ? lu(a.component) || a.component.proxy : a.el,
        o = l ? null : r,
        {
            i,
            r: s
        } = e,
        u = t && t.r,
        c = i.refs === tt ? i.refs = {} : i.refs,
        d = i.setupState;
    if (u != null && u !== s && (Tt(u) ? (c[u] = null, Xe(d, u) && (d[u] = null)) : Ge(u) && (u.value = null)), De(s)) _a(s, i, 12, [o, c]);
    else {
        const f = Tt(s),
            v = Ge(s);
        if (f || v) {
            const g = () => {
                if (e.f) {
                    const h = f ? Xe(d, s) ? d[s] : c[s] : s.value;
                    l ? Me(h) && Df(h, r) : Me(h) ? h.includes(r) || h.push(r) : f ? (c[s] = [r], Xe(d, s) && (d[s] = c[s])) : (s.value = [r], e.k && (c[e.k] = s.value))
                } else f ? (c[s] = o, Xe(d, s) && (d[s] = o)) : v && (s.value = o, e.k && (c[e.k] = o))
            };
            o ? (g.id = -1, Mt(g, n)) : g()
        }
    }
}
let Aa = !1;
const Ex = e => e.namespaceURI.includes("svg") && e.tagName !== "foreignObject",
    Ix = e => e.namespaceURI.includes("MathML"),
    Ii = e => {
        if (Ex(e)) return "svg";
        if (Ix(e)) return "mathml"
    },
    Ti = e => e.nodeType === 8;

function Tx(e) {
    const {
        mt: t,
        p: n,
        o: {
            patchProp: a,
            createText: l,
            nextSibling: r,
            parentNode: o,
            remove: i,
            insert: s,
            createComment: u
        }
    } = e, c = (p, _) => {
        if (!_.hasChildNodes()) {
            n(null, p, _), os(), _._vnode = p;
            return
        }
        Aa = !1, d(_.firstChild, p, null, null, null), os(), _._vnode = p, Aa && console.error("Hydration completed but contains mismatches.")
    }, d = (p, _, w, k, E, P = !1) => {
        const x = Ti(p) && p.data === "[",
            T = () => h(p, _, w, k, E, x),
            {
                type: V,
                ref: I,
                shapeFlag: R,
                patchFlag: B
            } = _;
        let $ = p.nodeType;
        _.el = p, B === -2 && (P = !1, _.dynamicChildren = null);
        let D = null;
        switch (V) {
            case Sa:
                $ !== 3 ? _.children === "" ? (s(_.el = l(""), o(p), p), D = p) : D = T() : (p.data !== _.children && (Aa = !0, p.data = _.children), D = r(p));
                break;
            case Nt:
                b(p) ? (D = r(p), S(_.el = p.content.firstChild, p, w)) : $ !== 8 || x ? D = T() : D = r(p);
                break;
            case wl:
                if (x && (p = r(p), $ = p.nodeType), $ === 1 || $ === 3) {
                    D = p;
                    const z = !_.children.length;
                    for (let N = 0; N < _.staticCount; N++) z && (_.children += D.nodeType === 1 ? D.outerHTML : D.data), N === _.staticCount - 1 && (_.anchor = D), D = r(D);
                    return x ? r(D) : D
                } else T();
                break;
            case ye:
                x ? D = g(p, _, w, k, E, P) : D = T();
                break;
            default:
                if (R & 1)($ !== 1 || _.type.toLowerCase() !== p.tagName.toLowerCase()) && !b(p) ? D = T() : D = f(p, _, w, k, E, P);
                else if (R & 6) {
                    _.slotScopeIds = E;
                    const z = o(p);
                    if (x ? D = y(p) : Ti(p) && p.data === "teleport start" ? D = y(p, p.data, "teleport end") : D = r(p), t(_, z, null, w, k, Ii(z), P), Sl(_)) {
                        let N;
                        x ? (N = m(ye), N.anchor = D ? D.previousSibling : z.lastChild) : N = p.nodeType === 3 ? hn("") : m("div"), N.el = p, _.component.subTree = N
                    }
                } else R & 64 ? $ !== 8 ? D = T() : D = _.type.hydrate(p, _, w, k, E, P, e, v) : R & 128 && (D = _.type.hydrate(p, _, w, k, Ii(o(p)), E, P, e, d))
        }
        return I != null && ss(I, null, k, _), D
    }, f = (p, _, w, k, E, P) => {
        P = P || !!_.dynamicChildren;
        const {
            type: x,
            props: T,
            patchFlag: V,
            shapeFlag: I,
            dirs: R,
            transition: B
        } = _, $ = x === "input" || x === "option";
        if ($ || V !== -1) {
            R && Gn(_, null, w, "created");
            let D = !1;
            if (b(p)) {
                D = yp(k, B) && w && w.vnode.props && w.vnode.props.appear;
                const N = p.content.firstChild;
                D && B.beforeEnter(N), S(N, p, w), _.el = p = N
            }
            if (I & 16 && !(T && (T.innerHTML || T.textContent))) {
                let N = v(p.firstChild, _, p, w, k, E, P);
                for (; N;) {
                    Aa = !0;
                    const H = N;
                    N = N.nextSibling, i(H)
                }
            } else I & 8 && p.textContent !== _.children && (Aa = !0, p.textContent = _.children);
            if (T)
                if ($ || !P || V & 48)
                    for (const N in T)($ && (N.endsWith("value") || N === "indeterminate") || zs(N) && !gr(N) || N[0] === ".") && a(p, N, null, T[N], void 0, void 0, w);
                else T.onClick && a(p, "onClick", null, T.onClick, void 0, void 0, w);
            let z;
            (z = T && T.onVnodeBeforeMount) && Xt(z, w, _), R && Gn(_, null, w, "beforeMount"), ((z = T && T.onVnodeMounted) || R || D) && Kb(() => {
                z && Xt(z, w, _), D && B.enter(p), R && Gn(_, null, w, "mounted")
            }, k)
        }
        return p.nextSibling
    }, v = (p, _, w, k, E, P, x) => {
        x = x || !!_.dynamicChildren;
        const T = _.children,
            V = T.length;
        for (let I = 0; I < V; I++) {
            const R = x ? T[I] : T[I] = cn(T[I]);
            if (p) p = d(p, R, k, E, P, x);
            else {
                if (R.type === Sa && !R.children) continue;
                Aa = !0, n(null, R, w, null, k, E, Ii(w), P)
            }
        }
        return p
    }, g = (p, _, w, k, E, P) => {
        const {
            slotScopeIds: x
        } = _;
        x && (E = E ? E.concat(x) : x);
        const T = o(p),
            V = v(r(p), _, T, w, k, E, P);
        return V && Ti(V) && V.data === "]" ? r(_.anchor = V) : (Aa = !0, s(_.anchor = u("]"), T, V), V)
    }, h = (p, _, w, k, E, P) => {
        if (Aa = !0, _.el = null, P) {
            const V = y(p);
            for (;;) {
                const I = r(p);
                if (I && I !== V) i(I);
                else break
            }
        }
        const x = r(p),
            T = o(p);
        return i(p), n(null, _, T, x, w, k, Ii(T), E), x
    }, y = (p, _ = "[", w = "]") => {
        let k = 0;
        for (; p;)
            if (p = r(p), p && Ti(p) && (p.data === _ && k++, p.data === w)) {
                if (k === 0) return r(p);
                k--
            }
        return p
    }, S = (p, _, w) => {
        const k = _.parentNode;
        k && k.replaceChild(p, _);
        let E = w;
        for (; E;) E.vnode.el === _ && (E.vnode.el = E.subTree.el = p), E = E.parent
    }, b = p => p.nodeType === 1 && p.tagName.toLowerCase() === "template";
    return [c, d]
}
const Mt = Kb;

function mp(e) {
    return gp(e)
}

function hp(e) {
    return gp(e, Tx)
}

function gp(e, t) {
    const n = Rb();
    n.__VUE__ = !0;
    const {
        insert: a,
        remove: l,
        patchProp: r,
        createElement: o,
        createText: i,
        createComment: s,
        setText: u,
        setElementText: c,
        parentNode: d,
        nextSibling: f,
        setScopeId: v = Pn,
        insertStaticContent: g
    } = e, h = (A, O, K, J = null, X = null, ue = null, be = void 0, L = null, M = !!O.dynamicChildren) => {
        if (A === O) return;
        A && !Nn(A, O) && (J = G(A), ae(A, X, ue, !0), A = null), O.patchFlag === -2 && (M = !1, O.dynamicChildren = null);
        const {
            type: U,
            ref: ie,
            shapeFlag: _e
        } = O;
        switch (U) {
            case Sa:
                y(A, O, K, J);
                break;
            case Nt:
                S(A, O, K, J);
                break;
            case wl:
                A == null && b(O, K, J, be);
                break;
            case ye:
                I(A, O, K, J, X, ue, be, L, M);
                break;
            default:
                _e & 1 ? w(A, O, K, J, X, ue, be, L, M) : _e & 6 ? R(A, O, K, J, X, ue, be, L, M) : (_e & 64 || _e & 128) && U.process(A, O, K, J, X, ue, be, L, M, ce)
        }
        ie != null && X && ss(ie, A && A.ref, ue, O || A, !O)
    }, y = (A, O, K, J) => {
        if (A == null) a(O.el = i(O.children), K, J);
        else {
            const X = O.el = A.el;
            O.children !== A.children && u(X, O.children)
        }
    }, S = (A, O, K, J) => {
        A == null ? a(O.el = s(O.children || ""), K, J) : O.el = A.el
    }, b = (A, O, K, J) => {
        [A.el, A.anchor] = g(A.children, O, K, J, A.el, A.anchor)
    }, p = ({
        el: A,
        anchor: O
    }, K, J) => {
        let X;
        for (; A && A !== O;) X = f(A), a(A, K, J), A = X;
        a(O, K, J)
    }, _ = ({
        el: A,
        anchor: O
    }) => {
        let K;
        for (; A && A !== O;) K = f(A), l(A), A = K;
        l(O)
    }, w = (A, O, K, J, X, ue, be, L, M) => {
        O.type === "svg" ? be = "svg" : O.type === "math" && (be = "mathml"), A == null ? k(O, K, J, X, ue, be, L, M) : x(A, O, X, ue, be, L, M)
    }, k = (A, O, K, J, X, ue, be, L) => {
        let M, U;
        const {
            props: ie,
            shapeFlag: _e,
            transition: me,
            dirs: q
        } = A;
        if (M = A.el = o(A.type, ue, ie && ie.is, ie), _e & 8 ? c(M, A.children) : _e & 16 && P(A.children, M, null, J, X, ac(A, ue), be, L), q && Gn(A, null, J, "created"), E(M, A, A.scopeId, be, J), ie) {
            for (const Ee in ie) Ee !== "value" && !gr(Ee) && r(M, Ee, null, ie[Ee], ue, A.children, J, X, ee);
            "value" in ie && r(M, "value", null, ie.value, ue), (U = ie.onVnodeBeforeMount) && Xt(U, J, A)
        }
        q && Gn(A, null, J, "beforeMount");
        const oe = yp(X, me);
        oe && me.beforeEnter(M), a(M, O, K), ((U = ie && ie.onVnodeMounted) || oe || q) && Mt(() => {
            U && Xt(U, J, A), oe && me.enter(M), q && Gn(A, null, J, "mounted")
        }, X)
    }, E = (A, O, K, J, X) => {
        if (K && v(A, K), J)
            for (let ue = 0; ue < J.length; ue++) v(A, J[ue]);
        if (X) {
            let ue = X.subTree;
            if (O === ue) {
                const be = X.vnode;
                E(A, be, be.scopeId, be.slotScopeIds, X.parent)
            }
        }
    }, P = (A, O, K, J, X, ue, be, L, M = 0) => {
        for (let U = M; U < A.length; U++) {
            const ie = A[U] = L ? Ba(A[U]) : cn(A[U]);
            h(null, ie, O, K, J, X, ue, be, L)
        }
    }, x = (A, O, K, J, X, ue, be) => {
        const L = O.el = A.el;
        let {
            patchFlag: M,
            dynamicChildren: U,
            dirs: ie
        } = O;
        M |= A.patchFlag & 16;
        const _e = A.props || tt,
            me = O.props || tt;
        let q;
        if (K && ol(K, !1), (q = me.onVnodeBeforeUpdate) && Xt(q, K, O, A), ie && Gn(O, A, K, "beforeUpdate"), K && ol(K, !0), U ? T(A.dynamicChildren, U, L, K, J, ac(O, X), ue) : be || N(A, O, L, null, K, J, ac(O, X), ue, !1), M > 0) {
            if (M & 16) V(L, O, _e, me, K, J, X);
            else if (M & 2 && _e.class !== me.class && r(L, "class", null, me.class, X), M & 4 && r(L, "style", _e.style, me.style, X), M & 8) {
                const oe = O.dynamicProps;
                for (let Ee = 0; Ee < oe.length; Ee++) {
                    const Oe = oe[Ee],
                        et = _e[Oe],
                        Bt = me[Oe];
                    (Bt !== et || Oe === "value") && r(L, Oe, et, Bt, X, A.children, K, J, ee)
                }
            }
            M & 1 && A.children !== O.children && c(L, O.children)
        } else !be && U == null && V(L, O, _e, me, K, J, X);
        ((q = me.onVnodeUpdated) || ie) && Mt(() => {
            q && Xt(q, K, O, A), ie && Gn(O, A, K, "updated")
        }, J)
    }, T = (A, O, K, J, X, ue, be) => {
        for (let L = 0; L < O.length; L++) {
            const M = A[L],
                U = O[L],
                ie = M.el && (M.type === ye || !Nn(M, U) || M.shapeFlag & 70) ? d(M.el) : K;
            h(M, U, ie, null, J, X, ue, be, !0)
        }
    }, V = (A, O, K, J, X, ue, be) => {
        if (K !== J) {
            if (K !== tt)
                for (const L in K) !gr(L) && !(L in J) && r(A, L, K[L], null, be, O.children, X, ue, ee);
            for (const L in J) {
                if (gr(L)) continue;
                const M = J[L],
                    U = K[L];
                M !== U && L !== "value" && r(A, L, U, M, be, O.children, X, ue, ee)
            }
            "value" in J && r(A, "value", K.value, J.value, be)
        }
    }, I = (A, O, K, J, X, ue, be, L, M) => {
        const U = O.el = A ? A.el : i(""),
            ie = O.anchor = A ? A.anchor : i("");
        let {
            patchFlag: _e,
            dynamicChildren: me,
            slotScopeIds: q
        } = O;
        q && (L = L ? L.concat(q) : q), A == null ? (a(U, K, J), a(ie, K, J), P(O.children || [], K, ie, X, ue, be, L, M)) : _e > 0 && _e & 64 && me && A.dynamicChildren ? (T(A.dynamicChildren, me, K, X, ue, be, L), (O.key != null || X && O === X.subTree) && Jf(A, O, !0)) : N(A, O, K, ie, X, ue, be, L, M)
    }, R = (A, O, K, J, X, ue, be, L, M) => {
        O.slotScopeIds = L, A == null ? O.shapeFlag & 512 ? X.ctx.activate(O, K, J, be, M) : B(O, K, J, X, ue, be, M) : $(A, O, M)
    }, B = (A, O, K, J, X, ue, be) => {
        const L = A.component = xp(A, J, X);
        if (ni(A) && (L.ctx.renderer = ce), Ep(L), L.asyncDep) {
            if (X && X.registerDep(L, D), !A.el) {
                const M = L.subTree = m(Nt);
                S(null, M, O, K)
            }
        } else D(L, A, O, K, X, ue, be)
    }, $ = (A, O, K) => {
        const J = O.component = A.component;
        if (B1(A, O, K))
            if (J.asyncDep && !J.asyncResolved) {
                z(J, O, K);
                return
            } else J.next = O, V1(J.update), J.effect.dirty = !0, J.update();
        else O.el = A.el, J.vnode = O
    }, D = (A, O, K, J, X, ue, be) => {
        const L = () => {
                if (A.isMounted) {
                    let {
                        next: ie,
                        bu: _e,
                        u: me,
                        parent: q,
                        vnode: oe
                    } = A; {
                        const ln = bp(A);
                        if (ln) {
                            ie && (ie.el = oe.el, z(A, ie, be)), ln.asyncDep.then(() => {
                                A.isUnmounted || L()
                            });
                            return
                        }
                    }
                    let Ee = ie,
                        Oe;
                    ol(A, !1), ie ? (ie.el = oe.el, z(A, ie, be)) : ie = oe, _e && uo(_e), (Oe = ie.props && ie.props.onVnodeBeforeUpdate) && Xt(Oe, q, ie, oe), ol(A, !0);
                    const et = Ki(A),
                        Bt = A.subTree;
                    A.subTree = et, h(Bt, et, d(Bt.el), G(Bt), A, X, ue), ie.el = et.el, Ee === null && $f(A, et.el), me && Mt(me, X), (Oe = ie.props && ie.props.onVnodeUpdated) && Mt(() => Xt(Oe, q, ie, oe), X)
                } else {
                    let ie;
                    const {
                        el: _e,
                        props: me
                    } = O, {
                        bm: q,
                        m: oe,
                        parent: Ee
                    } = A, Oe = Sl(O);
                    if (ol(A, !1), q && uo(q), !Oe && (ie = me && me.onVnodeBeforeMount) && Xt(ie, Ee, O), ol(A, !0), _e && pe) {
                        const et = () => {
                            A.subTree = Ki(A), pe(_e, A.subTree, A, X, null)
                        };
                        Oe ? O.type.__asyncLoader().then(() => !A.isUnmounted && et()) : et()
                    } else {
                        const et = A.subTree = Ki(A);
                        h(null, et, K, J, A, X, ue), O.el = et.el
                    }
                    if (oe && Mt(oe, X), !Oe && (ie = me && me.onVnodeMounted)) {
                        const et = O;
                        Mt(() => Xt(ie, Ee, et), X)
                    }(O.shapeFlag & 256 || Ee && Sl(Ee.vnode) && Ee.vnode.shapeFlag & 256) && A.a && Mt(A.a, X), A.isMounted = !0, O = K = J = null
                }
            },
            M = A.effect = new Sr(L, Pn, () => Ys(U), A.scope),
            U = A.update = () => {
                M.dirty && M.run()
            };
        U.id = A.uid, ol(A, !0), U()
    }, z = (A, O, K) => {
        O.component = A;
        const J = A.vnode.props;
        A.vnode = O, A.next = null, kx(A, O.props, J, K), Px(A, O.children, K), Bl(), Bm(A), Fl()
    }, N = (A, O, K, J, X, ue, be, L, M = !1) => {
        const U = A && A.children,
            ie = A ? A.shapeFlag : 0,
            _e = O.children,
            {
                patchFlag: me,
                shapeFlag: q
            } = O;
        if (me > 0) {
            if (me & 128) {
                F(U, _e, K, J, X, ue, be, L, M);
                return
            } else if (me & 256) {
                H(U, _e, K, J, X, ue, be, L, M);
                return
            }
        }
        q & 8 ? (ie & 16 && ee(U, X, ue), _e !== U && c(K, _e)) : ie & 16 ? q & 16 ? F(U, _e, K, J, X, ue, be, L, M) : ee(U, X, ue, !0) : (ie & 8 && c(K, ""), q & 16 && P(_e, K, J, X, ue, be, L, M))
    }, H = (A, O, K, J, X, ue, be, L, M) => {
        A = A || hr, O = O || hr;
        const U = A.length,
            ie = O.length,
            _e = Math.min(U, ie);
        let me;
        for (me = 0; me < _e; me++) {
            const q = O[me] = M ? Ba(O[me]) : cn(O[me]);
            h(A[me], q, K, null, X, ue, be, L, M)
        }
        U > ie ? ee(A, X, ue, !0, !1, _e) : P(O, K, J, X, ue, be, L, M, _e)
    }, F = (A, O, K, J, X, ue, be, L, M) => {
        let U = 0;
        const ie = O.length;
        let _e = A.length - 1,
            me = ie - 1;
        for (; U <= _e && U <= me;) {
            const q = A[U],
                oe = O[U] = M ? Ba(O[U]) : cn(O[U]);
            if (Nn(q, oe)) h(q, oe, K, null, X, ue, be, L, M);
            else break;
            U++
        }
        for (; U <= _e && U <= me;) {
            const q = A[_e],
                oe = O[me] = M ? Ba(O[me]) : cn(O[me]);
            if (Nn(q, oe)) h(q, oe, K, null, X, ue, be, L, M);
            else break;
            _e--, me--
        }
        if (U > _e) {
            if (U <= me) {
                const q = me + 1,
                    oe = q < ie ? O[q].el : J;
                for (; U <= me;) h(null, O[U] = M ? Ba(O[U]) : cn(O[U]), K, oe, X, ue, be, L, M), U++
            }
        } else if (U > me)
            for (; U <= _e;) ae(A[U], X, ue, !0), U++;
        else {
            const q = U,
                oe = U,
                Ee = new Map;
            for (U = oe; U <= me; U++) {
                const rn = O[U] = M ? Ba(O[U]) : cn(O[U]);
                rn.key != null && Ee.set(rn.key, U)
            }
            let Oe, et = 0;
            const Bt = me - oe + 1;
            let ln = !1,
                pi = 0;
            const er = new Array(Bt);
            for (U = 0; U < Bt; U++) er[U] = 0;
            for (U = q; U <= _e; U++) {
                const rn = A[U];
                if (et >= Bt) {
                    ae(rn, X, ue, !0);
                    continue
                }
                let zn;
                if (rn.key != null) zn = Ee.get(rn.key);
                else
                    for (Oe = oe; Oe <= me; Oe++)
                        if (er[Oe - oe] === 0 && Nn(rn, O[Oe])) {
                            zn = Oe;
                            break
                        }
                zn === void 0 ? ae(rn, X, ue, !0) : (er[zn - oe] = U + 1, zn >= pi ? pi = zn : ln = !0, h(rn, O[zn], K, null, X, ue, be, L, M), et++)
            }
            const Tm = ln ? Vx(er) : hr;
            for (Oe = Tm.length - 1, U = Bt - 1; U >= 0; U--) {
                const rn = oe + U,
                    zn = O[rn],
                    Vm = rn + 1 < ie ? O[rn + 1].el : J;
                er[U] === 0 ? h(null, zn, K, Vm, X, ue, be, L, M) : ln && (Oe < 0 || U !== Tm[Oe] ? j(zn, K, Vm, 2) : Oe--)
            }
        }
    }, j = (A, O, K, J, X = null) => {
        const {
            el: ue,
            type: be,
            transition: L,
            children: M,
            shapeFlag: U
        } = A;
        if (U & 6) {
            j(A.component.subTree, O, K, J);
            return
        }
        if (U & 128) {
            A.suspense.move(O, K, J);
            return
        }
        if (U & 64) {
            be.move(A, O, K, ce);
            return
        }
        if (be === ye) {
            a(ue, O, K);
            for (let _e = 0; _e < M.length; _e++) j(M[_e], O, K, J);
            a(A.anchor, O, K);
            return
        }
        if (be === wl) {
            p(A, O, K);
            return
        }
        if (J !== 2 && U & 1 && L)
            if (J === 0) L.beforeEnter(ue), a(ue, O, K), Mt(() => L.enter(ue), X);
            else {
                const {
                    leave: _e,
                    delayLeave: me,
                    afterLeave: q
                } = L, oe = () => a(ue, O, K), Ee = () => {
                    _e(ue, () => {
                        oe(), q && q()
                    })
                };
                me ? me(ue, oe, Ee) : Ee()
            }
        else a(ue, O, K)
    }, ae = (A, O, K, J = !1, X = !1) => {
        const {
            type: ue,
            props: be,
            ref: L,
            children: M,
            dynamicChildren: U,
            shapeFlag: ie,
            patchFlag: _e,
            dirs: me
        } = A;
        if (L != null && ss(L, null, K, A, !0), ie & 256) {
            O.ctx.deactivate(A);
            return
        }
        const q = ie & 1 && me,
            oe = !Sl(A);
        let Ee;
        if (oe && (Ee = be && be.onVnodeBeforeUnmount) && Xt(Ee, O, A), ie & 6) we(A.component, K, J);
        else {
            if (ie & 128) {
                A.suspense.unmount(K, J);
                return
            }
            q && Gn(A, null, O, "beforeUnmount"), ie & 64 ? A.type.remove(A, O, K, X, ce, J) : U && (ue !== ye || _e > 0 && _e & 64) ? ee(U, O, K, !1, !0) : (ue === ye && _e & 384 || !X && ie & 16) && ee(M, O, K), J && he(A)
        }(oe && (Ee = be && be.onVnodeUnmounted) || q) && Mt(() => {
            Ee && Xt(Ee, O, A), q && Gn(A, null, O, "unmounted")
        }, K)
    }, he = A => {
        const {
            type: O,
            el: K,
            anchor: J,
            transition: X
        } = A;
        if (O === ye) {
            ve(K, J);
            return
        }
        if (O === wl) {
            _(A);
            return
        }
        const ue = () => {
            l(K), X && !X.persisted && X.afterLeave && X.afterLeave()
        };
        if (A.shapeFlag & 1 && X && !X.persisted) {
            const {
                leave: be,
                delayLeave: L
            } = X, M = () => be(K, ue);
            L ? L(A.el, ue, M) : M()
        } else ue()
    }, ve = (A, O) => {
        let K;
        for (; A !== O;) K = f(A), l(A), A = K;
        l(O)
    }, we = (A, O, K) => {
        const {
            bum: J,
            scope: X,
            update: ue,
            subTree: be,
            um: L
        } = A;
        J && uo(J), X.stop(), ue && (ue.active = !1, ae(be, A, O, K)), L && Mt(L, O), Mt(() => {
            A.isUnmounted = !0
        }, O), O && O.pendingBranch && !O.isUnmounted && A.asyncDep && !A.asyncResolved && A.suspenseId === O.pendingId && (O.deps--, O.deps === 0 && O.resolve())
    }, ee = (A, O, K, J = !1, X = !1, ue = 0) => {
        for (let be = ue; be < A.length; be++) ae(A[be], O, K, J, X)
    }, G = A => A.shapeFlag & 6 ? G(A.component.subTree) : A.shapeFlag & 128 ? A.suspense.next() : f(A.anchor || A.el);
    let le = !1;
    const se = (A, O, K) => {
            A == null ? O._vnode && ae(O._vnode, null, null, !0) : h(O._vnode || null, A, O, null, null, null, K), le || (le = !0, Bm(), os(), le = !1), O._vnode = A
        },
        ce = {
            p: h,
            um: ae,
            m: j,
            r: he,
            mt: B,
            mc: P,
            pc: N,
            pbc: T,
            n: G,
            o: e
        };
    let re, pe;
    return t && ([re, pe] = t(ce)), {
        render: se,
        hydrate: re,
        createApp: Sx(se, re)
    }
}

function ac({
    type: e,
    props: t
}, n) {
    return n === "svg" && e === "foreignObject" || n === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : n
}

function ol({
    effect: e,
    update: t
}, n) {
    e.allowRecurse = t.allowRecurse = n
}

function yp(e, t) {
    return (!e || e && !e.pendingBranch) && t && !t.persisted
}

function Jf(e, t, n = !1) {
    const a = e.children,
        l = t.children;
    if (Me(a) && Me(l))
        for (let r = 0; r < a.length; r++) {
            const o = a[r];
            let i = l[r];
            i.shapeFlag & 1 && !i.dynamicChildren && ((i.patchFlag <= 0 || i.patchFlag === 32) && (i = l[r] = Ba(l[r]), i.el = o.el), n || Jf(o, i)), i.type === Sa && (i.el = o.el)
        }
}

function Vx(e) {
    const t = e.slice(),
        n = [0];
    let a, l, r, o, i;
    const s = e.length;
    for (a = 0; a < s; a++) {
        const u = e[a];
        if (u !== 0) {
            if (l = n[n.length - 1], e[l] < u) {
                t[a] = l, n.push(a);
                continue
            }
            for (r = 0, o = n.length - 1; r < o;) i = r + o >> 1, e[n[i]] < u ? r = i + 1 : o = i;
            u < e[n[r]] && (r > 0 && (t[a] = n[r - 1]), n[r] = a)
        }
    }
    for (r = n.length, o = n[r - 1]; r-- > 0;) n[r] = o, o = t[o];
    return n
}

function bp(e) {
    const t = e.subTree.component;
    if (t) return t.asyncDep && !t.asyncResolved ? t : bp(t)
}
const Ax = e => e.__isTeleport,
    fo = e => e && (e.disabled || e.disabled === ""),
    Jm = e => typeof SVGElement < "u" && e instanceof SVGElement,
    Zm = e => typeof MathMLElement == "function" && e instanceof MathMLElement,
    Hc = (e, t) => {
        const n = e && e.to;
        return Tt(n) ? t ? t(n) : null : n
    },
    Lx = {
        name: "Teleport",
        __isTeleport: !0,
        process(e, t, n, a, l, r, o, i, s, u) {
            const {
                mc: c,
                pc: d,
                pbc: f,
                o: {
                    insert: v,
                    querySelector: g,
                    createText: h,
                    createComment: y
                }
            } = u, S = fo(t.props);
            let {
                shapeFlag: b,
                children: p,
                dynamicChildren: _
            } = t;
            if (e == null) {
                const w = t.el = h(""),
                    k = t.anchor = h("");
                v(w, n, a), v(k, n, a);
                const E = t.target = Hc(t.props, g),
                    P = t.targetAnchor = h("");
                E && (v(P, E), o === "svg" || Jm(E) ? o = "svg" : (o === "mathml" || Zm(E)) && (o = "mathml"));
                const x = (T, V) => {
                    b & 16 && c(p, T, V, l, r, o, i, s)
                };
                S ? x(n, k) : E && x(E, P)
            } else {
                t.el = e.el;
                const w = t.anchor = e.anchor,
                    k = t.target = e.target,
                    E = t.targetAnchor = e.targetAnchor,
                    P = fo(e.props),
                    x = P ? n : k,
                    T = P ? w : E;
                if (o === "svg" || Jm(k) ? o = "svg" : (o === "mathml" || Zm(k)) && (o = "mathml"), _ ? (f(e.dynamicChildren, _, x, l, r, o, i), Jf(e, t, !0)) : s || d(e, t, x, T, l, r, o, i, !1), S) P ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to) : Vi(t, n, w, u, 1);
                else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
                    const V = t.target = Hc(t.props, g);
                    V && Vi(t, V, null, u, 0)
                } else P && Vi(t, k, E, u, 1)
            }
            _p(t)
        },
        remove(e, t, n, a, {
            um: l,
            o: {
                remove: r
            }
        }, o) {
            const {
                shapeFlag: i,
                children: s,
                anchor: u,
                targetAnchor: c,
                target: d,
                props: f
            } = e;
            if (d && r(c), o && r(u), i & 16) {
                const v = o || !fo(f);
                for (let g = 0; g < s.length; g++) {
                    const h = s[g];
                    l(h, t, n, v, !!h.dynamicChildren)
                }
            }
        },
        move: Vi,
        hydrate: Ox
    };

function Vi(e, t, n, {
    o: {
        insert: a
    },
    m: l
}, r = 2) {
    r === 0 && a(e.targetAnchor, t, n);
    const {
        el: o,
        anchor: i,
        shapeFlag: s,
        children: u,
        props: c
    } = e, d = r === 2;
    if (d && a(o, t, n), (!d || fo(c)) && s & 16)
        for (let f = 0; f < u.length; f++) l(u[f], t, n, 2);
    d && a(i, t, n)
}

function Ox(e, t, n, a, l, r, {
    o: {
        nextSibling: o,
        parentNode: i,
        querySelector: s
    }
}, u) {
    const c = t.target = Hc(t.props, s);
    if (c) {
        const d = c._lpa || c.firstChild;
        if (t.shapeFlag & 16)
            if (fo(t.props)) t.anchor = u(o(e), t, i(e), n, a, l, r), t.targetAnchor = d;
            else {
                t.anchor = o(e);
                let f = d;
                for (; f;)
                    if (f = o(f), f && f.nodeType === 8 && f.data === "teleport anchor") {
                        t.targetAnchor = f, c._lpa = t.targetAnchor && o(t.targetAnchor);
                        break
                    }
                u(d, t, c, n, a, l, r)
            }
        _p(t)
    }
    return t.anchor && o(t.anchor)
}
const pp = Lx;

function _p(e) {
    const t = e.ctx;
    if (t && t.ut) {
        let n = e.children[0].el;
        for (; n && n !== e.targetAnchor;) n.nodeType === 1 && n.setAttribute("data-v-owner", t.uid), n = n.nextSibling;
        t.ut()
    }
}
const ye = Symbol.for("v-fgt"),
    Sa = Symbol.for("v-txt"),
    Nt = Symbol.for("v-cmt"),
    wl = Symbol.for("v-stc"),
    vo = [];
let Jt = null;

function Cn(e = !1) {
    vo.push(Jt = e ? null : [])
}

function Sp() {
    vo.pop(), Jt = vo[vo.length - 1] || null
}
let Tl = 1;

function jc(e) {
    Tl += e
}

function wp(e) {
    return e.dynamicChildren = Tl > 0 ? Jt || hr : null, Sp(), Tl > 0 && Jt && Jt.push(e), e
}

function kp(e, t, n, a, l, r) {
    return wp(Zf(e, t, n, a, l, r, !0))
}

function qn(e, t, n, a, l) {
    return wp(m(e, t, n, a, l, !0))
}

function wa(e) {
    return e ? e.__v_isVNode === !0 : !1
}

function Nn(e, t) {
    return e.type === t.type && e.key === t.key
}

function Rx(e) {}
const au = "__vInternal",
    Cp = ({
        key: e
    }) => e ? ? null,
    Gi = ({
        ref: e,
        ref_key: t,
        ref_for: n
    }) => (typeof e == "number" && (e = "" + e), e != null ? Tt(e) || Ge(e) || De(e) ? {
        i: St,
        r: e,
        k: t,
        f: !!n
    } : e : null);

function Zf(e, t = null, n = null, a = 0, l = null, r = e === ye ? 0 : 1, o = !1, i = !1) {
    const s = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e,
        props: t,
        key: t && Cp(t),
        ref: t && Gi(t),
        scopeId: Xs,
        slotScopeIds: null,
        children: n,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: r,
        patchFlag: a,
        dynamicProps: l,
        dynamicChildren: null,
        appContext: null,
        ctx: St
    };
    return i ? (ev(s, n), r & 128 && e.normalize(s)) : n && (s.shapeFlag |= Tt(n) ? 8 : 16), Tl > 0 && !o && Jt && (s.patchFlag > 0 || r & 6) && s.patchFlag !== 32 && Jt.push(s), s
}
const m = Dx;

function Dx(e, t = null, n = null, a = 0, l = null, r = !1) {
    if ((!e || e === Wb) && (e = Nt), wa(e)) {
        const i = $n(e, t, !0);
        return n && ev(i, n), Tl > 0 && !r && Jt && (i.shapeFlag & 6 ? Jt[Jt.indexOf(e)] = i : Jt.push(i)), i.patchFlag |= -2, i
    }
    if (Wx(e) && (e = e.__vccOpts), t) {
        t = Qf(t);
        let {
            class: i,
            style: s
        } = t;
        i && !Tt(i) && (t.class = Hr(i)), wt(s) && (Vf(s) && !Me(s) && (s = Lt({}, s)), t.style = ei(s))
    }
    const o = Tt(e) ? 1 : zb(e) ? 128 : Ax(e) ? 64 : wt(e) ? 4 : De(e) ? 2 : 0;
    return Zf(e, t, n, a, l, o, r, !0)
}

function Qf(e) {
    return e ? Vf(e) || au in e ? Lt({}, e) : e : null
}

function $n(e, t, n = !1) {
    const {
        props: a,
        ref: l,
        patchFlag: r,
        children: o
    } = e, i = t ? te(a || {}, t) : a;
    return {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e.type,
        props: i,
        key: i && Cp(i),
        ref: t && t.ref ? n && l ? Me(l) ? l.concat(Gi(t)) : [l, Gi(t)] : Gi(t) : l,
        scopeId: e.scopeId,
        slotScopeIds: e.slotScopeIds,
        children: o,
        target: e.target,
        targetAnchor: e.targetAnchor,
        staticCount: e.staticCount,
        shapeFlag: e.shapeFlag,
        patchFlag: t && e.type !== ye ? r === -1 ? 16 : r | 16 : r,
        dynamicProps: e.dynamicProps,
        dynamicChildren: e.dynamicChildren,
        appContext: e.appContext,
        dirs: e.dirs,
        transition: e.transition,
        component: e.component,
        suspense: e.suspense,
        ssContent: e.ssContent && $n(e.ssContent),
        ssFallback: e.ssFallback && $n(e.ssFallback),
        el: e.el,
        anchor: e.anchor,
        ctx: e.ctx,
        ce: e.ce
    }
}

function hn(e = " ", t = 0) {
    return m(Sa, null, e, t)
}

function Mx(e, t) {
    const n = m(wl, null, e);
    return n.staticCount = t, n
}

function Nx(e = "", t = !1) {
    return t ? (Cn(), qn(Nt, null, e)) : m(Nt, null, e)
}

function cn(e) {
    return e == null || typeof e == "boolean" ? m(Nt) : Me(e) ? m(ye, null, e.slice()) : typeof e == "object" ? Ba(e) : m(Sa, null, String(e))
}

function Ba(e) {
    return e.el === null && e.patchFlag !== -1 || e.memo ? e : $n(e)
}

function ev(e, t) {
    let n = 0;
    const {
        shapeFlag: a
    } = e;
    if (t == null) t = null;
    else if (Me(t)) n = 16;
    else if (typeof t == "object")
        if (a & 65) {
            const l = t.default;
            l && (l._c && (l._d = !1), ev(e, l()), l._c && (l._d = !0));
            return
        } else {
            n = 32;
            const l = t._;
            !l && !(au in t) ? t._ctx = St : l === 3 && St && (St.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024))
        }
    else De(t) ? (t = {
        default: t,
        _ctx: St
    }, n = 32) : (t = String(t), a & 64 ? (n = 16, t = [hn(t)]) : n = 8);
    e.children = t, e.shapeFlag |= n
}

function te(...e) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
        const a = e[n];
        for (const l in a)
            if (l === "class") t.class !== a.class && (t.class = Hr([t.class, a.class]));
            else if (l === "style") t.style = ei([t.style, a.style]);
        else if (zs(l)) {
            const r = t[l],
                o = a[l];
            o && r !== o && !(Me(r) && r.includes(o)) && (t[l] = r ? [].concat(r, o) : o)
        } else l !== "" && (t[l] = a[l])
    }
    return t
}

function Xt(e, t, n, a = null) {
    vn(e, t, 7, [n, a])
}
const $x = sp();
let Bx = 0;

function xp(e, t, n) {
    const a = e.type,
        l = (t ? t.appContext : e.appContext) || $x,
        r = {
            uid: Bx++,
            vnode: e,
            type: a,
            parent: t,
            appContext: l,
            root: null,
            next: null,
            subTree: null,
            effect: null,
            update: null,
            scope: new Pf(!0),
            render: null,
            proxy: null,
            exposed: null,
            exposeProxy: null,
            withProxy: null,
            provides: t ? t.provides : Object.create(l.provides),
            accessCache: null,
            renderCache: [],
            components: null,
            directives: null,
            propsOptions: cp(a, l),
            emitsOptions: jb(a, l),
            emit: null,
            emitted: null,
            propsDefaults: tt,
            inheritAttrs: a.inheritAttrs,
            ctx: tt,
            data: tt,
            props: tt,
            attrs: tt,
            slots: tt,
            refs: tt,
            setupState: tt,
            setupContext: null,
            attrsProxy: null,
            slotsProxy: null,
            suspense: n,
            suspenseId: n ? n.pendingId : 0,
            asyncDep: null,
            asyncResolved: !1,
            isMounted: !1,
            isUnmounted: !1,
            isDeactivated: !1,
            bc: null,
            c: null,
            bm: null,
            m: null,
            bu: null,
            u: null,
            um: null,
            bum: null,
            da: null,
            a: null,
            rtg: null,
            rtc: null,
            ec: null,
            sp: null
        };
    return r.ctx = {
        _: r
    }, r.root = t ? t.root : r, r.emit = L1.bind(null, r), e.ce && e.ce(r), r
}
let Et = null;
const nn = () => Et || St;
let us, Uc; {
    const e = Rb(),
        t = (n, a) => {
            let l;
            return (l = e[n]) || (l = e[n] = []), l.push(a), r => {
                l.length > 1 ? l.forEach(o => o(r)) : l[0](r)
            }
        };
    us = t("__VUE_INSTANCE_SETTERS__", n => Et = n), Uc = t("__VUE_SSR_SETTERS__", n => li = n)
}
const Vl = e => {
        const t = Et;
        return us(e), e.scope.on(), () => {
            e.scope.off(), us(t)
        }
    },
    Wc = () => {
        Et && Et.scope.off(), us(null)
    };

function Pp(e) {
    return e.vnode.shapeFlag & 4
}
let li = !1;

function Ep(e, t = !1) {
    t && Uc(t);
    const {
        props: n,
        children: a
    } = e.vnode, l = Pp(e);
    wx(e, n, l, t), xx(e, a);
    const r = l ? Fx(e, t) : void 0;
    return t && Uc(!1), r
}

function Fx(e, t) {
    const n = e.type;
    e.accessCache = Object.create(null), e.proxy = Fr(new Proxy(e.ctx, Nc));
    const {
        setup: a
    } = n;
    if (a) {
        const l = e.setupContext = a.length > 1 ? Tp(e) : null,
            r = Vl(e);
        Bl();
        const o = _a(a, e, 0, [e.props, l]);
        if (Fl(), r(), Mf(o)) {
            if (o.then(Wc, Wc), t) return o.then(i => {
                zc(e, i, t)
            }).catch(i => {
                Hl(i, e, 0)
            });
            e.asyncDep = o
        } else zc(e, o, t)
    } else Ip(e, t)
}

function zc(e, t, n) {
    De(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : wt(t) && (e.setupState = Of(t)), Ip(e, n)
}
let cs, Kc;

function Hx(e) {
    cs = e, Kc = t => {
        t.render._rc && (t.withProxy = new Proxy(t.ctx, tx))
    }
}
const jx = () => !cs;

function Ip(e, t, n) {
    const a = e.type;
    if (!e.render) {
        if (!t && cs && !a.render) {
            const l = a.template || qf(e).template;
            if (l) {
                const {
                    isCustomElement: r,
                    compilerOptions: o
                } = e.appContext.config, {
                    delimiters: i,
                    compilerOptions: s
                } = a, u = Lt(Lt({
                    isCustomElement: r,
                    delimiters: i
                }, o), s);
                a.render = cs(l, u)
            }
        }
        e.render = a.render || Pn, Kc && Kc(e)
    } {
        const l = Vl(e);
        Bl();
        try {
            hx(e)
        } finally {
            Fl(), l()
        }
    }
}

function Ux(e) {
    return e.attrsProxy || (e.attrsProxy = new Proxy(e.attrs, {
        get(t, n) {
            return Zt(e, "get", "$attrs"), t[n]
        }
    }))
}

function Tp(e) {
    const t = n => {
        e.exposed = n || {}
    };
    return {
        get attrs() {
            return Ux(e)
        },
        slots: e.slots,
        emit: e.emit,
        expose: t
    }
}

function lu(e) {
    if (e.exposed) return e.exposeProxy || (e.exposeProxy = new Proxy(Of(Fr(e.exposed)), {
        get(t, n) {
            if (n in t) return t[n];
            if (n in co) return co[n](e)
        },
        has(t, n) {
            return n in t || n in co
        }
    }))
}

function Gc(e, t = !0) {
    return De(e) ? e.displayName || e.name : e.name || t && e.__name
}

function Wx(e) {
    return De(e) && "__vccOpts" in e
}
const C = (e, t) => n1(e, t, li);

function zx(e, t, n = tt) {
    const a = nn(),
        l = Qt(t),
        r = Qo(t),
        o = Rf((s, u) => {
            let c;
            return Xb(() => {
                const d = e[t];
                wo(c, d) && (c = d, u())
            }), {
                get() {
                    return s(), n.get ? n.get(c) : c
                },
                set(d) {
                    const f = a.vnode.props;
                    !(f && (t in f || l in f || r in f) && (`onUpdate:${t}` in f || `onUpdate:${l}` in f || `onUpdate:${r}` in f)) && wo(d, c) && (c = d, u()), a.emit(`update:${t}`, n.set ? n.set(d) : d)
                }
            }
        }),
        i = t === "modelValue" ? "modelModifiers" : `${t}Modifiers`;
    return o[Symbol.iterator] = () => {
        let s = 0;
        return {
            next() {
                return s < 2 ? {
                    value: s++ ? e[i] || {} : o,
                    done: !1
                } : {
                    done: !0
                }
            }
        }
    }, o
}

function ht(e, t, n) {
    const a = arguments.length;
    return a === 2 ? wt(t) && !Me(t) ? wa(t) ? m(e, null, [t]) : m(e, t) : m(e, null, t) : (a > 3 ? n = Array.prototype.slice.call(arguments, 2) : a === 3 && wa(n) && (n = [n]), m(e, t, n))
}

function Kx() {}

function Gx(e, t, n, a) {
    const l = n[a];
    if (l && Vp(l, e)) return l;
    const r = t();
    return r.memo = e.slice(), n[a] = r
}

function Vp(e, t) {
    const n = e.memo;
    if (n.length != t.length) return !1;
    for (let a = 0; a < n.length; a++)
        if (wo(n[a], t[a])) return !1;
    return Tl > 0 && Jt && Jt.push(e), !0
}
const tv = "3.4.21",
    Yx = Pn,
    qx = E1,
    Xx = ir,
    Jx = Hb,
    Zx = {
        createComponentInstance: xp,
        setupComponent: Ep,
        renderComponentRoot: Ki,
        setCurrentRenderingInstance: xo,
        isVNode: wa,
        normalizeVNode: cn
    },
    Qx = Zx,
    eP = null,
    tP = null,
    nP = null;
/**
 * @vue/shared v3.4.21
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
function aP(e, t) {
    const n = new Set(e.split(","));
    return a => n.has(a)
}
const lc = {},
    lP = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97),
    rP = e => e.startsWith("onUpdate:"),
    ri = Object.assign,
    gn = Array.isArray,
    oi = e => Lp(e) === "[object Set]",
    Qm = e => Lp(e) === "[object Date]",
    Ap = e => typeof e == "function",
    Io = e => typeof e == "string",
    eh = e => typeof e == "symbol",
    Yc = e => e !== null && typeof e == "object",
    oP = Object.prototype.toString,
    Lp = e => oP.call(e),
    nv = e => {
        const t = Object.create(null);
        return n => t[n] || (t[n] = e(n))
    },
    iP = /-(\w)/g,
    rc = nv(e => e.replace(iP, (t, n) => n ? n.toUpperCase() : "")),
    sP = /\B([A-Z])/g,
    Ua = nv(e => e.replace(sP, "-$1").toLowerCase()),
    uP = nv(e => e.charAt(0).toUpperCase() + e.slice(1)),
    cP = (e, t) => {
        for (let n = 0; n < e.length; n++) e[n](t)
    },
    ds = e => {
        const t = parseFloat(e);
        return isNaN(t) ? e : t
    },
    qc = e => {
        const t = Io(e) ? Number(e) : NaN;
        return isNaN(t) ? e : t
    },
    dP = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
    fP = aP(dP);

function Op(e) {
    return !!e || e === ""
}

function vP(e, t) {
    if (e.length !== t.length) return !1;
    let n = !0;
    for (let a = 0; n && a < e.length; a++) n = qa(e[a], t[a]);
    return n
}

function qa(e, t) {
    if (e === t) return !0;
    let n = Qm(e),
        a = Qm(t);
    if (n || a) return n && a ? e.getTime() === t.getTime() : !1;
    if (n = eh(e), a = eh(t), n || a) return e === t;
    if (n = gn(e), a = gn(t), n || a) return n && a ? vP(e, t) : !1;
    if (n = Yc(e), a = Yc(t), n || a) {
        if (!n || !a) return !1;
        const l = Object.keys(e).length,
            r = Object.keys(t).length;
        if (l !== r) return !1;
        for (const o in e) {
            const i = e.hasOwnProperty(o),
                s = t.hasOwnProperty(o);
            if (i && !s || !i && s || !qa(e[o], t[o])) return !1
        }
    }
    return String(e) === String(t)
}

function ru(e, t) {
    return e.findIndex(n => qa(n, t))
}
/**
 * @vue/runtime-dom v3.4.21
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
const mP = "http://www.w3.org/2000/svg",
    hP = "http://www.w3.org/1998/Math/MathML",
    Fa = typeof document < "u" ? document : null,
    th = Fa && Fa.createElement("template"),
    gP = {
        insert: (e, t, n) => {
            t.insertBefore(e, n || null)
        },
        remove: e => {
            const t = e.parentNode;
            t && t.removeChild(e)
        },
        createElement: (e, t, n, a) => {
            const l = t === "svg" ? Fa.createElementNS(mP, e) : t === "mathml" ? Fa.createElementNS(hP, e) : Fa.createElement(e, n ? {
                is: n
            } : void 0);
            return e === "select" && a && a.multiple != null && l.setAttribute("multiple", a.multiple), l
        },
        createText: e => Fa.createTextNode(e),
        createComment: e => Fa.createComment(e),
        setText: (e, t) => {
            e.nodeValue = t
        },
        setElementText: (e, t) => {
            e.textContent = t
        },
        parentNode: e => e.parentNode,
        nextSibling: e => e.nextSibling,
        querySelector: e => Fa.querySelector(e),
        setScopeId(e, t) {
            e.setAttribute(t, "")
        },
        insertStaticContent(e, t, n, a, l, r) {
            const o = n ? n.previousSibling : t.lastChild;
            if (l && (l === r || l.nextSibling))
                for (; t.insertBefore(l.cloneNode(!0), n), !(l === r || !(l = l.nextSibling)););
            else {
                th.innerHTML = a === "svg" ? `<svg>${e}</svg>` : a === "mathml" ? `<math>${e}</math>` : e;
                const i = th.content;
                if (a === "svg" || a === "mathml") {
                    const s = i.firstChild;
                    for (; s.firstChild;) i.appendChild(s.firstChild);
                    i.removeChild(s)
                }
                t.insertBefore(i, n)
            }
            return [o ? o.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild]
        }
    },
    La = "transition",
    eo = "animation",
    kr = Symbol("_vtc"),
    Tn = (e, {
        slots: t
    }) => ht(Zb, Dp(e), t);
Tn.displayName = "Transition";
const Rp = {
        name: String,
        type: String,
        css: {
            type: Boolean,
            default: !0
        },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String
    },
    yP = Tn.props = ri({}, zf, Rp),
    il = (e, t = []) => {
        gn(e) ? e.forEach(n => n(...t)) : e && e(...t)
    },
    nh = e => e ? gn(e) ? e.some(t => t.length > 1) : e.length > 1 : !1;

function Dp(e) {
    const t = {};
    for (const I in e) I in Rp || (t[I] = e[I]);
    if (e.css === !1) return t;
    const {
        name: n = "v",
        type: a,
        duration: l,
        enterFromClass: r = `${n}-enter-from`,
        enterActiveClass: o = `${n}-enter-active`,
        enterToClass: i = `${n}-enter-to`,
        appearFromClass: s = r,
        appearActiveClass: u = o,
        appearToClass: c = i,
        leaveFromClass: d = `${n}-leave-from`,
        leaveActiveClass: f = `${n}-leave-active`,
        leaveToClass: v = `${n}-leave-to`
    } = e, g = bP(l), h = g && g[0], y = g && g[1], {
        onBeforeEnter: S,
        onEnter: b,
        onEnterCancelled: p,
        onLeave: _,
        onLeaveCancelled: w,
        onBeforeAppear: k = S,
        onAppear: E = b,
        onAppearCancelled: P = p
    } = t, x = (I, R, B) => {
        Da(I, R ? c : i), Da(I, R ? u : o), B && B()
    }, T = (I, R) => {
        I._isLeaving = !1, Da(I, d), Da(I, v), Da(I, f), R && R()
    }, V = I => (R, B) => {
        const $ = I ? E : b,
            D = () => x(R, I, B);
        il($, [R, D]), ah(() => {
            Da(R, I ? s : r), va(R, I ? c : i), nh($) || lh(R, a, h, D)
        })
    };
    return ri(t, {
        onBeforeEnter(I) {
            il(S, [I]), va(I, r), va(I, o)
        },
        onBeforeAppear(I) {
            il(k, [I]), va(I, s), va(I, u)
        },
        onEnter: V(!1),
        onAppear: V(!0),
        onLeave(I, R) {
            I._isLeaving = !0;
            const B = () => T(I, R);
            va(I, d), Np(), va(I, f), ah(() => {
                I._isLeaving && (Da(I, d), va(I, v), nh(_) || lh(I, a, y, B))
            }), il(_, [I, B])
        },
        onEnterCancelled(I) {
            x(I, !1), il(p, [I])
        },
        onAppearCancelled(I) {
            x(I, !0), il(P, [I])
        },
        onLeaveCancelled(I) {
            T(I), il(w, [I])
        }
    })
}

function bP(e) {
    if (e == null) return null;
    if (Yc(e)) return [oc(e.enter), oc(e.leave)]; {
        const t = oc(e);
        return [t, t]
    }
}

function oc(e) {
    return qc(e)
}

function va(e, t) {
    t.split(/\s+/).forEach(n => n && e.classList.add(n)), (e[kr] || (e[kr] = new Set)).add(t)
}

function Da(e, t) {
    t.split(/\s+/).forEach(a => a && e.classList.remove(a));
    const n = e[kr];
    n && (n.delete(t), n.size || (e[kr] = void 0))
}

function ah(e) {
    requestAnimationFrame(() => {
        requestAnimationFrame(e)
    })
}
let pP = 0;

function lh(e, t, n, a) {
    const l = e._endId = ++pP,
        r = () => {
            l === e._endId && a()
        };
    if (n) return setTimeout(r, n);
    const {
        type: o,
        timeout: i,
        propCount: s
    } = Mp(e, t);
    if (!o) return a();
    const u = o + "end";
    let c = 0;
    const d = () => {
            e.removeEventListener(u, f), r()
        },
        f = v => {
            v.target === e && ++c >= s && d()
        };
    setTimeout(() => {
        c < s && d()
    }, i + 1), e.addEventListener(u, f)
}

function Mp(e, t) {
    const n = window.getComputedStyle(e),
        a = g => (n[g] || "").split(", "),
        l = a(`${La}Delay`),
        r = a(`${La}Duration`),
        o = rh(l, r),
        i = a(`${eo}Delay`),
        s = a(`${eo}Duration`),
        u = rh(i, s);
    let c = null,
        d = 0,
        f = 0;
    t === La ? o > 0 && (c = La, d = o, f = r.length) : t === eo ? u > 0 && (c = eo, d = u, f = s.length) : (d = Math.max(o, u), c = d > 0 ? o > u ? La : eo : null, f = c ? c === La ? r.length : s.length : 0);
    const v = c === La && /\b(transform|all)(,|$)/.test(a(`${La}Property`).toString());
    return {
        type: c,
        timeout: d,
        propCount: f,
        hasTransform: v
    }
}

function rh(e, t) {
    for (; e.length < t.length;) e = e.concat(e);
    return Math.max(...t.map((n, a) => oh(n) + oh(e[a])))
}

function oh(e) {
    return e === "auto" ? 0 : Number(e.slice(0, -1).replace(",", ".")) * 1e3
}

function Np() {
    return document.body.offsetHeight
}

function _P(e, t, n) {
    const a = e[kr];
    a && (t = (t ? [t, ...a] : [...a]).join(" ")), t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t
}
const fs = Symbol("_vod"),
    $p = Symbol("_vsh"),
    bn = {
        beforeMount(e, {
            value: t
        }, {
            transition: n
        }) {
            e[fs] = e.style.display === "none" ? "" : e.style.display, n && t ? n.beforeEnter(e) : to(e, t)
        },
        mounted(e, {
            value: t
        }, {
            transition: n
        }) {
            n && t && n.enter(e)
        },
        updated(e, {
            value: t,
            oldValue: n
        }, {
            transition: a
        }) {
            !t != !n && (a ? t ? (a.beforeEnter(e), to(e, !0), a.enter(e)) : a.leave(e, () => {
                to(e, !1)
            }) : to(e, t))
        },
        beforeUnmount(e, {
            value: t
        }) {
            to(e, t)
        }
    };

function to(e, t) {
    e.style.display = t ? e[fs] : "none", e[$p] = !t
}

function SP() {
    bn.getSSRProps = ({
        value: e
    }) => {
        if (!e) return {
            style: {
                display: "none"
            }
        }
    }
}
const Bp = Symbol("");

function wP(e) {
    const t = nn();
    if (!t) return;
    const n = t.ut = (l = e(t.proxy)) => {
            Array.from(document.querySelectorAll(`[data-v-owner="${t.uid}"]`)).forEach(r => Jc(r, l))
        },
        a = () => {
            const l = e(t.proxy);
            Xc(t.subTree, l), n(l)
        };
    qb(a), it(() => {
        const l = new MutationObserver(a);
        l.observe(t.subTree.el.parentNode, {
            childList: !0
        }), jr(() => l.disconnect())
    })
}

function Xc(e, t) {
    if (e.shapeFlag & 128) {
        const n = e.suspense;
        e = n.activeBranch, n.pendingBranch && !n.isHydrating && n.effects.push(() => {
            Xc(n.activeBranch, t)
        })
    }
    for (; e.component;) e = e.component.subTree;
    if (e.shapeFlag & 1 && e.el) Jc(e.el, t);
    else if (e.type === ye) e.children.forEach(n => Xc(n, t));
    else if (e.type === wl) {
        let {
            el: n,
            anchor: a
        } = e;
        for (; n && (Jc(n, t), n !== a);) n = n.nextSibling
    }
}

function Jc(e, t) {
    if (e.nodeType === 1) {
        const n = e.style;
        let a = "";
        for (const l in t) n.setProperty(`--${l}`, t[l]), a += `--${l}: ${t[l]};`;
        n[Bp] = a
    }
}
const kP = /(^|;)\s*display\s*:/;

function CP(e, t, n) {
    const a = e.style,
        l = Io(n);
    let r = !1;
    if (n && !l) {
        if (t)
            if (Io(t))
                for (const o of t.split(";")) {
                    const i = o.slice(0, o.indexOf(":")).trim();
                    n[i] == null && Yi(a, i, "")
                } else
                    for (const o in t) n[o] == null && Yi(a, o, "");
        for (const o in n) o === "display" && (r = !0), Yi(a, o, n[o])
    } else if (l) {
        if (t !== n) {
            const o = a[Bp];
            o && (n += ";" + o), a.cssText = n, r = kP.test(n)
        }
    } else t && e.removeAttribute("style");
    fs in e && (e[fs] = r ? a.display : "", e[$p] && (a.display = "none"))
}
const ih = /\s*!important$/;

function Yi(e, t, n) {
    if (gn(n)) n.forEach(a => Yi(e, t, a));
    else if (n == null && (n = ""), t.startsWith("--")) e.setProperty(t, n);
    else {
        const a = xP(e, t);
        ih.test(n) ? e.setProperty(Ua(a), n.replace(ih, ""), "important") : e[a] = n
    }
}
const sh = ["Webkit", "Moz", "ms"],
    ic = {};

function xP(e, t) {
    const n = ic[t];
    if (n) return n;
    let a = Qt(t);
    if (a !== "filter" && a in e) return ic[t] = a;
    a = uP(a);
    for (let l = 0; l < sh.length; l++) {
        const r = sh[l] + a;
        if (r in e) return ic[t] = r
    }
    return t
}
const uh = "http://www.w3.org/1999/xlink";

function PP(e, t, n, a, l) {
    if (a && t.startsWith("xlink:")) n == null ? e.removeAttributeNS(uh, t.slice(6, t.length)) : e.setAttributeNS(uh, t, n);
    else {
        const r = fP(t);
        n == null || r && !Op(n) ? e.removeAttribute(t) : e.setAttribute(t, r ? "" : n)
    }
}

function EP(e, t, n, a, l, r, o) {
    if (t === "innerHTML" || t === "textContent") {
        a && o(a, l, r), e[t] = n ? ? "";
        return
    }
    const i = e.tagName;
    if (t === "value" && i !== "PROGRESS" && !i.includes("-")) {
        const u = i === "OPTION" ? e.getAttribute("value") || "" : e.value,
            c = n ? ? "";
        (u !== c || !("_value" in e)) && (e.value = c), n == null && e.removeAttribute(t), e._value = n;
        return
    }
    let s = !1;
    if (n === "" || n == null) {
        const u = typeof e[t];
        u === "boolean" ? n = Op(n) : n == null && u === "string" ? (n = "", s = !0) : u === "number" && (n = 0, s = !0)
    }
    try {
        e[t] = n
    } catch {}
    s && e.removeAttribute(t)
}

function ha(e, t, n, a) {
    e.addEventListener(t, n, a)
}

function IP(e, t, n, a) {
    e.removeEventListener(t, n, a)
}
const ch = Symbol("_vei");

function TP(e, t, n, a, l = null) {
    const r = e[ch] || (e[ch] = {}),
        o = r[t];
    if (a && o) o.value = a;
    else {
        const [i, s] = VP(t);
        if (a) {
            const u = r[t] = OP(a, l);
            ha(e, i, u, s)
        } else o && (IP(e, i, o, s), r[t] = void 0)
    }
}
const dh = /(?:Once|Passive|Capture)$/;

function VP(e) {
    let t;
    if (dh.test(e)) {
        t = {};
        let a;
        for (; a = e.match(dh);) e = e.slice(0, e.length - a[0].length), t[a[0].toLowerCase()] = !0
    }
    return [e[2] === ":" ? e.slice(3) : Ua(e.slice(2)), t]
}
let sc = 0;
const AP = Promise.resolve(),
    LP = () => sc || (AP.then(() => sc = 0), sc = Date.now());

function OP(e, t) {
    const n = a => {
        if (!a._vts) a._vts = Date.now();
        else if (a._vts <= n.attached) return;
        vn(RP(a, n.value), t, 5, [a])
    };
    return n.value = e, n.attached = LP(), n
}

function RP(e, t) {
    if (gn(t)) {
        const n = e.stopImmediatePropagation;
        return e.stopImmediatePropagation = () => {
            n.call(e), e._stopped = !0
        }, t.map(a => l => !l._stopped && a && a(l))
    } else return t
}
const fh = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123,
    DP = (e, t, n, a, l, r, o, i, s) => {
        const u = l === "svg";
        t === "class" ? _P(e, a, u) : t === "style" ? CP(e, n, a) : lP(t) ? rP(t) || TP(e, t, n, a, o) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : MP(e, t, a, u)) ? EP(e, t, a, r, o, i, s) : (t === "true-value" ? e._trueValue = a : t === "false-value" && (e._falseValue = a), PP(e, t, a, u))
    };

function MP(e, t, n, a) {
    if (a) return !!(t === "innerHTML" || t === "textContent" || t in e && fh(t) && Ap(n));
    if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA") return !1;
    if (t === "width" || t === "height") {
        const l = e.tagName;
        if (l === "IMG" || l === "VIDEO" || l === "CANVAS" || l === "SOURCE") return !1
    }
    return fh(t) && Io(n) ? !1 : t in e
} /*! #__NO_SIDE_EFFECTS__ */
function Fp(e, t) {
    const n = Ln(e);
    class a extends ou {
        constructor(r) {
            super(n, r, t)
        }
    }
    return a.def = n, a
} /*! #__NO_SIDE_EFFECTS__ */
const NP = e => Fp(e, Jp),
    $P = typeof HTMLElement < "u" ? HTMLElement : class {};
class ou extends $P {
    constructor(t, n = {}, a) {
        super(), this._def = t, this._props = n, this._instance = null, this._connected = !1, this._resolved = !1, this._numberProps = null, this._ob = null, this.shadowRoot && a ? a(this._createVNode(), this.shadowRoot) : (this.attachShadow({
            mode: "open"
        }), this._def.__asyncLoader || this._resolveProps(this._def))
    }
    connectedCallback() {
        this._connected = !0, this._instance || (this._resolved ? this._update() : this._resolveDef())
    }
    disconnectedCallback() {
        this._connected = !1, this._ob && (this._ob.disconnect(), this._ob = null), Re(() => {
            this._connected || (Vo(null, this.shadowRoot), this._instance = null)
        })
    }
    _resolveDef() {
        this._resolved = !0;
        for (let a = 0; a < this.attributes.length; a++) this._setAttr(this.attributes[a].name);
        this._ob = new MutationObserver(a => {
            for (const l of a) this._setAttr(l.attributeName)
        }), this._ob.observe(this, {
            attributes: !0
        });
        const t = (a, l = !1) => {
                const {
                    props: r,
                    styles: o
                } = a;
                let i;
                if (r && !gn(r))
                    for (const s in r) {
                        const u = r[s];
                        (u === Number || u && u.type === Number) && (s in this._props && (this._props[s] = qc(this._props[s])), (i || (i = Object.create(null)))[rc(s)] = !0)
                    }
                this._numberProps = i, l && this._resolveProps(a), this._applyStyles(o), this._update()
            },
            n = this._def.__asyncLoader;
        n ? n().then(a => t(a, !0)) : t(this._def)
    }
    _resolveProps(t) {
        const {
            props: n
        } = t, a = gn(n) ? n : Object.keys(n || {});
        for (const l of Object.keys(this)) l[0] !== "_" && a.includes(l) && this._setProp(l, this[l], !0, !1);
        for (const l of a.map(rc)) Object.defineProperty(this, l, {
            get() {
                return this._getProp(l)
            },
            set(r) {
                this._setProp(l, r)
            }
        })
    }
    _setAttr(t) {
        let n = this.getAttribute(t);
        const a = rc(t);
        this._numberProps && this._numberProps[a] && (n = qc(n)), this._setProp(a, n, !1)
    }
    _getProp(t) {
        return this._props[t]
    }
    _setProp(t, n, a = !0, l = !0) {
        n !== this._props[t] && (this._props[t] = n, l && this._instance && this._update(), a && (n === !0 ? this.setAttribute(Ua(t), "") : typeof n == "string" || typeof n == "number" ? this.setAttribute(Ua(t), n + "") : n || this.removeAttribute(Ua(t))))
    }
    _update() {
        Vo(this._createVNode(), this.shadowRoot)
    }
    _createVNode() {
        const t = m(this._def, ri({}, this._props));
        return this._instance || (t.ce = n => {
            this._instance = n, n.isCE = !0;
            const a = (r, o) => {
                this.dispatchEvent(new CustomEvent(r, {
                    detail: o
                }))
            };
            n.emit = (r, ...o) => {
                a(r, o), Ua(r) !== r && a(Ua(r), o)
            };
            let l = this;
            for (; l = l && (l.parentNode || l.host);)
                if (l instanceof ou) {
                    n.parent = l._instance, n.provides = l._instance.provides;
                    break
                }
        }), t
    }
    _applyStyles(t) {
        t && t.forEach(n => {
            const a = document.createElement("style");
            a.textContent = n, this.shadowRoot.appendChild(a)
        })
    }
}

function BP(e = "$style") {
    {
        const t = nn();
        if (!t) return lc;
        const n = t.type.__cssModules;
        if (!n) return lc;
        const a = n[e];
        return a || lc
    }
}
const Hp = new WeakMap,
    jp = new WeakMap,
    vs = Symbol("_moveCb"),
    vh = Symbol("_enterCb"),
    Up = {
        name: "TransitionGroup",
        props: ri({}, yP, {
            tag: String,
            moveClass: String
        }),
        setup(e, {
            slots: t
        }) {
            const n = nn(),
                a = Wf();
            let l, r;
            return ai(() => {
                if (!l.length) return;
                const o = e.moveClass || `${e.name||"v"}-move`;
                if (!WP(l[0].el, n.vnode.el, o)) return;
                l.forEach(HP), l.forEach(jP);
                const i = l.filter(UP);
                Np(), i.forEach(s => {
                    const u = s.el,
                        c = u.style;
                    va(u, o), c.transform = c.webkitTransform = c.transitionDuration = "";
                    const d = u[vs] = f => {
                        f && f.target !== u || (!f || /transform$/.test(f.propertyName)) && (u.removeEventListener("transitionend", d), u[vs] = null, Da(u, o))
                    };
                    u.addEventListener("transitionend", d)
                })
            }), () => {
                const o = xe(e),
                    i = Dp(o);
                let s = o.tag || ye;
                l = r, r = t.default ? Zs(t.default()) : [];
                for (let u = 0; u < r.length; u++) {
                    const c = r[u];
                    c.key != null && Il(c, wr(c, i, a, n))
                }
                if (l)
                    for (let u = 0; u < l.length; u++) {
                        const c = l[u];
                        Il(c, wr(c, i, a, n)), Hp.set(c, c.el.getBoundingClientRect())
                    }
                return m(s, null, r)
            }
        }
    },
    FP = e => delete e.mode;
Up.props;
const iu = Up;

function HP(e) {
    const t = e.el;
    t[vs] && t[vs](), t[vh] && t[vh]()
}

function jP(e) {
    jp.set(e, e.el.getBoundingClientRect())
}

function UP(e) {
    const t = Hp.get(e),
        n = jp.get(e),
        a = t.left - n.left,
        l = t.top - n.top;
    if (a || l) {
        const r = e.el.style;
        return r.transform = r.webkitTransform = `translate(${a}px,${l}px)`, r.transitionDuration = "0s", e
    }
}

function WP(e, t, n) {
    const a = e.cloneNode(),
        l = e[kr];
    l && l.forEach(i => {
        i.split(/\s+/).forEach(s => s && a.classList.remove(s))
    }), n.split(/\s+/).forEach(i => i && a.classList.add(i)), a.style.display = "none";
    const r = t.nodeType === 1 ? t : t.parentNode;
    r.appendChild(a);
    const {
        hasTransform: o
    } = Mp(a);
    return r.removeChild(a), o
}
const Xa = e => {
    const t = e.props["onUpdate:modelValue"] || !1;
    return gn(t) ? n => cP(t, n) : t
};

function zP(e) {
    e.target.composing = !0
}

function mh(e) {
    const t = e.target;
    t.composing && (t.composing = !1, t.dispatchEvent(new Event("input")))
}
const In = Symbol("_assign"),
    To = {
        created(e, {
            modifiers: {
                lazy: t,
                trim: n,
                number: a
            }
        }, l) {
            e[In] = Xa(l);
            const r = a || l.props && l.props.type === "number";
            ha(e, t ? "change" : "input", o => {
                if (o.target.composing) return;
                let i = e.value;
                n && (i = i.trim()), r && (i = ds(i)), e[In](i)
            }), n && ha(e, "change", () => {
                e.value = e.value.trim()
            }), t || (ha(e, "compositionstart", zP), ha(e, "compositionend", mh), ha(e, "change", mh))
        },
        mounted(e, {
            value: t
        }) {
            e.value = t ? ? ""
        },
        beforeUpdate(e, {
            value: t,
            modifiers: {
                lazy: n,
                trim: a,
                number: l
            }
        }, r) {
            if (e[In] = Xa(r), e.composing) return;
            const o = l || e.type === "number" ? ds(e.value) : e.value,
                i = t ? ? "";
            o !== i && (document.activeElement === e && e.type !== "range" && (n || a && e.value.trim() === i) || (e.value = i))
        }
    },
    av = {
        deep: !0,
        created(e, t, n) {
            e[In] = Xa(n), ha(e, "change", () => {
                const a = e._modelValue,
                    l = Cr(e),
                    r = e.checked,
                    o = e[In];
                if (gn(a)) {
                    const i = ru(a, l),
                        s = i !== -1;
                    if (r && !s) o(a.concat(l));
                    else if (!r && s) {
                        const u = [...a];
                        u.splice(i, 1), o(u)
                    }
                } else if (oi(a)) {
                    const i = new Set(a);
                    r ? i.add(l) : i.delete(l), o(i)
                } else o(zp(e, r))
            })
        },
        mounted: hh,
        beforeUpdate(e, t, n) {
            e[In] = Xa(n), hh(e, t, n)
        }
    };

function hh(e, {
    value: t,
    oldValue: n
}, a) {
    e._modelValue = t, gn(t) ? e.checked = ru(t, a.props.value) > -1 : oi(t) ? e.checked = t.has(a.props.value) : t !== n && (e.checked = qa(t, zp(e, !0)))
}
const lv = {
        created(e, {
            value: t
        }, n) {
            e.checked = qa(t, n.props.value), e[In] = Xa(n), ha(e, "change", () => {
                e[In](Cr(e))
            })
        },
        beforeUpdate(e, {
            value: t,
            oldValue: n
        }, a) {
            e[In] = Xa(a), t !== n && (e.checked = qa(t, a.props.value))
        }
    },
    Wp = {
        deep: !0,
        created(e, {
            value: t,
            modifiers: {
                number: n
            }
        }, a) {
            const l = oi(t);
            ha(e, "change", () => {
                const r = Array.prototype.filter.call(e.options, o => o.selected).map(o => n ? ds(Cr(o)) : Cr(o));
                e[In](e.multiple ? l ? new Set(r) : r : r[0]), e._assigning = !0, Re(() => {
                    e._assigning = !1
                })
            }), e[In] = Xa(a)
        },
        mounted(e, {
            value: t,
            modifiers: {
                number: n
            }
        }) {
            gh(e, t, n)
        },
        beforeUpdate(e, t, n) {
            e[In] = Xa(n)
        },
        updated(e, {
            value: t,
            modifiers: {
                number: n
            }
        }) {
            e._assigning || gh(e, t, n)
        }
    };

function gh(e, t, n) {
    const a = e.multiple,
        l = gn(t);
    if (!(a && !l && !oi(t))) {
        for (let r = 0, o = e.options.length; r < o; r++) {
            const i = e.options[r],
                s = Cr(i);
            if (a)
                if (l) {
                    const u = typeof s;
                    u === "string" || u === "number" ? i.selected = t.includes(n ? ds(s) : s) : i.selected = ru(t, s) > -1
                } else i.selected = t.has(s);
            else if (qa(Cr(i), t)) {
                e.selectedIndex !== r && (e.selectedIndex = r);
                return
            }
        }!a && e.selectedIndex !== -1 && (e.selectedIndex = -1)
    }
}

function Cr(e) {
    return "_value" in e ? e._value : e.value
}

function zp(e, t) {
    const n = t ? "_trueValue" : "_falseValue";
    return n in e ? e[n] : t
}
const Kp = {
    created(e, t, n) {
        Ai(e, t, n, null, "created")
    },
    mounted(e, t, n) {
        Ai(e, t, n, null, "mounted")
    },
    beforeUpdate(e, t, n, a) {
        Ai(e, t, n, a, "beforeUpdate")
    },
    updated(e, t, n, a) {
        Ai(e, t, n, a, "updated")
    }
};

function Gp(e, t) {
    switch (e) {
        case "SELECT":
            return Wp;
        case "TEXTAREA":
            return To;
        default:
            switch (t) {
                case "checkbox":
                    return av;
                case "radio":
                    return lv;
                default:
                    return To
            }
    }
}

function Ai(e, t, n, a, l) {
    const o = Gp(e.tagName, n.props && n.props.type)[l];
    o && o(e, t, n, a)
}

function KP() {
    To.getSSRProps = ({
        value: e
    }) => ({
        value: e
    }), lv.getSSRProps = ({
        value: e
    }, t) => {
        if (t.props && qa(t.props.value, e)) return {
            checked: !0
        }
    }, av.getSSRProps = ({
        value: e
    }, t) => {
        if (gn(e)) {
            if (t.props && ru(e, t.props.value) > -1) return {
                checked: !0
            }
        } else if (oi(e)) {
            if (t.props && e.has(t.props.value)) return {
                checked: !0
            }
        } else if (e) return {
            checked: !0
        }
    }, Kp.getSSRProps = (e, t) => {
        if (typeof t.type != "string") return;
        const n = Gp(t.type.toUpperCase(), t.props && t.props.type);
        if (n.getSSRProps) return n.getSSRProps(e, t)
    }
}
const GP = ["ctrl", "shift", "alt", "meta"],
    YP = {
        stop: e => e.stopPropagation(),
        prevent: e => e.preventDefault(),
        self: e => e.target !== e.currentTarget,
        ctrl: e => !e.ctrlKey,
        shift: e => !e.shiftKey,
        alt: e => !e.altKey,
        meta: e => !e.metaKey,
        left: e => "button" in e && e.button !== 0,
        middle: e => "button" in e && e.button !== 1,
        right: e => "button" in e && e.button !== 2,
        exact: (e, t) => GP.some(n => e[`${n}Key`] && !t.includes(n))
    },
    ms = (e, t) => {
        const n = e._withMods || (e._withMods = {}),
            a = t.join(".");
        return n[a] || (n[a] = (l, ...r) => {
            for (let o = 0; o < t.length; o++) {
                const i = YP[t[o]];
                if (i && i(l, t)) return
            }
            return e(l, ...r)
        })
    },
    qP = {
        esc: "escape",
        space: " ",
        up: "arrow-up",
        left: "arrow-left",
        right: "arrow-right",
        down: "arrow-down",
        delete: "backspace"
    },
    XP = (e, t) => {
        const n = e._withKeys || (e._withKeys = {}),
            a = t.join(".");
        return n[a] || (n[a] = l => {
            if (!("key" in l)) return;
            const r = Ua(l.key);
            if (t.some(o => o === r || qP[o] === r)) return e(l)
        })
    },
    Yp = ri({
        patchProp: DP
    }, gP);
let mo, yh = !1;

function qp() {
    return mo || (mo = mp(Yp))
}

function Xp() {
    return mo = yh ? mo : hp(Yp), yh = !0, mo
}
const Vo = (...e) => {
        qp().render(...e)
    },
    Jp = (...e) => {
        Xp().hydrate(...e)
    },
    Zp = (...e) => {
        const t = qp().createApp(...e),
            {
                mount: n
            } = t;
        return t.mount = a => {
            const l = t_(a);
            if (!l) return;
            const r = t._component;
            !Ap(r) && !r.render && !r.template && (r.template = l.innerHTML), l.innerHTML = "";
            const o = n(l, !1, e_(l));
            return l instanceof Element && (l.removeAttribute("v-cloak"), l.setAttribute("data-v-app", "")), o
        }, t
    },
    Qp = (...e) => {
        const t = Xp().createApp(...e),
            {
                mount: n
            } = t;
        return t.mount = a => {
            const l = t_(a);
            if (l) return n(l, !0, e_(l))
        }, t
    };

function e_(e) {
    if (e instanceof SVGElement) return "svg";
    if (typeof MathMLElement == "function" && e instanceof MathMLElement) return "mathml"
}

function t_(e) {
    return Io(e) ? document.querySelector(e) : e
}
let bh = !1;
const JP = () => {
    bh || (bh = !0, KP(), SP())
};
/**
 * vue v3.4.21
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
const ZP = () => {},
    QP = Object.freeze(Object.defineProperty({
        __proto__: null,
        BaseTransition: Zb,
        BaseTransitionPropsValidators: zf,
        Comment: Nt,
        DeprecationTypes: nP,
        EffectScope: Pf,
        ErrorCodes: P1,
        ErrorTypeStrings: qx,
        Fragment: ye,
        KeepAlive: ep,
        ReactiveEffect: Sr,
        Static: wl,
        Suspense: jf,
        Teleport: pp,
        Text: Sa,
        TrackOpTypes: c1,
        Transition: Tn,
        TransitionGroup: iu,
        TriggerOpTypes: d1,
        VueElement: ou,
        assertNumber: x1,
        callWithAsyncErrorHandling: vn,
        callWithErrorHandling: _a,
        camelize: Qt,
        capitalize: na,
        cloneVNode: $n,
        compatUtils: tP,
        compile: ZP,
        computed: C,
        createApp: Zp,
        createBlock: qn,
        createCommentVNode: Nx,
        createElementBlock: kp,
        createElementVNode: Zf,
        createHydrationRenderer: hp,
        createPropsRestProxy: vx,
        createRenderer: mp,
        createSSRApp: Qp,
        createSlots: Z1,
        createStaticVNode: Mx,
        createTextVNode: hn,
        createVNode: m,
        customRef: Rf,
        defineAsyncComponent: mn,
        defineComponent: Ln,
        defineCustomElement: Fp,
        defineEmits: ax,
        defineExpose: lx,
        defineModel: ix,
        defineOptions: rx,
        defineProps: nx,
        defineSSRCustomElement: NP,
        defineSlots: ox,
        devtools: Xx,
        effect: RC,
        effectScope: xa,
        getCurrentInstance: nn,
        getCurrentScope: $r,
        getTransitionRawChildren: Zs,
        guardReactiveProps: Qf,
        h: ht,
        handleError: Hl,
        hasInjectionContext: nu,
        hydrate: Jp,
        initCustomFormatter: Kx,
        initDirectivesForSSR: JP,
        inject: Te,
        isMemoSame: Vp,
        isProxy: Vf,
        isReactive: pa,
        isReadonly: Ya,
        isRef: Ge,
        isRuntimeOnly: jx,
        isShallow: _o,
        isVNode: wa,
        markRaw: Fr,
        mergeDefaults: dx,
        mergeModels: fx,
        mergeProps: te,
        nextTick: Re,
        normalizeClass: Hr,
        normalizeProps: Db,
        normalizeStyle: ei,
        onActivated: Kf,
        onBeforeMount: tu,
        onBeforeUnmount: Ct,
        onBeforeUpdate: Gf,
        onDeactivated: Qs,
        onErrorCaptured: Yf,
        onMounted: it,
        onRenderTracked: lp,
        onRenderTriggered: ap,
        onScopeDispose: kt,
        onServerPrefetch: np,
        onUnmounted: jr,
        onUpdated: ai,
        openBlock: Cn,
        popScopeId: R1,
        provide: He,
        proxyRefs: Of,
        pushScopeId: O1,
        queuePostFlushCb: rs,
        reactive: mt,
        readonly: Br,
        ref: Q,
        registerRuntimeCompiler: Hx,
        render: Vo,
        renderList: J1,
        renderSlot: Q1,
        resolveComponent: Ub,
        resolveDirective: tn,
        resolveDynamicComponent: Ff,
        resolveFilter: eP,
        resolveTransitionHooks: wr,
        setBlockTracking: jc,
        setDevtoolsHook: Jx,
        setTransitionHooks: Il,
        shallowReactive: Jn,
        shallowReadonly: t1,
        shallowRef: fe,
        ssrContextKey: Gb,
        ssrUtils: Qx,
        stop: DC,
        toDisplayString: Mb,
        toHandlerKey: so,
        toHandlers: ex,
        toRaw: xe,
        toRef: Y,
        toRefs: ta,
        toValue: r1,
        transformVNodeArgs: Rx,
        triggerRef: l1,
        unref: Ie,
        useAttrs: cx,
        useCssModule: BP,
        useCssVars: wP,
        useModel: zx,
        useSSRContext: Yb,
        useSlots: ux,
        useTransitionState: Wf,
        vModelCheckbox: av,
        vModelDynamic: Kp,
        vModelRadio: lv,
        vModelSelect: Wp,
        vModelText: To,
        vShow: bn,
        version: tv,
        warn: Yx,
        watch: de,
        watchEffect: st,
        watchPostEffect: qb,
        watchSyncEffect: Xb,
        withAsyncContext: mx,
        withCtx: Js,
        withDefaults: sx,
        withDirectives: at,
        withKeys: XP,
        withMemo: Gx,
        withModifiers: ms,
        withScopeId: D1
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    eE = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,
    tE = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
    nE = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;

function aE(e, t) {
    if (e === "__proto__" || e === "constructor" && t && typeof t == "object" && "prototype" in t) {
        lE(e);
        return
    }
    return t
}

function lE(e) {
    console.warn(`[destr] Dropping "${e}" key to prevent prototype pollution.`)
}

function Ao(e, t = {}) {
    if (typeof e != "string") return e;
    const n = e.trim();
    if (e[0] === '"' && e.endsWith('"') && !e.includes("\\")) return n.slice(1, -1);
    if (n.length <= 9) {
        const a = n.toLowerCase();
        if (a === "true") return !0;
        if (a === "false") return !1;
        if (a === "undefined") return;
        if (a === "null") return null;
        if (a === "nan") return Number.NaN;
        if (a === "infinity") return Number.POSITIVE_INFINITY;
        if (a === "-infinity") return Number.NEGATIVE_INFINITY
    }
    if (!nE.test(e)) {
        if (t.strict) throw new SyntaxError("[destr] Invalid JSON");
        return e
    }
    try {
        if (eE.test(e) || tE.test(e)) {
            if (t.strict) throw new Error("[destr] Possible prototype pollution");
            return JSON.parse(e, aE)
        }
        return JSON.parse(e)
    } catch (a) {
        if (t.strict) throw a;
        return e
    }
}
const rE = /#/g,
    oE = /&/g,
    iE = /\//g,
    sE = /=/g,
    rv = /\+/g,
    uE = /%5e/gi,
    cE = /%60/gi,
    dE = /%7c/gi,
    fE = /%20/gi;

function vE(e) {
    return encodeURI("" + e).replace(dE, "|")
}

function Zc(e) {
    return vE(typeof e == "string" ? e : JSON.stringify(e)).replace(rv, "%2B").replace(fE, "+").replace(rE, "%23").replace(oE, "%26").replace(cE, "`").replace(uE, "^").replace(iE, "%2F")
}

function uc(e) {
    return Zc(e).replace(sE, "%3D")
}

function hs(e = "") {
    try {
        return decodeURIComponent("" + e)
    } catch {
        return "" + e
    }
}

function mE(e) {
    return hs(e.replace(rv, " "))
}

function hE(e) {
    return hs(e.replace(rv, " "))
}

function n_(e = "") {
    const t = {};
    e[0] === "?" && (e = e.slice(1));
    for (const n of e.split("&")) {
        const a = n.match(/([^=]+)=?(.*)/) || [];
        if (a.length < 2) continue;
        const l = mE(a[1]);
        if (l === "__proto__" || l === "constructor") continue;
        const r = hE(a[2] || "");
        t[l] === void 0 ? t[l] = r : Array.isArray(t[l]) ? t[l].push(r) : t[l] = [t[l], r]
    }
    return t
}

function gE(e, t) {
    return (typeof t == "number" || typeof t == "boolean") && (t = String(t)), t ? Array.isArray(t) ? t.map(n => `${uc(e)}=${Zc(n)}`).join("&") : `${uc(e)}=${Zc(t)}` : uc(e)
}

function yE(e) {
    return Object.keys(e).filter(t => e[t] !== void 0).map(t => gE(t, e[t])).filter(Boolean).join("&")
}
const bE = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/,
    pE = /^[\s\w\0+.-]{2,}:([/\\]{2})?/,
    _E = /^([/\\]\s*){2,}[^/\\]/,
    SE = /^[\s\0]*(blob|data|javascript|vbscript):$/i,
    wE = /\/$|\/\?|\/#/,
    kE = /^\.?\//;

function aa(e, t = {}) {
    return typeof t == "boolean" && (t = {
        acceptRelative: t
    }), t.strict ? bE.test(e) : pE.test(e) || (t.acceptRelative ? _E.test(e) : !1)
}

function CE(e) {
    return !!e && SE.test(e)
}

function Qc(e = "", t) {
    return t ? wE.test(e) : e.endsWith("/")
}

function su(e = "", t) {
    if (!t) return (Qc(e) ? e.slice(0, -1) : e) || "/";
    if (!Qc(e, !0)) return e || "/";
    let n = e,
        a = "";
    const l = e.indexOf("#");
    l >= 0 && (n = e.slice(0, l), a = e.slice(l));
    const [r, ...o] = n.split("?");
    return ((r.endsWith("/") ? r.slice(0, -1) : r) || "/") + (o.length > 0 ? `?${o.join("?")}` : "") + a
}

function gs(e = "", t) {
    if (!t) return e.endsWith("/") ? e : e + "/";
    if (Qc(e, !0)) return e || "/";
    let n = e,
        a = "";
    const l = e.indexOf("#");
    if (l >= 0 && (n = e.slice(0, l), a = e.slice(l), !n)) return a;
    const [r, ...o] = n.split("?");
    return r + "/" + (o.length > 0 ? `?${o.join("?")}` : "") + a
}

function xE(e = "") {
    return e.startsWith("/")
}

function ph(e = "") {
    return xE(e) ? e : "/" + e
}

function PE(e, t) {
    if (l_(t) || aa(e)) return e;
    const n = su(t);
    return e.startsWith(n) ? e : Ur(n, e)
}

function _h(e, t) {
    if (l_(t)) return e;
    const n = su(t);
    if (!e.startsWith(n)) return e;
    const a = e.slice(n.length);
    return a[0] === "/" ? a : "/" + a
}

function a_(e, t) {
    const n = IE(e),
        a = { ...n_(n.search),
            ...t
        };
    return n.search = yE(a), TE(n)
}

function l_(e) {
    return !e || e === "/"
}

function EE(e) {
    return e && e !== "/"
}

function Ur(e, ...t) {
    let n = e || "";
    for (const a of t.filter(l => EE(l)))
        if (n) {
            const l = a.replace(kE, "");
            n = gs(n) + l
        } else n = a;
    return n
}

function r_(...e) {
    var o, i, s, u;
    const t = /\/(?!\/)/,
        n = e.filter(Boolean),
        a = [];
    let l = 0;
    for (const c of n)
        if (!(!c || c === "/")) {
            for (const [d, f] of c.split(t).entries())
                if (!(!f || f === ".")) {
                    if (f === "..") {
                        if (a.length === 1 && aa(a[0])) continue;
                        a.pop(), l--;
                        continue
                    }
                    if (d === 1 && ((o = a[a.length - 1]) != null && o.endsWith(":/"))) {
                        a[a.length - 1] += "/" + f;
                        continue
                    }
                    a.push(f), l++
                }
        }
    let r = a.join("/");
    return l >= 0 ? (i = n[0]) != null && i.startsWith("/") && !r.startsWith("/") ? r = "/" + r : (s = n[0]) != null && s.startsWith("./") && !r.startsWith("./") && (r = "./" + r) : r = "../".repeat(-1 * l) + r, (u = n[n.length - 1]) != null && u.endsWith("/") && !r.endsWith("/") && (r += "/"), r
}

function ed(e, t, n = {}) {
    return n.trailingSlash || (e = gs(e), t = gs(t)), n.leadingSlash || (e = ph(e), t = ph(t)), n.encoding || (e = hs(e), t = hs(t)), e === t
}
const o_ = Symbol.for("ufo:protocolRelative");

function IE(e = "", t) {
    const n = e.match(/^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i);
    if (n) {
        const [, d, f = ""] = n;
        return {
            protocol: d.toLowerCase(),
            pathname: f,
            href: d + f,
            auth: "",
            host: "",
            search: "",
            hash: ""
        }
    }
    if (!aa(e, {
            acceptRelative: !0
        })) return td(e);
    const [, a = "", l, r = ""] = e.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || [];
    let [, o = "", i = ""] = r.match(/([^#/?]*)(.*)?/) || [];
    a === "file:" && (i = i.replace(/\/(?=[A-Za-z]:)/, ""));
    const {
        pathname: s,
        search: u,
        hash: c
    } = td(i);
    return {
        protocol: a.toLowerCase(),
        auth: l ? l.slice(0, Math.max(0, l.length - 1)) : "",
        host: o,
        pathname: s,
        search: u,
        hash: c,
        [o_]: !a
    }
}

function td(e = "") {
    const [t = "", n = "", a = ""] = (e.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
    return {
        pathname: t,
        search: n,
        hash: a
    }
}

function TE(e) {
    const t = e.pathname || "",
        n = e.search ? (e.search.startsWith("?") ? "" : "?") + e.search : "",
        a = e.hash || "",
        l = e.auth ? e.auth + "@" : "",
        r = e.host || "";
    return (e.protocol || e[o_] ? (e.protocol || "") + "//" : "") + l + r + t + n + a
}
class VE extends Error {
    constructor(t, n) {
        super(t, n), this.name = "FetchError", n != null && n.cause && !this.cause && (this.cause = n.cause)
    }
}

function AE(e) {
    var s, u, c, d, f;
    const t = ((s = e.error) == null ? void 0 : s.message) || ((u = e.error) == null ? void 0 : u.toString()) || "",
        n = ((c = e.request) == null ? void 0 : c.method) || ((d = e.options) == null ? void 0 : d.method) || "GET",
        a = ((f = e.request) == null ? void 0 : f.url) || String(e.request) || "/",
        l = `[${n}] ${JSON.stringify(a)}`,
        r = e.response ? `${e.response.status} ${e.response.statusText}` : "<no response>",
        o = `${l}: ${r}${t?` ${t}`:""}`,
        i = new VE(o, e.error ? {
            cause: e.error
        } : void 0);
    for (const v of ["request", "options", "response"]) Object.defineProperty(i, v, {
        get() {
            return e[v]
        }
    });
    for (const [v, g] of [
            ["data", "_data"],
            ["status", "status"],
            ["statusCode", "status"],
            ["statusText", "statusText"],
            ["statusMessage", "statusText"]
        ]) Object.defineProperty(i, v, {
        get() {
            return e.response && e.response[g]
        }
    });
    return i
}
const LE = new Set(Object.freeze(["PATCH", "POST", "PUT", "DELETE"]));

function Sh(e = "GET") {
    return LE.has(e.toUpperCase())
}

function OE(e) {
    if (e === void 0) return !1;
    const t = typeof e;
    return t === "string" || t === "number" || t === "boolean" || t === null ? !0 : t !== "object" ? !1 : Array.isArray(e) ? !0 : e.buffer ? !1 : e.constructor && e.constructor.name === "Object" || typeof e.toJSON == "function"
}
const RE = new Set(["image/svg", "application/xml", "application/xhtml", "application/html"]),
    DE = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;

function ME(e = "") {
    if (!e) return "json";
    const t = e.split(";").shift() || "";
    return DE.test(t) ? "json" : RE.has(t) || t.startsWith("text/") ? "text" : "blob"
}

function NE(e, t, n, a) {
    const l = $E((t == null ? void 0 : t.headers) ? ? (e == null ? void 0 : e.headers), n == null ? void 0 : n.headers, a);
    let r;
    return (n != null && n.query || n != null && n.params || t != null && t.params || t != null && t.query) && (r = { ...n == null ? void 0 : n.params,
        ...n == null ? void 0 : n.query,
        ...t == null ? void 0 : t.params,
        ...t == null ? void 0 : t.query
    }), { ...n,
        ...t,
        query: r,
        params: r,
        headers: l
    }
}

function $E(e, t, n) {
    if (!t) return new n(e);
    const a = new n(t);
    if (e)
        for (const [l, r] of Symbol.iterator in e || Array.isArray(e) ? e : new n(e)) a.set(l, r);
    return a
}
async function Li(e, t) {
    if (t)
        if (Array.isArray(t))
            for (const n of t) await n(e);
        else await t(e)
}
const BE = new Set([408, 409, 425, 429, 500, 502, 503, 504]),
    FE = new Set([101, 204, 205, 304]);

function i_(e = {}) {
    const {
        fetch: t = globalThis.fetch,
        Headers: n = globalThis.Headers,
        AbortController: a = globalThis.AbortController
    } = e;
    async function l(i) {
        const s = i.error && i.error.name === "AbortError" && !i.options.timeout || !1;
        if (i.options.retry !== !1 && !s) {
            let c;
            typeof i.options.retry == "number" ? c = i.options.retry : c = Sh(i.options.method) ? 0 : 1;
            const d = i.response && i.response.status || 500;
            if (c > 0 && (Array.isArray(i.options.retryStatusCodes) ? i.options.retryStatusCodes.includes(d) : BE.has(d))) {
                const f = typeof i.options.retryDelay == "function" ? i.options.retryDelay(i) : i.options.retryDelay || 0;
                return f > 0 && await new Promise(v => setTimeout(v, f)), r(i.request, { ...i.options,
                    retry: c - 1
                })
            }
        }
        const u = AE(i);
        throw Error.captureStackTrace && Error.captureStackTrace(u, r), u
    }
    const r = async function(s, u = {}) {
            const c = {
                request: s,
                options: NE(s, u, e.defaults, n),
                response: void 0,
                error: void 0
            };
            c.options.method && (c.options.method = c.options.method.toUpperCase()), c.options.onRequest && await Li(c, c.options.onRequest), typeof c.request == "string" && (c.options.baseURL && (c.request = PE(c.request, c.options.baseURL)), c.options.query && (c.request = a_(c.request, c.options.query), delete c.options.query), "query" in c.options && delete c.options.query, "params" in c.options && delete c.options.params), c.options.body && Sh(c.options.method) && (OE(c.options.body) ? (c.options.body = typeof c.options.body == "string" ? c.options.body : JSON.stringify(c.options.body), c.options.headers = new n(c.options.headers || {}), c.options.headers.has("content-type") || c.options.headers.set("content-type", "application/json"), c.options.headers.has("accept") || c.options.headers.set("accept", "application/json")) : ("pipeTo" in c.options.body && typeof c.options.body.pipeTo == "function" || typeof c.options.body.pipe == "function") && ("duplex" in c.options || (c.options.duplex = "half")));
            let d;
            if (!c.options.signal && c.options.timeout) {
                const v = new a;
                d = setTimeout(() => {
                    const g = new Error("[TimeoutError]: The operation was aborted due to timeout");
                    g.name = "TimeoutError", g.code = 23, v.abort(g)
                }, c.options.timeout), c.options.signal = v.signal
            }
            try {
                c.response = await t(c.request, c.options)
            } catch (v) {
                return c.error = v, c.options.onRequestError && await Li(c, c.options.onRequestError), await l(c)
            } finally {
                d && clearTimeout(d)
            }
            if ((c.response.body || c.response._bodyInit) && !FE.has(c.response.status) && c.options.method !== "HEAD") {
                const v = (c.options.parseResponse ? "json" : c.options.responseType) || ME(c.response.headers.get("content-type") || "");
                switch (v) {
                    case "json":
                        {
                            const g = await c.response.text(),
                                h = c.options.parseResponse || Ao;c.response._data = h(g);
                            break
                        }
                    case "stream":
                        {
                            c.response._data = c.response.body || c.response._bodyInit;
                            break
                        }
                    default:
                        c.response._data = await c.response[v]()
                }
            }
            return c.options.onResponse && await Li(c, c.options.onResponse), !c.options.ignoreResponseError && c.response.status >= 400 && c.response.status < 600 ? (c.options.onResponseError && await Li(c, c.options.onResponseError), await l(c)) : c.response
        },
        o = async function(s, u) {
            return (await r(s, u))._data
        };
    return o.raw = r, o.native = (...i) => t(...i), o.create = (i = {}, s = {}) => i_({ ...e,
        ...s,
        defaults: { ...e.defaults,
            ...s.defaults,
            ...i
        }
    }), o
}
const ys = function() {
        if (typeof globalThis < "u") return globalThis;
        if (typeof self < "u") return self;
        if (typeof window < "u") return window;
        if (typeof global < "u") return global;
        throw new Error("unable to locate global object")
    }(),
    HE = ys.fetch ? (...e) => ys.fetch(...e) : () => Promise.reject(new Error("[ofetch] global.fetch is not supported!")),
    jE = ys.Headers,
    UE = ys.AbortController,
    WE = i_({
        fetch: HE,
        Headers: jE,
        AbortController: UE
    }),
    zE = WE,
    KE = () => {
        var e;
        return ((e = window == null ? void 0 : window.__NUXT__) == null ? void 0 : e.config) || {}
    },
    bs = KE().app,
    GE = () => bs.baseURL,
    YE = () => bs.buildAssetsDir,
    ov = (...e) => r_(s_(), YE(), ...e),
    s_ = (...e) => {
        const t = bs.cdnURL || bs.baseURL;
        return e.length ? r_(t, ...e) : t
    };
globalThis.__buildAssetsURL = ov, globalThis.__publicAssetsURL = s_;
globalThis.$fetch || (globalThis.$fetch = zE.create({
    baseURL: GE()
}));

function nd(e, t = {}, n) {
    for (const a in e) {
        const l = e[a],
            r = n ? `${n}:${a}` : a;
        typeof l == "object" && l !== null ? nd(l, t, r) : typeof l == "function" && (t[r] = l)
    }
    return t
}
const qE = {
        run: e => e()
    },
    XE = () => qE,
    u_ = typeof console.createTask < "u" ? console.createTask : XE;

function JE(e, t) {
    const n = t.shift(),
        a = u_(n);
    return e.reduce((l, r) => l.then(() => a.run(() => r(...t))), Promise.resolve())
}

function ZE(e, t) {
    const n = t.shift(),
        a = u_(n);
    return Promise.all(e.map(l => a.run(() => l(...t))))
}

function cc(e, t) {
    for (const n of [...e]) n(t)
}
class QE {
    constructor() {
        this._hooks = {}, this._before = void 0, this._after = void 0, this._deprecatedMessages = void 0, this._deprecatedHooks = {}, this.hook = this.hook.bind(this), this.callHook = this.callHook.bind(this), this.callHookWith = this.callHookWith.bind(this)
    }
    hook(t, n, a = {}) {
        if (!t || typeof n != "function") return () => {};
        const l = t;
        let r;
        for (; this._deprecatedHooks[t];) r = this._deprecatedHooks[t], t = r.to;
        if (r && !a.allowDeprecated) {
            let o = r.message;
            o || (o = `${l} hook has been deprecated` + (r.to ? `, please use ${r.to}` : "")), this._deprecatedMessages || (this._deprecatedMessages = new Set), this._deprecatedMessages.has(o) || (console.warn(o), this._deprecatedMessages.add(o))
        }
        if (!n.name) try {
            Object.defineProperty(n, "name", {
                get: () => "_" + t.replace(/\W+/g, "_") + "_hook_cb",
                configurable: !0
            })
        } catch {}
        return this._hooks[t] = this._hooks[t] || [], this._hooks[t].push(n), () => {
            n && (this.removeHook(t, n), n = void 0)
        }
    }
    hookOnce(t, n) {
        let a, l = (...r) => (typeof a == "function" && a(), a = void 0, l = void 0, n(...r));
        return a = this.hook(t, l), a
    }
    removeHook(t, n) {
        if (this._hooks[t]) {
            const a = this._hooks[t].indexOf(n);
            a !== -1 && this._hooks[t].splice(a, 1), this._hooks[t].length === 0 && delete this._hooks[t]
        }
    }
    deprecateHook(t, n) {
        this._deprecatedHooks[t] = typeof n == "string" ? {
            to: n
        } : n;
        const a = this._hooks[t] || [];
        delete this._hooks[t];
        for (const l of a) this.hook(t, l)
    }
    deprecateHooks(t) {
        Object.assign(this._deprecatedHooks, t);
        for (const n in t) this.deprecateHook(n, t[n])
    }
    addHooks(t) {
        const n = nd(t),
            a = Object.keys(n).map(l => this.hook(l, n[l]));
        return () => {
            for (const l of a.splice(0, a.length)) l()
        }
    }
    removeHooks(t) {
        const n = nd(t);
        for (const a in n) this.removeHook(a, n[a])
    }
    removeAllHooks() {
        for (const t in this._hooks) delete this._hooks[t]
    }
    callHook(t, ...n) {
        return n.unshift(t), this.callHookWith(JE, t, ...n)
    }
    callHookParallel(t, ...n) {
        return n.unshift(t), this.callHookWith(ZE, t, ...n)
    }
    callHookWith(t, n, ...a) {
        const l = this._before || this._after ? {
            name: n,
            args: a,
            context: {}
        } : void 0;
        this._before && cc(this._before, l);
        const r = t(n in this._hooks ? [...this._hooks[n]] : [], a);
        return r instanceof Promise ? r.finally(() => {
            this._after && l && cc(this._after, l)
        }) : (this._after && l && cc(this._after, l), r)
    }
    beforeEach(t) {
        return this._before = this._before || [], this._before.push(t), () => {
            if (this._before !== void 0) {
                const n = this._before.indexOf(t);
                n !== -1 && this._before.splice(n, 1)
            }
        }
    }
    afterEach(t) {
        return this._after = this._after || [], this._after.push(t), () => {
            if (this._after !== void 0) {
                const n = this._after.indexOf(t);
                n !== -1 && this._after.splice(n, 1)
            }
        }
    }
}

function c_() {
    return new QE
}

function eI(e = {}) {
    let t, n = !1;
    const a = o => {
        if (t && t !== o) throw new Error("Context conflict")
    };
    let l;
    if (e.asyncContext) {
        const o = e.AsyncLocalStorage || globalThis.AsyncLocalStorage;
        o ? l = new o : console.warn("[unctx] `AsyncLocalStorage` is not provided.")
    }
    const r = () => {
        if (l && t === void 0) {
            const o = l.getStore();
            if (o !== void 0) return o
        }
        return t
    };
    return {
        use: () => {
            const o = r();
            if (o === void 0) throw new Error("Context is not available");
            return o
        },
        tryUse: () => r(),
        set: (o, i) => {
            i || a(o), t = o, n = !0
        },
        unset: () => {
            t = void 0, n = !1
        },
        call: (o, i) => {
            a(o), t = o;
            try {
                return l ? l.run(o, i) : i()
            } finally {
                n || (t = void 0)
            }
        },
        async callAsync(o, i) {
            t = o;
            const s = () => {
                    t = o
                },
                u = () => t === o ? s : void 0;
            ad.add(u);
            try {
                const c = l ? l.run(o, i) : i();
                return n || (t = void 0), await c
            } finally {
                ad.delete(u)
            }
        }
    }
}

function tI(e = {}) {
    const t = {};
    return {
        get(n, a = {}) {
            return t[n] || (t[n] = eI({ ...e,
                ...a
            })), t[n], t[n]
        }
    }
}
const ps = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof global < "u" ? global : typeof window < "u" ? window : {},
    wh = "__unctx__",
    nI = ps[wh] || (ps[wh] = tI()),
    aI = (e, t = {}) => nI.get(e, t),
    kh = "__unctx_async_handlers__",
    ad = ps[kh] || (ps[kh] = new Set);

function Xn(e) {
    const t = [];
    for (const l of ad) {
        const r = l();
        r && t.push(r)
    }
    const n = () => {
        for (const l of t) l()
    };
    let a = e();
    return a && typeof a == "object" && "catch" in a && (a = a.catch(l => {
        throw n(), l
    })), [a, n]
}
const Rj = !1,
    ld = !1,
    lI = !1,
    Dj = {
        componentName: "NuxtLink"
    },
    Mj = {
        value: null,
        errorValue: null,
        deep: !0
    },
    rI = null,
    Nj = {},
    oI = "#__nuxt",
    d_ = "nuxt-app",
    Ch = 36e5;

function f_(e = d_) {
    return aI(e, {
        asyncContext: !1
    })
}
const iI = "__nuxt_plugin";

function sI(e) {
    let t = 0;
    const n = {
        _name: d_,
        _scope: xa(),
        provide: void 0,
        globalName: "nuxt",
        versions: {
            get nuxt() {
                return "3.12.3"
            },
            get vue() {
                return n.vueApp.version
            }
        },
        payload: Jn({
            data: Jn({}),
            state: mt({}),
            once: new Set,
            _errors: Jn({})
        }),
        static: {
            data: {}
        },
        runWithContext(l) {
            return n._scope.active && !$r() ? n._scope.run(() => xh(n, l)) : xh(n, l)
        },
        isHydrating: !0,
        deferHydration() {
            if (!n.isHydrating) return () => {};
            t++;
            let l = !1;
            return () => {
                if (!l && (l = !0, t--, t === 0)) return n.isHydrating = !1, n.callHook("app:suspense:resolve")
            }
        },
        _asyncDataPromises: {},
        _asyncData: Jn({}),
        _payloadRevivers: {},
        ...e
    };
    if (window.__NUXT__)
        for (const l in window.__NUXT__) switch (l) {
            case "data":
            case "state":
            case "_errors":
                Object.assign(n.payload[l], window.__NUXT__[l]);
                break;
            default:
                n.payload[l] = window.__NUXT__[l]
        }
    n.hooks = c_(), n.hook = n.hooks.hook, n.callHook = n.hooks.callHook, n.provide = (l, r) => {
        const o = "$" + l;
        Oi(n, o, r), Oi(n.vueApp.config.globalProperties, o, r)
    }, Oi(n.vueApp, "$nuxt", n), Oi(n.vueApp.config.globalProperties, "$nuxt", n); {
        window.addEventListener("nuxt.preloadError", r => {
            n.callHook("app:chunkError", {
                error: r.payload
            })
        }), window.useNuxtApp = window.useNuxtApp || Ye;
        const l = n.hook("app:error", (...r) => {
            console.error("[nuxt] error caught during app initialization", ...r)
        });
        n.hook("app:mounted", l)
    }
    const a = n.payload.config;
    return n.provide("config", a), n
}

function uI(e, t) {
    t.hooks && e.hooks.addHooks(t.hooks)
}
async function cI(e, t) {
    if (typeof t == "function") {
        const {
            provide: n
        } = await e.runWithContext(() => t(e)) || {};
        if (n && typeof n == "object")
            for (const a in n) e.provide(a, n[a])
    }
}
async function dI(e, t) {
    const n = [],
        a = [],
        l = [],
        r = [];
    let o = 0;
    async function i(s) {
        var c;
        const u = ((c = s.dependsOn) == null ? void 0 : c.filter(d => t.some(f => f._name === d) && !n.includes(d))) ? ? [];
        if (u.length > 0) a.push([new Set(u), s]);
        else {
            const d = cI(e, s).then(async () => {
                s._name && (n.push(s._name), await Promise.all(a.map(async ([f, v]) => {
                    f.has(s._name) && (f.delete(s._name), f.size === 0 && (o++, await i(v)))
                })))
            });
            s.parallel ? l.push(d.catch(f => r.push(f))) : await d
        }
    }
    for (const s of t) uI(e, s);
    for (const s of t) await i(s);
    if (await Promise.all(l), o)
        for (let s = 0; s < o; s++) await Promise.all(l);
    if (r.length) throw r[0]
}

function Wt(e) {
    if (typeof e == "function") return e;
    const t = e._name || e.name;
    return delete e.name, Object.assign(e.setup || (() => {}), e, {
        [iI]: !0,
        _name: t
    })
}

function xh(e, t, n) {
    const a = () => t();
    return f_(e._name).set(e), e.vueApp.runWithContext(a)
}

function fI(e) {
    var n;
    let t;
    return nu() && (t = (n = nn()) == null ? void 0 : n.appContext.app.$nuxt), t = t || f_(e).tryUse(), t || null
}

function Ye(e) {
    const t = fI(e);
    if (!t) throw new Error("[nuxt] instance unavailable");
    return t
}

function Ut(e) {
    return Ye().$config
}

function Oi(e, t, n) {
    Object.defineProperty(e, t, {
        get: () => n
    })
}
const Ri = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;

function vI(e, t) {
    if (typeof e != "string") throw new TypeError("argument str must be a string");
    const n = {},
        l = (t || {}).decode || gI;
    let r = 0;
    for (; r < e.length;) {
        const o = e.indexOf("=", r);
        if (o === -1) break;
        let i = e.indexOf(";", r);
        if (i === -1) i = e.length;
        else if (i < o) {
            r = e.lastIndexOf(";", o - 1) + 1;
            continue
        }
        const s = e.slice(r, o).trim();
        if (n[s] === void 0) {
            let u = e.slice(o + 1, i).trim();
            u.codePointAt(0) === 34 && (u = u.slice(1, -1)), n[s] = hI(u, l)
        }
        r = i + 1
    }
    return n
}

function Ph(e, t, n) {
    const a = n || {},
        l = a.encode || yI;
    if (typeof l != "function") throw new TypeError("option encode is invalid");
    if (!Ri.test(e)) throw new TypeError("argument name is invalid");
    const r = l(t);
    if (r && !Ri.test(r)) throw new TypeError("argument val is invalid");
    let o = e + "=" + r;
    if (a.maxAge !== void 0 && a.maxAge !== null) {
        const i = a.maxAge - 0;
        if (Number.isNaN(i) || !Number.isFinite(i)) throw new TypeError("option maxAge is invalid");
        o += "; Max-Age=" + Math.floor(i)
    }
    if (a.domain) {
        if (!Ri.test(a.domain)) throw new TypeError("option domain is invalid");
        o += "; Domain=" + a.domain
    }
    if (a.path) {
        if (!Ri.test(a.path)) throw new TypeError("option path is invalid");
        o += "; Path=" + a.path
    }
    if (a.expires) {
        if (!mI(a.expires) || Number.isNaN(a.expires.valueOf())) throw new TypeError("option expires is invalid");
        o += "; Expires=" + a.expires.toUTCString()
    }
    if (a.httpOnly && (o += "; HttpOnly"), a.secure && (o += "; Secure"), a.priority) switch (typeof a.priority == "string" ? a.priority.toLowerCase() : a.priority) {
        case "low":
            {
                o += "; Priority=Low";
                break
            }
        case "medium":
            {
                o += "; Priority=Medium";
                break
            }
        case "high":
            {
                o += "; Priority=High";
                break
            }
        default:
            throw new TypeError("option priority is invalid")
    }
    if (a.sameSite) switch (typeof a.sameSite == "string" ? a.sameSite.toLowerCase() : a.sameSite) {
        case !0:
            {
                o += "; SameSite=Strict";
                break
            }
        case "lax":
            {
                o += "; SameSite=Lax";
                break
            }
        case "strict":
            {
                o += "; SameSite=Strict";
                break
            }
        case "none":
            {
                o += "; SameSite=None";
                break
            }
        default:
            throw new TypeError("option sameSite is invalid")
    }
    return a.partitioned && (o += "; Partitioned"), o
}

function mI(e) {
    return Object.prototype.toString.call(e) === "[object Date]" || e instanceof Date
}

function hI(e, t) {
    try {
        return t(e)
    } catch {
        return e
    }
}

function gI(e) {
    return e.includes("%") ? decodeURIComponent(e) : e
}

function yI(e) {
    return encodeURIComponent(e)
}
const Eh = Object.freeze({
    ignoreUnknown: !1,
    respectType: !1,
    respectFunctionNames: !1,
    respectFunctionProperties: !1,
    unorderedObjects: !0,
    unorderedArrays: !1,
    unorderedSets: !1,
    excludeKeys: void 0,
    excludeValues: void 0,
    replacer: void 0
});

function rd(e, t) {
    t ? t = { ...Eh,
        ...t
    } : t = Eh;
    const n = v_(t);
    return n.dispatch(e), n.toString()
}
const bI = Object.freeze(["prototype", "__proto__", "constructor"]);

function v_(e) {
    let t = "",
        n = new Map;
    const a = l => {
        t += l
    };
    return {
        toString() {
            return t
        },
        getContext() {
            return n
        },
        dispatch(l) {
            return e.replacer && (l = e.replacer(l)), this[l === null ? "null" : typeof l](l)
        },
        object(l) {
            if (l && typeof l.toJSON == "function") return this.object(l.toJSON());
            const r = Object.prototype.toString.call(l);
            let o = "";
            const i = r.length;
            i < 10 ? o = "unknown:[" + r + "]" : o = r.slice(8, i - 1), o = o.toLowerCase();
            let s = null;
            if ((s = n.get(l)) === void 0) n.set(l, n.size);
            else return this.dispatch("[CIRCULAR:" + s + "]");
            if (typeof Buffer < "u" && Buffer.isBuffer && Buffer.isBuffer(l)) return a("buffer:"), a(l.toString("utf8"));
            if (o !== "object" && o !== "function" && o !== "asyncfunction") this[o] ? this[o](l) : e.ignoreUnknown || this.unkown(l, o);
            else {
                let u = Object.keys(l);
                e.unorderedObjects && (u = u.sort());
                let c = [];
                e.respectType !== !1 && !Ih(l) && (c = bI), e.excludeKeys && (u = u.filter(f => !e.excludeKeys(f)), c = c.filter(f => !e.excludeKeys(f))), a("object:" + (u.length + c.length) + ":");
                const d = f => {
                    this.dispatch(f), a(":"), e.excludeValues || this.dispatch(l[f]), a(",")
                };
                for (const f of u) d(f);
                for (const f of c) d(f)
            }
        },
        array(l, r) {
            if (r = r === void 0 ? e.unorderedArrays !== !1 : r, a("array:" + l.length + ":"), !r || l.length <= 1) {
                for (const s of l) this.dispatch(s);
                return
            }
            const o = new Map,
                i = l.map(s => {
                    const u = v_(e);
                    u.dispatch(s);
                    for (const [c, d] of u.getContext()) o.set(c, d);
                    return u.toString()
                });
            return n = o, i.sort(), this.array(i, !1)
        },
        date(l) {
            return a("date:" + l.toJSON())
        },
        symbol(l) {
            return a("symbol:" + l.toString())
        },
        unkown(l, r) {
            if (a(r), !!l && (a(":"), l && typeof l.entries == "function")) return this.array(Array.from(l.entries()), !0)
        },
        error(l) {
            return a("error:" + l.toString())
        },
        boolean(l) {
            return a("bool:" + l)
        },
        string(l) {
            a("string:" + l.length + ":"), a(l)
        },
        function(l) {
            a("fn:"), Ih(l) ? this.dispatch("[native]") : this.dispatch(l.toString()), e.respectFunctionNames !== !1 && this.dispatch("function-name:" + String(l.name)), e.respectFunctionProperties && this.object(l)
        },
        number(l) {
            return a("number:" + l)
        },
        xml(l) {
            return a("xml:" + l.toString())
        },
        null() {
            return a("Null")
        },
        undefined() {
            return a("Undefined")
        },
        regexp(l) {
            return a("regex:" + l.toString())
        },
        uint8array(l) {
            return a("uint8array:"), this.dispatch(Array.prototype.slice.call(l))
        },
        uint8clampedarray(l) {
            return a("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(l))
        },
        int8array(l) {
            return a("int8array:"), this.dispatch(Array.prototype.slice.call(l))
        },
        uint16array(l) {
            return a("uint16array:"), this.dispatch(Array.prototype.slice.call(l))
        },
        int16array(l) {
            return a("int16array:"), this.dispatch(Array.prototype.slice.call(l))
        },
        uint32array(l) {
            return a("uint32array:"), this.dispatch(Array.prototype.slice.call(l))
        },
        int32array(l) {
            return a("int32array:"), this.dispatch(Array.prototype.slice.call(l))
        },
        float32array(l) {
            return a("float32array:"), this.dispatch(Array.prototype.slice.call(l))
        },
        float64array(l) {
            return a("float64array:"), this.dispatch(Array.prototype.slice.call(l))
        },
        arraybuffer(l) {
            return a("arraybuffer:"), this.dispatch(new Uint8Array(l))
        },
        url(l) {
            return a("url:" + l.toString())
        },
        map(l) {
            a("map:");
            const r = [...l];
            return this.array(r, e.unorderedSets !== !1)
        },
        set(l) {
            a("set:");
            const r = [...l];
            return this.array(r, e.unorderedSets !== !1)
        },
        file(l) {
            return a("file:"), this.dispatch([l.name, l.size, l.type, l.lastModfied])
        },
        blob() {
            if (e.ignoreUnknown) return a("[blob]");
            throw new Error(`Hashing Blob objects is currently not supported
Use "options.replacer" or "options.ignoreUnknown"
`)
        },
        domwindow() {
            return a("domwindow")
        },
        bigint(l) {
            return a("bigint:" + l.toString())
        },
        process() {
            return a("process")
        },
        timer() {
            return a("timer")
        },
        pipe() {
            return a("pipe")
        },
        tcp() {
            return a("tcp")
        },
        udp() {
            return a("udp")
        },
        tty() {
            return a("tty")
        },
        statwatcher() {
            return a("statwatcher")
        },
        securecontext() {
            return a("securecontext")
        },
        connection() {
            return a("connection")
        },
        zlib() {
            return a("zlib")
        },
        context() {
            return a("context")
        },
        nodescript() {
            return a("nodescript")
        },
        httpparser() {
            return a("httpparser")
        },
        dataview() {
            return a("dataview")
        },
        signal() {
            return a("signal")
        },
        fsevent() {
            return a("fsevent")
        },
        tlswrap() {
            return a("tlswrap")
        }
    }
}
const m_ = "[native code] }",
    pI = m_.length;

function Ih(e) {
    return typeof e != "function" ? !1 : Function.prototype.toString.call(e).slice(-pI) === m_
}
var _I = Object.defineProperty,
    SI = (e, t, n) => t in e ? _I(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n,
    cr = (e, t, n) => (SI(e, typeof t != "symbol" ? t + "" : t, n), n);
class Ga {
    constructor(t, n) {
        cr(this, "words"), cr(this, "sigBytes"), t = this.words = t || [], this.sigBytes = n === void 0 ? t.length * 4 : n
    }
    toString(t) {
        return (t || wI).stringify(this)
    }
    concat(t) {
        if (this.clamp(), this.sigBytes % 4)
            for (let n = 0; n < t.sigBytes; n++) {
                const a = t.words[n >>> 2] >>> 24 - n % 4 * 8 & 255;
                this.words[this.sigBytes + n >>> 2] |= a << 24 - (this.sigBytes + n) % 4 * 8
            } else
                for (let n = 0; n < t.sigBytes; n += 4) this.words[this.sigBytes + n >>> 2] = t.words[n >>> 2];
        return this.sigBytes += t.sigBytes, this
    }
    clamp() {
        this.words[this.sigBytes >>> 2] &= 4294967295 << 32 - this.sigBytes % 4 * 8, this.words.length = Math.ceil(this.sigBytes / 4)
    }
    clone() {
        return new Ga([...this.words])
    }
}
const wI = {
        stringify(e) {
            const t = [];
            for (let n = 0; n < e.sigBytes; n++) {
                const a = e.words[n >>> 2] >>> 24 - n % 4 * 8 & 255;
                t.push((a >>> 4).toString(16), (a & 15).toString(16))
            }
            return t.join("")
        }
    },
    kI = {
        stringify(e) {
            const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
                n = [];
            for (let a = 0; a < e.sigBytes; a += 3) {
                const l = e.words[a >>> 2] >>> 24 - a % 4 * 8 & 255,
                    r = e.words[a + 1 >>> 2] >>> 24 - (a + 1) % 4 * 8 & 255,
                    o = e.words[a + 2 >>> 2] >>> 24 - (a + 2) % 4 * 8 & 255,
                    i = l << 16 | r << 8 | o;
                for (let s = 0; s < 4 && a * 8 + s * 6 < e.sigBytes * 8; s++) n.push(t.charAt(i >>> 6 * (3 - s) & 63))
            }
            return n.join("")
        }
    },
    CI = {
        parse(e) {
            const t = e.length,
                n = [];
            for (let a = 0; a < t; a++) n[a >>> 2] |= (e.charCodeAt(a) & 255) << 24 - a % 4 * 8;
            return new Ga(n, t)
        }
    },
    xI = {
        parse(e) {
            return CI.parse(unescape(encodeURIComponent(e)))
        }
    };
class PI {
    constructor() {
        cr(this, "_data", new Ga), cr(this, "_nDataBytes", 0), cr(this, "_minBufferSize", 0), cr(this, "blockSize", 512 / 32)
    }
    reset() {
        this._data = new Ga, this._nDataBytes = 0
    }
    _append(t) {
        typeof t == "string" && (t = xI.parse(t)), this._data.concat(t), this._nDataBytes += t.sigBytes
    }
    _doProcessBlock(t, n) {}
    _process(t) {
        let n, a = this._data.sigBytes / (this.blockSize * 4);
        t ? a = Math.ceil(a) : a = Math.max((a | 0) - this._minBufferSize, 0);
        const l = a * this.blockSize,
            r = Math.min(l * 4, this._data.sigBytes);
        if (l) {
            for (let o = 0; o < l; o += this.blockSize) this._doProcessBlock(this._data.words, o);
            n = this._data.words.splice(0, l), this._data.sigBytes -= r
        }
        return new Ga(n, r)
    }
}
class EI extends PI {
    update(t) {
        return this._append(t), this._process(), this
    }
    finalize(t) {
        t && this._append(t)
    }
}
var II = Object.defineProperty,
    TI = (e, t, n) => t in e ? II(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n,
    VI = (e, t, n) => (TI(e, t + "", n), n);
const Th = [1779033703, -1150833019, 1013904242, -1521486534, 1359893119, -1694144372, 528734635, 1541459225],
    AI = [1116352408, 1899447441, -1245643825, -373957723, 961987163, 1508970993, -1841331548, -1424204075, -670586216, 310598401, 607225278, 1426881987, 1925078388, -2132889090, -1680079193, -1046744716, -459576895, -272742522, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, -1740746414, -1473132947, -1341970488, -1084653625, -958395405, -710438585, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, -2117940946, -1838011259, -1564481375, -1474664885, -1035236496, -949202525, -778901479, -694614492, -200395387, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, -2067236844, -1933114872, -1866530822, -1538233109, -1090935817, -965641998],
    sl = [];
class LI extends EI {
    constructor() {
        super(...arguments), VI(this, "_hash", new Ga([...Th]))
    }
    reset() {
        super.reset(), this._hash = new Ga([...Th])
    }
    _doProcessBlock(t, n) {
        const a = this._hash.words;
        let l = a[0],
            r = a[1],
            o = a[2],
            i = a[3],
            s = a[4],
            u = a[5],
            c = a[6],
            d = a[7];
        for (let f = 0; f < 64; f++) {
            if (f < 16) sl[f] = t[n + f] | 0;
            else {
                const p = sl[f - 15],
                    _ = (p << 25 | p >>> 7) ^ (p << 14 | p >>> 18) ^ p >>> 3,
                    w = sl[f - 2],
                    k = (w << 15 | w >>> 17) ^ (w << 13 | w >>> 19) ^ w >>> 10;
                sl[f] = _ + sl[f - 7] + k + sl[f - 16]
            }
            const v = s & u ^ ~s & c,
                g = l & r ^ l & o ^ r & o,
                h = (l << 30 | l >>> 2) ^ (l << 19 | l >>> 13) ^ (l << 10 | l >>> 22),
                y = (s << 26 | s >>> 6) ^ (s << 21 | s >>> 11) ^ (s << 7 | s >>> 25),
                S = d + y + v + AI[f] + sl[f],
                b = h + g;
            d = c, c = u, u = s, s = i + S | 0, i = o, o = r, r = l, l = S + b | 0
        }
        a[0] = a[0] + l | 0, a[1] = a[1] + r | 0, a[2] = a[2] + o | 0, a[3] = a[3] + i | 0, a[4] = a[4] + s | 0, a[5] = a[5] + u | 0, a[6] = a[6] + c | 0, a[7] = a[7] + d | 0
    }
    finalize(t) {
        super.finalize(t);
        const n = this._nDataBytes * 8,
            a = this._data.sigBytes * 8;
        return this._data.words[a >>> 5] |= 128 << 24 - a % 32, this._data.words[(a + 64 >>> 9 << 4) + 14] = Math.floor(n / 4294967296), this._data.words[(a + 64 >>> 9 << 4) + 15] = n, this._data.sigBytes = this._data.words.length * 4, this._process(), this._hash
    }
}

function OI(e) {
    return new LI().finalize(e).toString(kI)
}

function $j(e, t = {}) {
    const n = typeof e == "string" ? e : rd(e, t);
    return OI(n).slice(0, 10)
}

function RI(e, t, n = {}) {
    return e === t || rd(e, n) === rd(t, n)
}

function DI(e, t) {
    return {
        ctx: {
            table: e
        },
        matchAll: n => g_(n, e)
    }
}

function h_(e) {
    const t = {};
    for (const n in e) t[n] = n === "dynamic" ? new Map(Object.entries(e[n]).map(([a, l]) => [a, h_(l)])) : new Map(Object.entries(e[n]));
    return t
}

function MI(e) {
    return DI(h_(e))
}

function g_(e, t, n) {
    e.endsWith("/") && (e = e.slice(0, -1) || "/");
    const a = [];
    for (const [r, o] of Vh(t.wildcard))(e === r || e.startsWith(r + "/")) && a.push(o);
    for (const [r, o] of Vh(t.dynamic))
        if (e.startsWith(r + "/")) {
            const i = "/" + e.slice(r.length).split("/").splice(2).join("/");
            a.push(...g_(i, o))
        }
    const l = t.static.get(e);
    return l && a.push(l), a.filter(Boolean)
}

function Vh(e) {
    return [...e.entries()].sort((t, n) => t[0].length - n[0].length)
}

function dc(e) {
    if (e === null || typeof e != "object") return !1;
    const t = Object.getPrototypeOf(e);
    return t !== null && t !== Object.prototype && Object.getPrototypeOf(t) !== null || Symbol.iterator in e ? !1 : Symbol.toStringTag in e ? Object.prototype.toString.call(e) === "[object Module]" : !0
}

function od(e, t, n = ".", a) {
    if (!dc(t)) return od(e, {}, n, a);
    const l = Object.assign({}, t);
    for (const r in e) {
        if (r === "__proto__" || r === "constructor") continue;
        const o = e[r];
        o != null && (a && a(l, r, o, n) || (Array.isArray(o) && Array.isArray(l[r]) ? l[r] = [...o, ...l[r]] : dc(o) && dc(l[r]) ? l[r] = od(o, l[r], (n ? `${n}.` : "") + r.toString(), a) : l[r] = o))
    }
    return l
}

function NI(e) {
    return (...t) => t.reduce((n, a) => od(n, a, "", e), {})
}
const y_ = NI();

function $I(e, t) {
    try {
        return t in e
    } catch {
        return !1
    }
}
var BI = Object.defineProperty,
    FI = (e, t, n) => t in e ? BI(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n,
    vl = (e, t, n) => (FI(e, typeof t != "symbol" ? t + "" : t, n), n);
class id extends Error {
    constructor(t, n = {}) {
        super(t, n), vl(this, "statusCode", 500), vl(this, "fatal", !1), vl(this, "unhandled", !1), vl(this, "statusMessage"), vl(this, "data"), vl(this, "cause"), n.cause && !this.cause && (this.cause = n.cause)
    }
    toJSON() {
        const t = {
            message: this.message,
            statusCode: ud(this.statusCode, 500)
        };
        return this.statusMessage && (t.statusMessage = b_(this.statusMessage)), this.data !== void 0 && (t.data = this.data), t
    }
}
vl(id, "__h3_error__", !0);

function sd(e) {
    if (typeof e == "string") return new id(e);
    if (HI(e)) return e;
    const t = new id(e.message ? ? e.statusMessage ? ? "", {
        cause: e.cause || e
    });
    if ($I(e, "stack")) try {
        Object.defineProperty(t, "stack", {
            get() {
                return e.stack
            }
        })
    } catch {
        try {
            t.stack = e.stack
        } catch {}
    }
    if (e.data && (t.data = e.data), e.statusCode ? t.statusCode = ud(e.statusCode, t.statusCode) : e.status && (t.statusCode = ud(e.status, t.statusCode)), e.statusMessage ? t.statusMessage = e.statusMessage : e.statusText && (t.statusMessage = e.statusText), t.statusMessage) {
        const n = t.statusMessage;
        b_(t.statusMessage) !== n && console.warn("[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default.")
    }
    return e.fatal !== void 0 && (t.fatal = e.fatal), e.unhandled !== void 0 && (t.unhandled = e.unhandled), t
}

function HI(e) {
    var t;
    return ((t = e == null ? void 0 : e.constructor) == null ? void 0 : t.__h3_error__) === !0
}
const jI = /[^\u0009\u0020-\u007E]/g;

function b_(e = "") {
    return e.replace(jI, "")
}

function ud(e, t = 200) {
    return !e || (typeof e == "string" && (e = Number.parseInt(e, 10)), e < 100 || e > 999) ? t : e
}
const UI = Symbol("layout-meta"),
    uu = Symbol("route"),
    Vn = () => {
        var e;
        return (e = Ye()) == null ? void 0 : e.$router
    },
    iv = () => nu() ? Te(uu, Ye()._route) : Ye()._route;

function Bj(e) {
    return e
}
const WI = (e, t, n = {}) => {
        const a = Ye(),
            l = n.global || typeof e != "string",
            r = t;
        if (!r) {
            console.warn("[nuxt] No route middleware passed to `addRouteMiddleware`.", e);
            return
        }
        l ? a._middleware.global.push(r) : a._middleware.named[e] = r
    },
    zI = () => {
        try {
            if (Ye()._processingMiddleware) return !0
        } catch {
            return !1
        }
        return !1
    },
    KI = (e, t) => {
        e || (e = "/");
        const n = typeof e == "string" ? e : "path" in e ? GI(e) : Vn().resolve(e).href;
        if (t != null && t.open) {
            const {
                target: s = "_blank",
                windowFeatures: u = {}
            } = t.open, c = Object.entries(u).filter(([d, f]) => f !== void 0).map(([d, f]) => `${d.toLowerCase()}=${f}`).join(", ");
            return open(n, s, c), Promise.resolve()
        }
        const a = aa(n, {
                acceptRelative: !0
            }),
            l = (t == null ? void 0 : t.external) || a;
        if (l) {
            if (!(t != null && t.external)) throw new Error("Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`.");
            const {
                protocol: s
            } = new URL(n, window.location.href);
            if (s && CE(s)) throw new Error(`Cannot navigate to a URL with '${s}' protocol.`)
        }
        const r = zI();
        if (!l && r) return e;
        const o = Vn(),
            i = Ye();
        return l ? (i._scope.stop(), t != null && t.replace ? location.replace(n) : location.href = n, r ? i.isHydrating ? new Promise(() => {}) : !1 : Promise.resolve()) : t != null && t.replace ? o.replace(e) : o.push(e)
    };

function GI(e) {
    return a_(e.path || "", e.query || {}) + (e.hash || "")
}
const p_ = "__nuxt_error",
    cu = () => Y(Ye().payload, "error"),
    dr = e => {
        const t = du(e);
        try {
            const n = Ye(),
                a = cu();
            n.hooks.callHook("app:error", t), a.value = a.value || t
        } catch {
            throw t
        }
        return t
    },
    YI = async (e = {}) => {
        const t = Ye(),
            n = cu();
        t.callHook("app:error:cleared", e), e.redirect && await Vn().replace(e.redirect), n.value = rI
    },
    qI = e => !!e && typeof e == "object" && p_ in e,
    du = e => {
        const t = sd(e);
        return Object.defineProperty(t, p_, {
            value: !0,
            configurable: !1,
            writable: !1
        }), t
    },
    XI = -1,
    JI = -2,
    ZI = -3,
    QI = -4,
    eT = -5,
    tT = -6;

function nT(e, t) {
    return aT(JSON.parse(e), t)
}

function aT(e, t) {
    if (typeof e == "number") return l(e, !0);
    if (!Array.isArray(e) || e.length === 0) throw new Error("Invalid input");
    const n = e,
        a = Array(n.length);

    function l(r, o = !1) {
        if (r === XI) return;
        if (r === ZI) return NaN;
        if (r === QI) return 1 / 0;
        if (r === eT) return -1 / 0;
        if (r === tT) return -0;
        if (o) throw new Error("Invalid input");
        if (r in a) return a[r];
        const i = n[r];
        if (!i || typeof i != "object") a[r] = i;
        else if (Array.isArray(i))
            if (typeof i[0] == "string") {
                const s = i[0],
                    u = t == null ? void 0 : t[s];
                if (u) return a[r] = u(l(i[1]));
                switch (s) {
                    case "Date":
                        a[r] = new Date(i[1]);
                        break;
                    case "Set":
                        const c = new Set;
                        a[r] = c;
                        for (let v = 1; v < i.length; v += 1) c.add(l(i[v]));
                        break;
                    case "Map":
                        const d = new Map;
                        a[r] = d;
                        for (let v = 1; v < i.length; v += 2) d.set(l(i[v]), l(i[v + 1]));
                        break;
                    case "RegExp":
                        a[r] = new RegExp(i[1], i[2]);
                        break;
                    case "Object":
                        a[r] = Object(i[1]);
                        break;
                    case "BigInt":
                        a[r] = BigInt(i[1]);
                        break;
                    case "null":
                        const f = Object.create(null);
                        a[r] = f;
                        for (let v = 1; v < i.length; v += 2) f[i[v]] = l(i[v + 1]);
                        break;
                    default:
                        throw new Error(`Unknown type ${s}`)
                }
            } else {
                const s = new Array(i.length);
                a[r] = s;
                for (let u = 0; u < i.length; u += 1) {
                    const c = i[u];
                    c !== JI && (s[u] = l(c))
                }
            }
        else {
            const s = {};
            a[r] = s;
            for (const u in i) {
                const c = i[u];
                s[u] = l(c)
            }
        }
        return a[r]
    }
    return l(0)
}

function lT(e) {
    return Array.isArray(e) ? e : [e]
}
const rT = ["title", "titleTemplate", "script", "style", "noscript"],
    qi = ["base", "meta", "link", "style", "script", "noscript"],
    oT = ["title", "titleTemplate", "templateParams", "base", "htmlAttrs", "bodyAttrs", "meta", "link", "style", "script", "noscript"],
    iT = ["base", "title", "titleTemplate", "bodyAttrs", "htmlAttrs", "templateParams"],
    __ = ["tagPosition", "tagPriority", "tagDuplicateStrategy", "children", "innerHTML", "textContent", "processTemplateParams"],
    sT = typeof window < "u";

function sv(e) {
    let t = 9;
    for (let n = 0; n < e.length;) t = Math.imul(t ^ e.charCodeAt(n++), 9 ** 9);
    return ((t ^ t >>> 9) + 65536).toString(16).substring(1, 8).toLowerCase()
}

function Ah(e) {
    return e._h || sv(e._d ? e._d : `${e.tag}:${e.textContent||e.innerHTML||""}:${Object.entries(e.props).map(([t,n])=>`${t}:${String(n)}`).join(",")}`)
}

function S_(e, t) {
    const {
        props: n,
        tag: a
    } = e;
    if (iT.includes(a)) return a;
    if (a === "link" && n.rel === "canonical") return "canonical";
    if (n.charset) return "charset";
    const l = ["id"];
    a === "meta" && l.push("name", "property", "http-equiv");
    for (const r of l)
        if (typeof n[r] < "u") {
            const o = String(n[r]);
            return `${a}:${r}:${o}`
        }
    return !1
}

function Lh(e, t) {
    return e == null ? t || null : typeof e == "function" ? e(t) : e
}
async function uT(e, t, n) {
    const a = {
        tag: e,
        props: await w_(typeof t == "object" && typeof t != "function" && !(t instanceof Promise) ? { ...t
        } : {
            [
                ["script", "noscript", "style"].includes(e) ? "innerHTML" : "textContent"
            ]: t
        }, ["templateParams", "titleTemplate"].includes(e))
    };
    return __.forEach(l => {
        const r = typeof a.props[l] < "u" ? a.props[l] : n[l];
        typeof r < "u" && ((!["innerHTML", "textContent", "children"].includes(l) || rT.includes(a.tag)) && (a[l === "children" ? "innerHTML" : l] = r), delete a.props[l])
    }), a.props.body && (a.tagPosition = "bodyClose", delete a.props.body), a.tag === "script" && typeof a.innerHTML == "object" && (a.innerHTML = JSON.stringify(a.innerHTML), a.props.type = a.props.type || "application/json"), Array.isArray(a.props.content) ? a.props.content.map(l => ({ ...a,
        props: { ...a.props,
            content: l
        }
    })) : a
}

function cT(e, t) {
    var a;
    const n = e === "class" ? " " : ";";
    return typeof t == "object" && !Array.isArray(t) && (t = Object.entries(t).filter(([, l]) => l).map(([l, r]) => e === "style" ? `${l}:${r}` : l)), (a = String(Array.isArray(t) ? t.join(n) : t)) == null ? void 0 : a.split(n).filter(l => l.trim()).filter(Boolean).join(n)
}
async function w_(e, t) {
    for (const n of Object.keys(e)) {
        if (["class", "style"].includes(n)) {
            e[n] = cT(n, e[n]);
            continue
        }
        if (e[n] instanceof Promise && (e[n] = await e[n]), !t && !__.includes(n)) {
            const a = String(e[n]),
                l = n.startsWith("data-");
            a === "true" || a === "" ? e[n] = l ? "true" : !0 : e[n] || (l && a === "false" ? e[n] = "false" : delete e[n])
        }
    }
    return e
}
const dT = 10;
async function fT(e) {
    const t = [];
    return Object.entries(e.resolvedInput).filter(([n, a]) => typeof a < "u" && oT.includes(n)).forEach(([n, a]) => {
        const l = lT(a);
        t.push(...l.map(r => uT(n, r, e)).flat())
    }), (await Promise.all(t)).flat().filter(Boolean).map((n, a) => (n._e = e._i, e.mode && (n._m = e.mode), n._p = (e._i << dT) + a, n))
}
const Oh = {
        base: -10,
        title: 10
    },
    Rh = {
        critical: -80,
        high: -10,
        low: 20
    };

function _s(e) {
    let t = 100;
    const n = e.tagPriority;
    return typeof n == "number" ? n : (e.tag === "meta" ? (e.props["http-equiv"] === "content-security-policy" && (t = -30), e.props.charset && (t = -20), e.props.name === "viewport" && (t = -15)) : e.tag === "link" && e.props.rel === "preconnect" ? t = 20 : e.tag in Oh && (t = Oh[e.tag]), typeof n == "string" && n in Rh ? t + Rh[n] : t)
}
const vT = [{
        prefix: "before:",
        offset: -1
    }, {
        prefix: "after:",
        offset: 1
    }],
    Dh = ["onload", "onerror", "onabort", "onprogress", "onloadstart"],
    Oa = "%separator";

function Xi(e, t, n) {
    if (typeof e != "string" || !e.includes("%")) return e;

    function a(o) {
        let i;
        return ["s", "pageTitle"].includes(o) ? i = t.pageTitle : o.includes(".") ? i = o.split(".").reduce((s, u) => s && s[u] || void 0, t) : i = t[o], typeof i < "u" ? (i || "").replace(/"/g, '\\"') : !1
    }
    let l = e;
    try {
        l = decodeURI(e)
    } catch {}
    return (l.match(/%(\w+\.+\w+)|%(\w+)/g) || []).sort().reverse().forEach(o => {
        const i = a(o.slice(1));
        typeof i == "string" && (e = e.replace(new RegExp(`\\${o}(\\W|$)`, "g"), (s, u) => `${i}${u}`).trim())
    }), e.includes(Oa) && (e.endsWith(Oa) && (e = e.slice(0, -Oa.length).trim()), e.startsWith(Oa) && (e = e.slice(Oa.length).trim()), e = e.replace(new RegExp(`\\${Oa}\\s*\\${Oa}`, "g"), Oa), e = Xi(e, {
        separator: n
    }, n)), e
}
async function k_(e, t = {}) {
    var c;
    const n = t.document || e.resolvedOptions.document;
    if (!n || !e.dirty) return;
    const a = {
        shouldRender: !0,
        tags: []
    };
    if (await e.hooks.callHook("dom:beforeRender", a), !a.shouldRender) return;
    const l = (await e.resolveTags()).map(d => ({
        tag: d,
        id: qi.includes(d.tag) ? Ah(d) : d.tag,
        shouldRender: !0
    }));
    let r = e._dom;
    if (!r) {
        r = {
            elMap: {
                htmlAttrs: n.documentElement,
                bodyAttrs: n.body
            }
        };
        for (const d of ["body", "head"]) {
            const f = (c = n[d]) == null ? void 0 : c.children,
                v = [];
            for (const g of [...f].filter(h => qi.includes(h.tagName.toLowerCase()))) {
                const h = {
                    tag: g.tagName.toLowerCase(),
                    props: await w_(g.getAttributeNames().reduce((b, p) => ({ ...b,
                        [p]: g.getAttribute(p)
                    }), {})),
                    innerHTML: g.innerHTML
                };
                let y = 1,
                    S = S_(h);
                for (; S && v.find(b => b._d === S);) S = `${S}:${y++}`;
                h._d = S || void 0, v.push(h), r.elMap[g.getAttribute("data-hid") || Ah(h)] = g
            }
        }
    }
    r.pendingSideEffects = { ...r.sideEffects || {}
    }, r.sideEffects = {};

    function o(d, f, v) {
        const g = `${d}:${f}`;
        r.sideEffects[g] = v, delete r.pendingSideEffects[g]
    }

    function i({
        id: d,
        $el: f,
        tag: v
    }) {
        const g = v.tag.endsWith("Attrs");
        r.elMap[d] = f, g || (["textContent", "innerHTML"].forEach(h => {
            v[h] && v[h] !== f[h] && (f[h] = v[h])
        }), o(d, "el", () => {
            var h;
            (h = r.elMap[d]) == null || h.remove(), delete r.elMap[d]
        }));
        for (const [h, y] of Object.entries(v._eventHandlers || {})) f.getAttribute(`data-${h}`) !== "" && ((v.tag === "bodyAttrs" ? n.defaultView : f).addEventListener(h.replace("on", ""), y.bind(f)), f.setAttribute(`data-${h}`, ""));
        Object.entries(v.props).forEach(([h, y]) => {
            const S = `attr:${h}`;
            if (h === "class")
                for (const b of (y || "").split(" ").filter(Boolean)) g && o(d, `${S}:${b}`, () => f.classList.remove(b)), !f.classList.contains(b) && f.classList.add(b);
            else if (h === "style")
                for (const b of (y || "").split(";").filter(Boolean)) {
                    const [p, ..._] = b.split(":").map(w => w.trim());
                    o(d, `${S}:${p}`, () => {
                        f.style.removeProperty(p)
                    }), f.style.setProperty(p, _.join(":"))
                } else f.getAttribute(h) !== y && f.setAttribute(h, y === !0 ? "" : String(y)), g && o(d, S, () => f.removeAttribute(h))
        })
    }
    const s = [],
        u = {
            bodyClose: void 0,
            bodyOpen: void 0,
            head: void 0
        };
    for (const d of l) {
        const {
            tag: f,
            shouldRender: v,
            id: g
        } = d;
        if (v) {
            if (f.tag === "title") {
                n.title = f.textContent;
                continue
            }
            d.$el = d.$el || r.elMap[g], d.$el ? i(d) : qi.includes(f.tag) && s.push(d)
        }
    }
    for (const d of s) {
        const f = d.tag.tagPosition || "head";
        d.$el = n.createElement(d.tag.tag), i(d), u[f] = u[f] || n.createDocumentFragment(), u[f].appendChild(d.$el)
    }
    for (const d of l) await e.hooks.callHook("dom:renderTag", d, n, o);
    u.head && n.head.appendChild(u.head), u.bodyOpen && n.body.insertBefore(u.bodyOpen, n.body.firstChild), u.bodyClose && n.body.appendChild(u.bodyClose), Object.values(r.pendingSideEffects).forEach(d => d()), e._dom = r, e.dirty = !1, await e.hooks.callHook("dom:rendered", {
        renders: l
    })
}
async function mT(e, t = {}) {
    const n = t.delayFn || (a => setTimeout(a, 10));
    return e._domUpdatePromise = e._domUpdatePromise || new Promise(a => n(async () => {
        await k_(e, t), delete e._domUpdatePromise, a()
    }))
}

function hT(e) {
    return t => {
        var a, l;
        const n = ((l = (a = t.resolvedOptions.document) == null ? void 0 : a.head.querySelector('script[id="unhead:payload"]')) == null ? void 0 : l.innerHTML) || !1;
        return n && t.push(JSON.parse(n)), {
            mode: "client",
            hooks: {
                "entries:updated": function(r) {
                    mT(r, e)
                }
            }
        }
    }
}
const gT = ["templateParams", "htmlAttrs", "bodyAttrs"],
    yT = {
        hooks: {
            "tag:normalise": function({
                tag: e
            }) {
                ["hid", "vmid", "key"].forEach(a => {
                    e.props[a] && (e.key = e.props[a], delete e.props[a])
                });
                const n = S_(e) || (e.key ? `${e.tag}:${e.key}` : !1);
                n && (e._d = n)
            },
            "tags:resolve": function(e) {
                const t = {};
                e.tags.forEach(a => {
                    const l = (a.key ? `${a.tag}:${a.key}` : a._d) || a._p,
                        r = t[l];
                    if (r) {
                        let i = a == null ? void 0 : a.tagDuplicateStrategy;
                        if (!i && gT.includes(a.tag) && (i = "merge"), i === "merge") {
                            const s = r.props;
                            ["class", "style"].forEach(u => {
                                s[u] && (a.props[u] ? (u === "style" && !s[u].endsWith(";") && (s[u] += ";"), a.props[u] = `${s[u]} ${a.props[u]}`) : a.props[u] = s[u])
                            }), t[l].props = { ...s,
                                ...a.props
                            };
                            return
                        } else if (a._e === r._e) {
                            r._duped = r._duped || [], a._d = `${r._d}:${r._duped.length+1}`, r._duped.push(a);
                            return
                        } else if (_s(a) > _s(r)) return
                    }
                    const o = Object.keys(a.props).length + (a.innerHTML ? 1 : 0) + (a.textContent ? 1 : 0);
                    if (qi.includes(a.tag) && o === 0) {
                        delete t[l];
                        return
                    }
                    t[l] = a
                });
                const n = [];
                Object.values(t).forEach(a => {
                    const l = a._duped;
                    delete a._duped, n.push(a), l && n.push(...l)
                }), e.tags = n, e.tags = e.tags.filter(a => !(a.tag === "meta" && (a.props.name || a.props.property) && !a.props.content))
            }
        }
    },
    bT = {
        mode: "server",
        hooks: {
            "tags:resolve": function(e) {
                const t = {};
                e.tags.filter(n => ["titleTemplate", "templateParams", "title"].includes(n.tag) && n._m === "server").forEach(n => {
                    t[n.tag] = n.tag.startsWith("title") ? n.textContent : n.props
                }), Object.keys(t).length && e.tags.push({
                    tag: "script",
                    innerHTML: JSON.stringify(t),
                    props: {
                        id: "unhead:payload",
                        type: "application/json"
                    }
                })
            }
        }
    },
    pT = ["script", "link", "bodyAttrs"],
    _T = e => ({
        hooks: {
            "tags:resolve": function(t) {
                for (const n of t.tags.filter(a => pT.includes(a.tag))) Object.entries(n.props).forEach(([a, l]) => {
                    a.startsWith("on") && typeof l == "function" && (e.ssr && Dh.includes(a) ? n.props[a] = `this.dataset.${a}fired = true` : delete n.props[a], n._eventHandlers = n._eventHandlers || {}, n._eventHandlers[a] = l)
                }), e.ssr && n._eventHandlers && (n.props.src || n.props.href) && (n.key = n.key || sv(n.props.src || n.props.href))
            },
            "dom:renderTag": function({
                $el: t,
                tag: n
            }) {
                var a, l;
                for (const r of Object.keys((t == null ? void 0 : t.dataset) || {}).filter(o => Dh.some(i => `${i}fired` === o))) {
                    const o = r.replace("fired", "");
                    (l = (a = n._eventHandlers) == null ? void 0 : a[o]) == null || l.call(t, new Event(o.replace("on", "")))
                }
            }
        }
    }),
    ST = ["link", "style", "script", "noscript"],
    wT = {
        hooks: {
            "tag:normalise": ({
                tag: e
            }) => {
                e.key && ST.includes(e.tag) && (e.props["data-hid"] = e._h = sv(e.key))
            }
        }
    },
    kT = {
        hooks: {
            "tags:resolve": e => {
                const t = n => {
                    var a;
                    return (a = e.tags.find(l => l._d === n)) == null ? void 0 : a._p
                };
                for (const {
                        prefix: n,
                        offset: a
                    } of vT)
                    for (const l of e.tags.filter(r => typeof r.tagPriority == "string" && r.tagPriority.startsWith(n))) {
                        const r = t(l.tagPriority.replace(n, ""));
                        typeof r < "u" && (l._p = r + a)
                    }
                e.tags.sort((n, a) => n._p - a._p).sort((n, a) => _s(n) - _s(a))
            }
        }
    },
    CT = {
        meta: "content",
        link: "href",
        htmlAttrs: "lang"
    },
    xT = e => ({
        hooks: {
            "tags:resolve": t => {
                var i;
                const {
                    tags: n
                } = t, a = (i = n.find(s => s.tag === "title")) == null ? void 0 : i.textContent, l = n.findIndex(s => s.tag === "templateParams"), r = l !== -1 ? n[l].props : {}, o = r.separator || "|";
                delete r.separator, r.pageTitle = Xi(r.pageTitle || a || "", r, o);
                for (const s of n.filter(u => u.processTemplateParams !== !1)) {
                    const u = CT[s.tag];
                    u && typeof s.props[u] == "string" ? s.props[u] = Xi(s.props[u], r, o) : (s.processTemplateParams === !0 || ["titleTemplate", "title"].includes(s.tag)) && ["innerHTML", "textContent"].forEach(c => {
                        typeof s[c] == "string" && (s[c] = Xi(s[c], r, o))
                    })
                }
                e._templateParams = r, e._separator = o, t.tags = n.filter(s => s.tag !== "templateParams")
            }
        }
    }),
    PT = {
        hooks: {
            "tags:resolve": e => {
                const {
                    tags: t
                } = e;
                let n = t.findIndex(l => l.tag === "titleTemplate");
                const a = t.findIndex(l => l.tag === "title");
                if (a !== -1 && n !== -1) {
                    const l = Lh(t[n].textContent, t[a].textContent);
                    l !== null ? t[a].textContent = l || t[a].textContent : delete t[a]
                } else if (n !== -1) {
                    const l = Lh(t[n].textContent);
                    l !== null && (t[n].textContent = l, t[n].tag = "title", n = -1)
                }
                n !== -1 && delete t[n], e.tags = t.filter(Boolean)
            }
        }
    },
    ET = {
        hooks: {
            "tags:afterResolve": function(e) {
                for (const t of e.tags) typeof t.innerHTML == "string" && (t.innerHTML && ["application/ld+json", "application/json"].includes(t.props.type) ? t.innerHTML = t.innerHTML.replace(/</g, "\\u003C") : t.innerHTML = t.innerHTML.replace(new RegExp(`</${t.tag}`, "g"), `<\\/${t.tag}`))
            }
        }
    };
let C_;

function IT(e = {}) {
    const t = TT(e);
    return t.use(hT()), C_ = t
}

function Mh(e, t) {
    return !e || e === "server" && t || e === "client" && !t
}

function TT(e = {}) {
    const t = c_();
    t.addHooks(e.hooks || {}), e.document = e.document || (sT ? document : void 0);
    const n = !e.document,
        a = () => {
            i.dirty = !0, t.callHook("entries:updated", i)
        };
    let l = 0,
        r = [];
    const o = [],
        i = {
            plugins: o,
            dirty: !1,
            resolvedOptions: e,
            hooks: t,
            headEntries() {
                return r
            },
            use(s) {
                const u = typeof s == "function" ? s(i) : s;
                (!u.key || !o.some(c => c.key === u.key)) && (o.push(u), Mh(u.mode, n) && t.addHooks(u.hooks || {}))
            },
            push(s, u) {
                u == null || delete u.head;
                const c = {
                    _i: l++,
                    input: s,
                    ...u
                };
                return Mh(c.mode, n) && (r.push(c), a()), {
                    dispose() {
                        r = r.filter(d => d._i !== c._i), t.callHook("entries:updated", i), a()
                    },
                    patch(d) {
                        r = r.map(f => (f._i === c._i && (f.input = c.input = d), f)), a()
                    }
                }
            },
            async resolveTags() {
                const s = {
                    tags: [],
                    entries: [...r]
                };
                await t.callHook("entries:resolve", s);
                for (const u of s.entries) {
                    const c = u.resolvedInput || u.input;
                    if (u.resolvedInput = await (u.transform ? u.transform(c) : c), u.resolvedInput)
                        for (const d of await fT(u)) {
                            const f = {
                                tag: d,
                                entry: u,
                                resolvedOptions: i.resolvedOptions
                            };
                            await t.callHook("tag:normalise", f), s.tags.push(f.tag)
                        }
                }
                return await t.callHook("tags:beforeResolve", s), await t.callHook("tags:resolve", s), await t.callHook("tags:afterResolve", s), s.tags
            },
            ssr: n
        };
    return [yT, bT, _T, wT, kT, xT, PT, ET, ...(e == null ? void 0 : e.plugins) || []].forEach(s => i.use(s)), i.hooks.callHook("init", i), i
}

function VT() {
    return C_
}
const AT = tv.startsWith("3");

function LT(e) {
    return typeof e == "function" ? e() : Ie(e)
}

function cd(e, t = "") {
    if (e instanceof Promise) return e;
    const n = LT(e);
    return !e || !n ? n : Array.isArray(n) ? n.map(a => cd(a, t)) : typeof n == "object" ? Object.fromEntries(Object.entries(n).map(([a, l]) => a === "titleTemplate" || a.startsWith("on") ? [a, Ie(l)] : [a, cd(l, a)])) : n
}
const OT = {
        hooks: {
            "entries:resolve": function(e) {
                for (const t of e.entries) t.resolvedInput = cd(t.input)
            }
        }
    },
    x_ = "usehead";

function RT(e) {
    return {
        install(n) {
            AT && (n.config.globalProperties.$unhead = e, n.config.globalProperties.$head = e, n.provide(x_, e))
        }
    }.install
}

function DT(e = {}) {
    e.domDelayFn = e.domDelayFn || (n => Re(() => setTimeout(() => n(), 0)));
    const t = IT(e);
    return t.use(OT), t.install = RT(t), t
}
const dd = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {},
    fd = "__unhead_injection_handler__";

function MT(e) {
    dd[fd] = e
}

function Fj() {
    if (fd in dd) return dd[fd]();
    const e = Te(x_);
    return e || VT()
}
let Ji, Zi;

function NT() {
    return Ji = $fetch(ov(`builds/meta/${Ut().app.buildId}.json`), {
        responseType: "json"
    }), Ji.then(e => {
        Zi = MI(e.matcher)
    }).catch(e => {
        console.error("[nuxt] Error fetching app manifest.", e)
    }), Ji
}

function fu() {
    return Ji || NT()
}
async function uv(e) {
    if (await fu(), !Zi) return console.error("[nuxt] Error creating app manifest matcher.", Zi), {};
    try {
        return y_({}, ...Zi.matchAll(e).reverse())
    } catch (t) {
        return console.error("[nuxt] Error matching route rules.", t), {}
    }
}
async function Nh(e, t = {}) {
    const n = await BT(e, t),
        a = Ye(),
        l = a._payloadCache = a._payloadCache || {};
    return n in l || (l[n] = E_(e).then(r => r ? P_(n).then(o => o || (delete l[n], null)) : (l[n] = null, null))), l[n]
}
const $T = "_payload.json";
async function BT(e, t = {}) {
    const n = new URL(e, "http://localhost");
    if (n.host !== "localhost" || aa(n.pathname, {
            acceptRelative: !0
        })) throw new Error("Payload URL must not include hostname: " + e);
    const a = Ut(),
        l = t.hash || (t.fresh ? Date.now() : a.app.buildId),
        r = a.app.cdnURL,
        o = r && await E_(e) ? r : a.app.baseURL;
    return Ur(o, n.pathname, $T + (l ? `?${l}` : ""))
}
async function P_(e) {
    const t = fetch(e).then(n => n.text().then(I_));
    try {
        return await t
    } catch (n) {
        console.warn("[nuxt] Cannot load payload ", e, n)
    }
    return null
}
async function E_(e = iv().path) {
    if (e = su(e), (await fu()).prerendered.includes(e)) return !0;
    const n = await uv(e);
    return !!n.prerender && !n.redirect
}
let Di = null;
async function FT() {
    if (Di) return Di;
    const e = document.getElementById("__NUXT_DATA__");
    if (!e) return {};
    const t = await I_(e.textContent || ""),
        n = e.dataset.src ? await P_(e.dataset.src) : void 0;
    return Di = { ...t,
        ...n,
        ...window.__NUXT__
    }, Di
}
async function I_(e) {
    return await nT(e, Ye()._payloadRevivers)
}

function HT(e, t) {
    Ye()._payloadRevivers[e] = t
}
const $h = {
        NuxtError: e => du(e),
        EmptyShallowRef: e => fe(e === "_" ? void 0 : e === "0n" ? BigInt(0) : Ao(e)),
        EmptyRef: e => Q(e === "_" ? void 0 : e === "0n" ? BigInt(0) : Ao(e)),
        ShallowRef: e => fe(e),
        ShallowReactive: e => Jn(e),
        Ref: e => Q(e),
        Reactive: e => mt(e)
    },
    jT = Wt({
        name: "nuxt:revive-payload:client",
        order: -30,
        async setup(e) {
            let t, n;
            for (const a in $h) HT(a, $h[a]);
            Object.assign(e.payload, ([t, n] = Xn(() => e.runWithContext(FT)), t = await t, n(), t)), window.__NUXT__ = e.payload
        }
    }),
    UT = [],
    WT = Wt({
        name: "nuxt:head",
        enforce: "pre",
        setup(e) {
            const t = DT({
                plugins: UT
            });
            MT(() => Ye().vueApp._context.provides.usehead), e.vueApp.use(t); {
                let n = !0;
                const a = async () => {
                    n = !1, await k_(t)
                };
                t.hooks.hook("dom:beforeRender", l => {
                    l.shouldRender = !n
                }), e.hooks.hook("page:start", () => {
                    n = !0
                }), e.hooks.hook("page:finish", () => {
                    e.isHydrating || a()
                }), e.hooks.hook("app:error", a), e.hooks.hook("app:suspense:resolve", a)
            }
        }
    });
/*!
 * vue-router v4.4.0
 * (c) 2024 Eduardo San Martin Morote
 * @license MIT
 */
const sr = typeof document < "u";

function zT(e) {
    return e.__esModule || e[Symbol.toStringTag] === "Module"
}
const qe = Object.assign;

function fc(e, t) {
    const n = {};
    for (const a in t) {
        const l = t[a];
        n[a] = Bn(l) ? l.map(e) : e(l)
    }
    return n
}
const ho = () => {},
    Bn = Array.isArray,
    T_ = /#/g,
    KT = /&/g,
    GT = /\//g,
    YT = /=/g,
    qT = /\?/g,
    V_ = /\+/g,
    XT = /%5B/g,
    JT = /%5D/g,
    A_ = /%5E/g,
    ZT = /%60/g,
    L_ = /%7B/g,
    QT = /%7C/g,
    O_ = /%7D/g,
    eV = /%20/g;

function cv(e) {
    return encodeURI("" + e).replace(QT, "|").replace(XT, "[").replace(JT, "]")
}

function tV(e) {
    return cv(e).replace(L_, "{").replace(O_, "}").replace(A_, "^")
}

function vd(e) {
    return cv(e).replace(V_, "%2B").replace(eV, "+").replace(T_, "%23").replace(KT, "%26").replace(ZT, "`").replace(L_, "{").replace(O_, "}").replace(A_, "^")
}

function nV(e) {
    return vd(e).replace(YT, "%3D")
}

function aV(e) {
    return cv(e).replace(T_, "%23").replace(qT, "%3F")
}

function lV(e) {
    return e == null ? "" : aV(e).replace(GT, "%2F")
}

function Lo(e) {
    try {
        return decodeURIComponent("" + e)
    } catch {}
    return "" + e
}
const rV = /\/$/,
    oV = e => e.replace(rV, "");

function vc(e, t, n = "/") {
    let a, l = {},
        r = "",
        o = "";
    const i = t.indexOf("#");
    let s = t.indexOf("?");
    return i < s && i >= 0 && (s = -1), s > -1 && (a = t.slice(0, s), r = t.slice(s + 1, i > -1 ? i : t.length), l = e(r)), i > -1 && (a = a || t.slice(0, i), o = t.slice(i, t.length)), a = cV(a ? ? t, n), {
        fullPath: a + (r && "?") + r + o,
        path: a,
        query: l,
        hash: Lo(o)
    }
}

function iV(e, t) {
    const n = t.query ? e(t.query) : "";
    return t.path + (n && "?") + n + (t.hash || "")
}

function Bh(e, t) {
    return !t || !e.toLowerCase().startsWith(t.toLowerCase()) ? e : e.slice(t.length) || "/"
}

function sV(e, t, n) {
    const a = t.matched.length - 1,
        l = n.matched.length - 1;
    return a > -1 && a === l && xr(t.matched[a], n.matched[l]) && R_(t.params, n.params) && e(t.query) === e(n.query) && t.hash === n.hash
}

function xr(e, t) {
    return (e.aliasOf || e) === (t.aliasOf || t)
}

function R_(e, t) {
    if (Object.keys(e).length !== Object.keys(t).length) return !1;
    for (const n in e)
        if (!uV(e[n], t[n])) return !1;
    return !0
}

function uV(e, t) {
    return Bn(e) ? Fh(e, t) : Bn(t) ? Fh(t, e) : e === t
}

function Fh(e, t) {
    return Bn(t) ? e.length === t.length && e.every((n, a) => n === t[a]) : e.length === 1 && e[0] === t
}

function cV(e, t) {
    if (e.startsWith("/")) return e;
    if (!e) return t;
    const n = t.split("/"),
        a = e.split("/"),
        l = a[a.length - 1];
    (l === ".." || l === ".") && a.push("");
    let r = n.length - 1,
        o, i;
    for (o = 0; o < a.length; o++)
        if (i = a[o], i !== ".")
            if (i === "..") r > 1 && r--;
            else break;
    return n.slice(0, r).join("/") + "/" + a.slice(o).join("/")
}
const Mn = {
    path: "/",
    name: void 0,
    params: {},
    query: {},
    hash: "",
    fullPath: "/",
    matched: [],
    meta: {},
    redirectedFrom: void 0
};
var Oo;
(function(e) {
    e.pop = "pop", e.push = "push"
})(Oo || (Oo = {}));
var go;
(function(e) {
    e.back = "back", e.forward = "forward", e.unknown = ""
})(go || (go = {}));

function dV(e) {
    if (!e)
        if (sr) {
            const t = document.querySelector("base");
            e = t && t.getAttribute("href") || "/", e = e.replace(/^\w+:\/\/[^\/]+/, "")
        } else e = "/";
    return e[0] !== "/" && e[0] !== "#" && (e = "/" + e), oV(e)
}
const fV = /^[^#]+#/;

function vV(e, t) {
    return e.replace(fV, "#") + t
}

function mV(e, t) {
    const n = document.documentElement.getBoundingClientRect(),
        a = e.getBoundingClientRect();
    return {
        behavior: t.behavior,
        left: a.left - n.left - (t.left || 0),
        top: a.top - n.top - (t.top || 0)
    }
}
const vu = () => ({
    left: window.scrollX,
    top: window.scrollY
});

function hV(e) {
    let t;
    if ("el" in e) {
        const n = e.el,
            a = typeof n == "string" && n.startsWith("#"),
            l = typeof n == "string" ? a ? document.getElementById(n.slice(1)) : document.querySelector(n) : n;
        if (!l) return;
        t = mV(l, e)
    } else t = e;
    "scrollBehavior" in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(t.left != null ? t.left : window.scrollX, t.top != null ? t.top : window.scrollY)
}

function Hh(e, t) {
    return (history.state ? history.state.position - t : -1) + e
}
const md = new Map;

function gV(e, t) {
    md.set(e, t)
}

function yV(e) {
    const t = md.get(e);
    return md.delete(e), t
}
let bV = () => location.protocol + "//" + location.host;

function D_(e, t) {
    const {
        pathname: n,
        search: a,
        hash: l
    } = t, r = e.indexOf("#");
    if (r > -1) {
        let i = l.includes(e.slice(r)) ? e.slice(r).length : 1,
            s = l.slice(i);
        return s[0] !== "/" && (s = "/" + s), Bh(s, "")
    }
    return Bh(n, e) + a + l
}

function pV(e, t, n, a) {
    let l = [],
        r = [],
        o = null;
    const i = ({
        state: f
    }) => {
        const v = D_(e, location),
            g = n.value,
            h = t.value;
        let y = 0;
        if (f) {
            if (n.value = v, t.value = f, o && o === g) {
                o = null;
                return
            }
            y = h ? f.position - h.position : 0
        } else a(v);
        l.forEach(S => {
            S(n.value, g, {
                delta: y,
                type: Oo.pop,
                direction: y ? y > 0 ? go.forward : go.back : go.unknown
            })
        })
    };

    function s() {
        o = n.value
    }

    function u(f) {
        l.push(f);
        const v = () => {
            const g = l.indexOf(f);
            g > -1 && l.splice(g, 1)
        };
        return r.push(v), v
    }

    function c() {
        const {
            history: f
        } = window;
        f.state && f.replaceState(qe({}, f.state, {
            scroll: vu()
        }), "")
    }

    function d() {
        for (const f of r) f();
        r = [], window.removeEventListener("popstate", i), window.removeEventListener("beforeunload", c)
    }
    return window.addEventListener("popstate", i), window.addEventListener("beforeunload", c, {
        passive: !0
    }), {
        pauseListeners: s,
        listen: u,
        destroy: d
    }
}

function jh(e, t, n, a = !1, l = !1) {
    return {
        back: e,
        current: t,
        forward: n,
        replaced: a,
        position: window.history.length,
        scroll: l ? vu() : null
    }
}

function _V(e) {
    const {
        history: t,
        location: n
    } = window, a = {
        value: D_(e, n)
    }, l = {
        value: t.state
    };
    l.value || r(a.value, {
        back: null,
        current: a.value,
        forward: null,
        position: t.length - 1,
        replaced: !0,
        scroll: null
    }, !0);

    function r(s, u, c) {
        const d = e.indexOf("#"),
            f = d > -1 ? (n.host && document.querySelector("base") ? e : e.slice(d)) + s : bV() + e + s;
        try {
            t[c ? "replaceState" : "pushState"](u, "", f), l.value = u
        } catch (v) {
            console.error(v), n[c ? "replace" : "assign"](f)
        }
    }

    function o(s, u) {
        const c = qe({}, t.state, jh(l.value.back, s, l.value.forward, !0), u, {
            position: l.value.position
        });
        r(s, c, !0), a.value = s
    }

    function i(s, u) {
        const c = qe({}, l.value, t.state, {
            forward: s,
            scroll: vu()
        });
        r(c.current, c, !0);
        const d = qe({}, jh(a.value, s, null), {
            position: c.position + 1
        }, u);
        r(s, d, !1), a.value = s
    }
    return {
        location: a,
        state: l,
        push: i,
        replace: o
    }
}

function M_(e) {
    e = dV(e);
    const t = _V(e),
        n = pV(e, t.state, t.location, t.replace);

    function a(r, o = !0) {
        o || n.pauseListeners(), history.go(r)
    }
    const l = qe({
        location: "",
        base: e,
        go: a,
        createHref: vV.bind(null, e)
    }, t, n);
    return Object.defineProperty(l, "location", {
        enumerable: !0,
        get: () => t.location.value
    }), Object.defineProperty(l, "state", {
        enumerable: !0,
        get: () => t.state.value
    }), l
}

function SV(e) {
    return e = location.host ? e || location.pathname + location.search : "", e.includes("#") || (e += "#"), M_(e)
}

function wV(e) {
    return typeof e == "string" || e && typeof e == "object"
}

function N_(e) {
    return typeof e == "string" || typeof e == "symbol"
}
const $_ = Symbol("");
var Uh;
(function(e) {
    e[e.aborted = 4] = "aborted", e[e.cancelled = 8] = "cancelled", e[e.duplicated = 16] = "duplicated"
})(Uh || (Uh = {}));

function Pr(e, t) {
    return qe(new Error, {
        type: e,
        [$_]: !0
    }, t)
}

function ca(e, t) {
    return e instanceof Error && $_ in e && (t == null || !!(e.type & t))
}
const Wh = "[^/]+?",
    kV = {
        sensitive: !1,
        strict: !1,
        start: !0,
        end: !0
    },
    CV = /[.+*?^${}()[\]/\\]/g;

function xV(e, t) {
    const n = qe({}, kV, t),
        a = [];
    let l = n.start ? "^" : "";
    const r = [];
    for (const u of e) {
        const c = u.length ? [] : [90];
        n.strict && !u.length && (l += "/");
        for (let d = 0; d < u.length; d++) {
            const f = u[d];
            let v = 40 + (n.sensitive ? .25 : 0);
            if (f.type === 0) d || (l += "/"), l += f.value.replace(CV, "\\$&"), v += 40;
            else if (f.type === 1) {
                const {
                    value: g,
                    repeatable: h,
                    optional: y,
                    regexp: S
                } = f;
                r.push({
                    name: g,
                    repeatable: h,
                    optional: y
                });
                const b = S || Wh;
                if (b !== Wh) {
                    v += 10;
                    try {
                        new RegExp(`(${b})`)
                    } catch (_) {
                        throw new Error(`Invalid custom RegExp for param "${g}" (${b}): ` + _.message)
                    }
                }
                let p = h ? `((?:${b})(?:/(?:${b}))*)` : `(${b})`;
                d || (p = y && u.length < 2 ? `(?:/${p})` : "/" + p), y && (p += "?"), l += p, v += 20, y && (v += -8), h && (v += -20), b === ".*" && (v += -50)
            }
            c.push(v)
        }
        a.push(c)
    }
    if (n.strict && n.end) {
        const u = a.length - 1;
        a[u][a[u].length - 1] += .7000000000000001
    }
    n.strict || (l += "/?"), n.end ? l += "$" : n.strict && (l += "(?:/|$)");
    const o = new RegExp(l, n.sensitive ? "" : "i");

    function i(u) {
        const c = u.match(o),
            d = {};
        if (!c) return null;
        for (let f = 1; f < c.length; f++) {
            const v = c[f] || "",
                g = r[f - 1];
            d[g.name] = v && g.repeatable ? v.split("/") : v
        }
        return d
    }

    function s(u) {
        let c = "",
            d = !1;
        for (const f of e) {
            (!d || !c.endsWith("/")) && (c += "/"), d = !1;
            for (const v of f)
                if (v.type === 0) c += v.value;
                else if (v.type === 1) {
                const {
                    value: g,
                    repeatable: h,
                    optional: y
                } = v, S = g in u ? u[g] : "";
                if (Bn(S) && !h) throw new Error(`Provided param "${g}" is an array but it is not repeatable (* or + modifiers)`);
                const b = Bn(S) ? S.join("/") : S;
                if (!b)
                    if (y) f.length < 2 && (c.endsWith("/") ? c = c.slice(0, -1) : d = !0);
                    else throw new Error(`Missing required param "${g}"`);
                c += b
            }
        }
        return c || "/"
    }
    return {
        re: o,
        score: a,
        keys: r,
        parse: i,
        stringify: s
    }
}

function PV(e, t) {
    let n = 0;
    for (; n < e.length && n < t.length;) {
        const a = t[n] - e[n];
        if (a) return a;
        n++
    }
    return e.length < t.length ? e.length === 1 && e[0] === 80 ? -1 : 1 : e.length > t.length ? t.length === 1 && t[0] === 80 ? 1 : -1 : 0
}

function B_(e, t) {
    let n = 0;
    const a = e.score,
        l = t.score;
    for (; n < a.length && n < l.length;) {
        const r = PV(a[n], l[n]);
        if (r) return r;
        n++
    }
    if (Math.abs(l.length - a.length) === 1) {
        if (zh(a)) return 1;
        if (zh(l)) return -1
    }
    return l.length - a.length
}

function zh(e) {
    const t = e[e.length - 1];
    return e.length > 0 && t[t.length - 1] < 0
}
const EV = {
        type: 0,
        value: ""
    },
    IV = /[a-zA-Z0-9_]/;

function TV(e) {
    if (!e) return [
        []
    ];
    if (e === "/") return [
        [EV]
    ];
    if (!e.startsWith("/")) throw new Error(`Invalid path "${e}"`);

    function t(v) {
        throw new Error(`ERR (${n})/"${u}": ${v}`)
    }
    let n = 0,
        a = n;
    const l = [];
    let r;

    function o() {
        r && l.push(r), r = []
    }
    let i = 0,
        s, u = "",
        c = "";

    function d() {
        u && (n === 0 ? r.push({
            type: 0,
            value: u
        }) : n === 1 || n === 2 || n === 3 ? (r.length > 1 && (s === "*" || s === "+") && t(`A repeatable param (${u}) must be alone in its segment. eg: '/:ids+.`), r.push({
            type: 1,
            value: u,
            regexp: c,
            repeatable: s === "*" || s === "+",
            optional: s === "*" || s === "?"
        })) : t("Invalid state to consume buffer"), u = "")
    }

    function f() {
        u += s
    }
    for (; i < e.length;) {
        if (s = e[i++], s === "\\" && n !== 2) {
            a = n, n = 4;
            continue
        }
        switch (n) {
            case 0:
                s === "/" ? (u && d(), o()) : s === ":" ? (d(), n = 1) : f();
                break;
            case 4:
                f(), n = a;
                break;
            case 1:
                s === "(" ? n = 2 : IV.test(s) ? f() : (d(), n = 0, s !== "*" && s !== "?" && s !== "+" && i--);
                break;
            case 2:
                s === ")" ? c[c.length - 1] == "\\" ? c = c.slice(0, -1) + s : n = 3 : c += s;
                break;
            case 3:
                d(), n = 0, s !== "*" && s !== "?" && s !== "+" && i--, c = "";
                break;
            default:
                t("Unknown state");
                break
        }
    }
    return n === 2 && t(`Unfinished custom RegExp for param "${u}"`), d(), o(), l
}

function VV(e, t, n) {
    const a = xV(TV(e.path), n),
        l = qe(a, {
            record: e,
            parent: t,
            children: [],
            alias: []
        });
    return t && !l.record.aliasOf == !t.record.aliasOf && t.children.push(l), l
}

function AV(e, t) {
    const n = [],
        a = new Map;
    t = Yh({
        strict: !1,
        end: !0,
        sensitive: !1
    }, t);

    function l(d) {
        return a.get(d)
    }

    function r(d, f, v) {
        const g = !v,
            h = LV(d);
        h.aliasOf = v && v.record;
        const y = Yh(t, d),
            S = [h];
        if ("alias" in d) {
            const _ = typeof d.alias == "string" ? [d.alias] : d.alias;
            for (const w of _) S.push(qe({}, h, {
                components: v ? v.record.components : h.components,
                path: w,
                aliasOf: v ? v.record : h
            }))
        }
        let b, p;
        for (const _ of S) {
            const {
                path: w
            } = _;
            if (f && w[0] !== "/") {
                const k = f.record.path,
                    E = k[k.length - 1] === "/" ? "" : "/";
                _.path = f.record.path + (w && E + w)
            }
            if (b = VV(_, f, y), v ? v.alias.push(b) : (p = p || b, p !== b && p.alias.push(b), g && d.name && !Gh(b) && o(d.name)), F_(b) && s(b), h.children) {
                const k = h.children;
                for (let E = 0; E < k.length; E++) r(k[E], b, v && v.children[E])
            }
            v = v || b
        }
        return p ? () => {
            o(p)
        } : ho
    }

    function o(d) {
        if (N_(d)) {
            const f = a.get(d);
            f && (a.delete(d), n.splice(n.indexOf(f), 1), f.children.forEach(o), f.alias.forEach(o))
        } else {
            const f = n.indexOf(d);
            f > -1 && (n.splice(f, 1), d.record.name && a.delete(d.record.name), d.children.forEach(o), d.alias.forEach(o))
        }
    }

    function i() {
        return n
    }

    function s(d) {
        const f = DV(d, n);
        n.splice(f, 0, d), d.record.name && !Gh(d) && a.set(d.record.name, d)
    }

    function u(d, f) {
        let v, g = {},
            h, y;
        if ("name" in d && d.name) {
            if (v = a.get(d.name), !v) throw Pr(1, {
                location: d
            });
            y = v.record.name, g = qe(Kh(f.params, v.keys.filter(p => !p.optional).concat(v.parent ? v.parent.keys.filter(p => p.optional) : []).map(p => p.name)), d.params && Kh(d.params, v.keys.map(p => p.name))), h = v.stringify(g)
        } else if (d.path != null) h = d.path, v = n.find(p => p.re.test(h)), v && (g = v.parse(h), y = v.record.name);
        else {
            if (v = f.name ? a.get(f.name) : n.find(p => p.re.test(f.path)), !v) throw Pr(1, {
                location: d,
                currentLocation: f
            });
            y = v.record.name, g = qe({}, f.params, d.params), h = v.stringify(g)
        }
        const S = [];
        let b = v;
        for (; b;) S.unshift(b.record), b = b.parent;
        return {
            name: y,
            path: h,
            params: g,
            matched: S,
            meta: RV(S)
        }
    }
    e.forEach(d => r(d));

    function c() {
        n.length = 0, a.clear()
    }
    return {
        addRoute: r,
        resolve: u,
        removeRoute: o,
        clearRoutes: c,
        getRoutes: i,
        getRecordMatcher: l
    }
}

function Kh(e, t) {
    const n = {};
    for (const a of t) a in e && (n[a] = e[a]);
    return n
}

function LV(e) {
    return {
        path: e.path,
        redirect: e.redirect,
        name: e.name,
        meta: e.meta || {},
        aliasOf: void 0,
        beforeEnter: e.beforeEnter,
        props: OV(e),
        children: e.children || [],
        instances: {},
        leaveGuards: new Set,
        updateGuards: new Set,
        enterCallbacks: {},
        components: "components" in e ? e.components || null : e.component && {
            default: e.component
        }
    }
}

function OV(e) {
    const t = {},
        n = e.props || !1;
    if ("component" in e) t.default = n;
    else
        for (const a in e.components) t[a] = typeof n == "object" ? n[a] : n;
    return t
}

function Gh(e) {
    for (; e;) {
        if (e.record.aliasOf) return !0;
        e = e.parent
    }
    return !1
}

function RV(e) {
    return e.reduce((t, n) => qe(t, n.meta), {})
}

function Yh(e, t) {
    const n = {};
    for (const a in e) n[a] = a in t ? t[a] : e[a];
    return n
}

function DV(e, t) {
    let n = 0,
        a = t.length;
    for (; n !== a;) {
        const r = n + a >> 1;
        B_(e, t[r]) < 0 ? a = r : n = r + 1
    }
    const l = MV(e);
    return l && (a = t.lastIndexOf(l, a - 1)), a
}

function MV(e) {
    let t = e;
    for (; t = t.parent;)
        if (F_(t) && B_(e, t) === 0) return t
}

function F_({
    record: e
}) {
    return !!(e.name || e.components && Object.keys(e.components).length || e.redirect)
}

function NV(e) {
    const t = {};
    if (e === "" || e === "?") return t;
    const a = (e[0] === "?" ? e.slice(1) : e).split("&");
    for (let l = 0; l < a.length; ++l) {
        const r = a[l].replace(V_, " "),
            o = r.indexOf("="),
            i = Lo(o < 0 ? r : r.slice(0, o)),
            s = o < 0 ? null : Lo(r.slice(o + 1));
        if (i in t) {
            let u = t[i];
            Bn(u) || (u = t[i] = [u]), u.push(s)
        } else t[i] = s
    }
    return t
}

function qh(e) {
    let t = "";
    for (let n in e) {
        const a = e[n];
        if (n = nV(n), a == null) {
            a !== void 0 && (t += (t.length ? "&" : "") + n);
            continue
        }(Bn(a) ? a.map(r => r && vd(r)) : [a && vd(a)]).forEach(r => {
            r !== void 0 && (t += (t.length ? "&" : "") + n, r != null && (t += "=" + r))
        })
    }
    return t
}

function $V(e) {
    const t = {};
    for (const n in e) {
        const a = e[n];
        a !== void 0 && (t[n] = Bn(a) ? a.map(l => l == null ? null : "" + l) : a == null ? a : "" + a)
    }
    return t
}
const BV = Symbol(""),
    Xh = Symbol(""),
    dv = Symbol(""),
    fv = Symbol(""),
    hd = Symbol("");

function no() {
    let e = [];

    function t(a) {
        return e.push(a), () => {
            const l = e.indexOf(a);
            l > -1 && e.splice(l, 1)
        }
    }

    function n() {
        e = []
    }
    return {
        add: t,
        list: () => e.slice(),
        reset: n
    }
}

function Ha(e, t, n, a, l, r = o => o()) {
    const o = a && (a.enterCallbacks[l] = a.enterCallbacks[l] || []);
    return () => new Promise((i, s) => {
        const u = f => {
                f === !1 ? s(Pr(4, {
                    from: n,
                    to: t
                })) : f instanceof Error ? s(f) : wV(f) ? s(Pr(2, {
                    from: t,
                    to: f
                })) : (o && a.enterCallbacks[l] === o && typeof f == "function" && o.push(f), i())
            },
            c = r(() => e.call(a && a.instances[l], t, n, u));
        let d = Promise.resolve(c);
        e.length < 3 && (d = d.then(u)), d.catch(f => s(f))
    })
}

function mc(e, t, n, a, l = r => r()) {
    const r = [];
    for (const o of e)
        for (const i in o.components) {
            let s = o.components[i];
            if (!(t !== "beforeRouteEnter" && !o.instances[i]))
                if (FV(s)) {
                    const c = (s.__vccOpts || s)[t];
                    c && r.push(Ha(c, n, a, o, i, l))
                } else {
                    let u = s();
                    r.push(() => u.then(c => {
                        if (!c) return Promise.reject(new Error(`Couldn't resolve component "${i}" at "${o.path}"`));
                        const d = zT(c) ? c.default : c;
                        o.components[i] = d;
                        const v = (d.__vccOpts || d)[t];
                        return v && Ha(v, n, a, o, i, l)()
                    }))
                }
        }
    return r
}

function FV(e) {
    return typeof e == "object" || "displayName" in e || "props" in e || "__vccOpts" in e
}

function Jh(e) {
    const t = Te(dv),
        n = Te(fv),
        a = C(() => {
            const s = Ie(e.to);
            return t.resolve(s)
        }),
        l = C(() => {
            const {
                matched: s
            } = a.value, {
                length: u
            } = s, c = s[u - 1], d = n.matched;
            if (!c || !d.length) return -1;
            const f = d.findIndex(xr.bind(null, c));
            if (f > -1) return f;
            const v = Zh(s[u - 2]);
            return u > 1 && Zh(c) === v && d[d.length - 1].path !== v ? d.findIndex(xr.bind(null, s[u - 2])) : f
        }),
        r = C(() => l.value > -1 && WV(n.params, a.value.params)),
        o = C(() => l.value > -1 && l.value === n.matched.length - 1 && R_(n.params, a.value.params));

    function i(s = {}) {
        return UV(s) ? t[Ie(e.replace) ? "replace" : "push"](Ie(e.to)).catch(ho) : Promise.resolve()
    }
    return {
        route: a,
        href: C(() => a.value.href),
        isActive: r,
        isExactActive: o,
        navigate: i
    }
}
const HV = Ln({
        name: "RouterLink",
        compatConfig: {
            MODE: 3
        },
        props: {
            to: {
                type: [String, Object],
                required: !0
            },
            replace: Boolean,
            activeClass: String,
            exactActiveClass: String,
            custom: Boolean,
            ariaCurrentValue: {
                type: String,
                default: "page"
            }
        },
        useLink: Jh,
        setup(e, {
            slots: t
        }) {
            const n = mt(Jh(e)),
                {
                    options: a
                } = Te(dv),
                l = C(() => ({
                    [Qh(e.activeClass, a.linkActiveClass, "router-link-active")]: n.isActive,
                    [Qh(e.exactActiveClass, a.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive
                }));
            return () => {
                const r = t.default && t.default(n);
                return e.custom ? r : ht("a", {
                    "aria-current": n.isExactActive ? e.ariaCurrentValue : null,
                    href: n.href,
                    onClick: n.navigate,
                    class: l.value
                }, r)
            }
        }
    }),
    jV = HV;

function UV(e) {
    if (!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && !e.defaultPrevented && !(e.button !== void 0 && e.button !== 0)) {
        if (e.currentTarget && e.currentTarget.getAttribute) {
            const t = e.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(t)) return
        }
        return e.preventDefault && e.preventDefault(), !0
    }
}

function WV(e, t) {
    for (const n in t) {
        const a = t[n],
            l = e[n];
        if (typeof a == "string") {
            if (a !== l) return !1
        } else if (!Bn(l) || l.length !== a.length || a.some((r, o) => r !== l[o])) return !1
    }
    return !0
}

function Zh(e) {
    return e ? e.aliasOf ? e.aliasOf.path : e.path : ""
}
const Qh = (e, t, n) => e ? ? t ? ? n,
    zV = Ln({
        name: "RouterView",
        inheritAttrs: !1,
        props: {
            name: {
                type: String,
                default: "default"
            },
            route: Object
        },
        compatConfig: {
            MODE: 3
        },
        setup(e, {
            attrs: t,
            slots: n
        }) {
            const a = Te(hd),
                l = C(() => e.route || a.value),
                r = Te(Xh, 0),
                o = C(() => {
                    let u = Ie(r);
                    const {
                        matched: c
                    } = l.value;
                    let d;
                    for (;
                        (d = c[u]) && !d.components;) u++;
                    return u
                }),
                i = C(() => l.value.matched[o.value]);
            He(Xh, C(() => o.value + 1)), He(BV, i), He(hd, l);
            const s = Q();
            return de(() => [s.value, i.value, e.name], ([u, c, d], [f, v, g]) => {
                c && (c.instances[d] = u, v && v !== c && u && u === f && (c.leaveGuards.size || (c.leaveGuards = v.leaveGuards), c.updateGuards.size || (c.updateGuards = v.updateGuards))), u && c && (!v || !xr(c, v) || !f) && (c.enterCallbacks[d] || []).forEach(h => h(u))
            }, {
                flush: "post"
            }), () => {
                const u = l.value,
                    c = e.name,
                    d = i.value,
                    f = d && d.components[c];
                if (!f) return eg(n.default, {
                    Component: f,
                    route: u
                });
                const v = d.props[c],
                    g = v ? v === !0 ? u.params : typeof v == "function" ? v(u) : v : null,
                    y = ht(f, qe({}, g, t, {
                        onVnodeUnmounted: S => {
                            S.component.isUnmounted && (d.instances[c] = null)
                        },
                        ref: s
                    }));
                return eg(n.default, {
                    Component: y,
                    route: u
                }) || y
            }
        }
    });

function eg(e, t) {
    if (!e) return null;
    const n = e(t);
    return n.length === 1 ? n[0] : n
}
const H_ = zV;

function KV(e) {
    const t = AV(e.routes, e),
        n = e.parseQuery || NV,
        a = e.stringifyQuery || qh,
        l = e.history,
        r = no(),
        o = no(),
        i = no(),
        s = fe(Mn);
    let u = Mn;
    sr && e.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual");
    const c = fc.bind(null, G => "" + G),
        d = fc.bind(null, lV),
        f = fc.bind(null, Lo);

    function v(G, le) {
        let se, ce;
        return N_(G) ? (se = t.getRecordMatcher(G), ce = le) : ce = G, t.addRoute(ce, se)
    }

    function g(G) {
        const le = t.getRecordMatcher(G);
        le && t.removeRoute(le)
    }

    function h() {
        return t.getRoutes().map(G => G.record)
    }

    function y(G) {
        return !!t.getRecordMatcher(G)
    }

    function S(G, le) {
        if (le = qe({}, le || s.value), typeof G == "string") {
            const O = vc(n, G, le.path),
                K = t.resolve({
                    path: O.path
                }, le),
                J = l.createHref(O.fullPath);
            return qe(O, K, {
                params: f(K.params),
                hash: Lo(O.hash),
                redirectedFrom: void 0,
                href: J
            })
        }
        let se;
        if (G.path != null) se = qe({}, G, {
            path: vc(n, G.path, le.path).path
        });
        else {
            const O = qe({}, G.params);
            for (const K in O) O[K] == null && delete O[K];
            se = qe({}, G, {
                params: d(O)
            }), le.params = d(le.params)
        }
        const ce = t.resolve(se, le),
            re = G.hash || "";
        ce.params = c(f(ce.params));
        const pe = iV(a, qe({}, G, {
                hash: tV(re),
                path: ce.path
            })),
            A = l.createHref(pe);
        return qe({
            fullPath: pe,
            hash: re,
            query: a === qh ? $V(G.query) : G.query || {}
        }, ce, {
            redirectedFrom: void 0,
            href: A
        })
    }

    function b(G) {
        return typeof G == "string" ? vc(n, G, s.value.path) : qe({}, G)
    }

    function p(G, le) {
        if (u !== G) return Pr(8, {
            from: le,
            to: G
        })
    }

    function _(G) {
        return E(G)
    }

    function w(G) {
        return _(qe(b(G), {
            replace: !0
        }))
    }

    function k(G) {
        const le = G.matched[G.matched.length - 1];
        if (le && le.redirect) {
            const {
                redirect: se
            } = le;
            let ce = typeof se == "function" ? se(G) : se;
            return typeof ce == "string" && (ce = ce.includes("?") || ce.includes("#") ? ce = b(ce) : {
                path: ce
            }, ce.params = {}), qe({
                query: G.query,
                hash: G.hash,
                params: ce.path != null ? {} : G.params
            }, ce)
        }
    }

    function E(G, le) {
        const se = u = S(G),
            ce = s.value,
            re = G.state,
            pe = G.force,
            A = G.replace === !0,
            O = k(se);
        if (O) return E(qe(b(O), {
            state: typeof O == "object" ? qe({}, re, O.state) : re,
            force: pe,
            replace: A
        }), le || se);
        const K = se;
        K.redirectedFrom = le;
        let J;
        return !pe && sV(a, ce, se) && (J = Pr(16, {
            to: K,
            from: ce
        }), j(ce, ce, !0, !1)), (J ? Promise.resolve(J) : T(K, ce)).catch(X => ca(X) ? ca(X, 2) ? X : F(X) : N(X, K, ce)).then(X => {
            if (X) {
                if (ca(X, 2)) return E(qe({
                    replace: A
                }, b(X.to), {
                    state: typeof X.to == "object" ? qe({}, re, X.to.state) : re,
                    force: pe
                }), le || K)
            } else X = I(K, ce, !0, A, re);
            return V(K, ce, X), X
        })
    }

    function P(G, le) {
        const se = p(G, le);
        return se ? Promise.reject(se) : Promise.resolve()
    }

    function x(G) {
        const le = ve.values().next().value;
        return le && typeof le.runWithContext == "function" ? le.runWithContext(G) : G()
    }

    function T(G, le) {
        let se;
        const [ce, re, pe] = GV(G, le);
        se = mc(ce.reverse(), "beforeRouteLeave", G, le);
        for (const O of ce) O.leaveGuards.forEach(K => {
            se.push(Ha(K, G, le))
        });
        const A = P.bind(null, G, le);
        return se.push(A), ee(se).then(() => {
            se = [];
            for (const O of r.list()) se.push(Ha(O, G, le));
            return se.push(A), ee(se)
        }).then(() => {
            se = mc(re, "beforeRouteUpdate", G, le);
            for (const O of re) O.updateGuards.forEach(K => {
                se.push(Ha(K, G, le))
            });
            return se.push(A), ee(se)
        }).then(() => {
            se = [];
            for (const O of pe)
                if (O.beforeEnter)
                    if (Bn(O.beforeEnter))
                        for (const K of O.beforeEnter) se.push(Ha(K, G, le));
                    else se.push(Ha(O.beforeEnter, G, le));
            return se.push(A), ee(se)
        }).then(() => (G.matched.forEach(O => O.enterCallbacks = {}), se = mc(pe, "beforeRouteEnter", G, le, x), se.push(A), ee(se))).then(() => {
            se = [];
            for (const O of o.list()) se.push(Ha(O, G, le));
            return se.push(A), ee(se)
        }).catch(O => ca(O, 8) ? O : Promise.reject(O))
    }

    function V(G, le, se) {
        i.list().forEach(ce => x(() => ce(G, le, se)))
    }

    function I(G, le, se, ce, re) {
        const pe = p(G, le);
        if (pe) return pe;
        const A = le === Mn,
            O = sr ? history.state : {};
        se && (ce || A ? l.replace(G.fullPath, qe({
            scroll: A && O && O.scroll
        }, re)) : l.push(G.fullPath, re)), s.value = G, j(G, le, se, A), F()
    }
    let R;

    function B() {
        R || (R = l.listen((G, le, se) => {
            if (!we.listening) return;
            const ce = S(G),
                re = k(ce);
            if (re) {
                E(qe(re, {
                    replace: !0
                }), ce).catch(ho);
                return
            }
            u = ce;
            const pe = s.value;
            sr && gV(Hh(pe.fullPath, se.delta), vu()), T(ce, pe).catch(A => ca(A, 12) ? A : ca(A, 2) ? (E(A.to, ce).then(O => {
                ca(O, 20) && !se.delta && se.type === Oo.pop && l.go(-1, !1)
            }).catch(ho), Promise.reject()) : (se.delta && l.go(-se.delta, !1), N(A, ce, pe))).then(A => {
                A = A || I(ce, pe, !1), A && (se.delta && !ca(A, 8) ? l.go(-se.delta, !1) : se.type === Oo.pop && ca(A, 20) && l.go(-1, !1)), V(ce, pe, A)
            }).catch(ho)
        }))
    }
    let $ = no(),
        D = no(),
        z;

    function N(G, le, se) {
        F(G);
        const ce = D.list();
        return ce.length ? ce.forEach(re => re(G, le, se)) : console.error(G), Promise.reject(G)
    }

    function H() {
        return z && s.value !== Mn ? Promise.resolve() : new Promise((G, le) => {
            $.add([G, le])
        })
    }

    function F(G) {
        return z || (z = !G, B(), $.list().forEach(([le, se]) => G ? se(G) : le()), $.reset()), G
    }

    function j(G, le, se, ce) {
        const {
            scrollBehavior: re
        } = e;
        if (!sr || !re) return Promise.resolve();
        const pe = !se && yV(Hh(G.fullPath, 0)) || (ce || !se) && history.state && history.state.scroll || null;
        return Re().then(() => re(G, le, pe)).then(A => A && hV(A)).catch(A => N(A, G, le))
    }
    const ae = G => l.go(G);
    let he;
    const ve = new Set,
        we = {
            currentRoute: s,
            listening: !0,
            addRoute: v,
            removeRoute: g,
            clearRoutes: t.clearRoutes,
            hasRoute: y,
            getRoutes: h,
            resolve: S,
            options: e,
            push: _,
            replace: w,
            go: ae,
            back: () => ae(-1),
            forward: () => ae(1),
            beforeEach: r.add,
            beforeResolve: o.add,
            afterEach: i.add,
            onError: D.add,
            isReady: H,
            install(G) {
                const le = this;
                G.component("RouterLink", jV), G.component("RouterView", H_), G.config.globalProperties.$router = le, Object.defineProperty(G.config.globalProperties, "$route", {
                    enumerable: !0,
                    get: () => Ie(s)
                }), sr && !he && s.value === Mn && (he = !0, _(l.location).catch(re => {}));
                const se = {};
                for (const re in Mn) Object.defineProperty(se, re, {
                    get: () => s.value[re],
                    enumerable: !0
                });
                G.provide(dv, le), G.provide(fv, Jn(se)), G.provide(hd, s);
                const ce = G.unmount;
                ve.add(G), G.unmount = function() {
                    ve.delete(G), ve.size < 1 && (u = Mn, R && R(), R = null, s.value = Mn, he = !1, z = !1), ce()
                }
            }
        };

    function ee(G) {
        return G.reduce((le, se) => le.then(() => x(se)), Promise.resolve())
    }
    return we
}

function GV(e, t) {
    const n = [],
        a = [],
        l = [],
        r = Math.max(t.matched.length, e.matched.length);
    for (let o = 0; o < r; o++) {
        const i = t.matched[o];
        i && (e.matched.find(u => xr(u, i)) ? a.push(i) : n.push(i));
        const s = e.matched[o];
        s && (t.matched.find(u => xr(u, s)) || l.push(s))
    }
    return [n, a, l]
}

function Hj(e) {
    return Te(fv)
}
const YV = (e, t) => t.path.replace(/(:\w+)\([^)]+\)/g, "$1").replace(/(:\w+)[?+*]/g, "$1").replace(/:\w+/g, n => {
        var a;
        return ((a = e.params[n.slice(1)]) == null ? void 0 : a.toString()) || ""
    }),
    gd = (e, t) => {
        const n = e.route.matched.find(l => {
                var r;
                return ((r = l.components) == null ? void 0 : r.default) === e.Component.type
            }),
            a = t ? ? (n == null ? void 0 : n.meta.key) ? ? (n && YV(e.route, n));
        return typeof a == "function" ? a(e.route) : a
    },
    qV = (e, t) => ({
        default: () => e ? ht(ep, e === !0 ? {} : e, t) : t
    });

function vv(e) {
    return Array.isArray(e) ? e : [e]
}
const XV = "modulepreload",
    JV = function(e, t) {
        return e[0] === "." ? new URL(e, t).href : e
    },
    tg = {},
    ZV = function(t, n, a) {
        let l = Promise.resolve();
        if (n && n.length > 0) {
            const r = document.getElementsByTagName("link"),
                o = document.querySelector("meta[property=csp-nonce]"),
                i = (o == null ? void 0 : o.nonce) || (o == null ? void 0 : o.getAttribute("nonce"));
            l = Promise.all(n.map(s => {
                if (s = JV(s, a), s in tg) return;
                tg[s] = !0;
                const u = s.endsWith(".css"),
                    c = u ? '[rel="stylesheet"]' : "";
                if (!!a)
                    for (let v = r.length - 1; v >= 0; v--) {
                        const g = r[v];
                        if (g.href === s && (!u || g.rel === "stylesheet")) return
                    } else if (document.querySelector(`link[href="${s}"]${c}`)) return;
                const f = document.createElement("link");
                if (f.rel = u ? "stylesheet" : XV, u || (f.as = "script", f.crossOrigin = ""), f.href = s, i && f.setAttribute("nonce", i), document.head.appendChild(f), u) return new Promise((v, g) => {
                    f.addEventListener("load", v), f.addEventListener("error", () => g(new Error(`Unable to preload CSS for ${s}`)))
                })
            }))
        }
        return l.then(() => t()).catch(r => {
            const o = new Event("vite:preloadError", {
                cancelable: !0
            });
            if (o.payload = r, window.dispatchEvent(o), !o.defaultPrevented) throw r
        })
    },
    Je = (...e) => ZV(...e).catch(t => {
        const n = new Event("nuxt.preloadError");
        throw n.payload = t, window.dispatchEvent(n), t
    }),
    QV = {
        layout: "public"
    },
    eA = {
        layout: "default"
    },
    tA = {
        layout: "default"
    },
    nA = {
        layout: "public"
    },
    aA = {
        layout: "public"
    },
    lA = {
        layout: "public"
    },
    rA = {
        layout: "public"
    },
    oA = {
        layout: "public"
    },
    iA = {
        layout: "default"
    },
    sA = {
        layout: "public"
    },
    ng = [{
        name: "about",
        path: "/about",
        meta: QV || {},
        component: () => Je(() =>
            import ("./Hs4KDZfb.js"), __vite__mapDeps([0, 1, 2, 3, 4, 5, 6]),
            import.meta.url).then(e => e.default || e)
    }, {
        name: "account-recovery",
        path: "/account-recovery",
        meta: eA || {},
        component: () => Je(() =>
            import ("./BN0LOnJ0.js"), __vite__mapDeps([7, 8, 2, 9, 4]),
            import.meta.url).then(e => e.default || e)
    }, {
        name: "auth-logout",
        path: "/auth/logout",
        meta: tA || {},
        component: () => Je(() =>
            import ("./qqrkwCeT.js"), __vite__mapDeps([10, 11, 12, 13]),
            import.meta.url).then(e => e.default || e)
    }, {
        name: "deleteaccount",
        path: "/deleteaccount",
        meta: nA || {},
        component: () => Je(() =>
            import ("./BJFuLHGv.js"), __vite__mapDeps([14, 1, 2, 3, 15, 16, 17, 18, 19, 13, 20, 21, 4, 5, 22]),
            import.meta.url).then(e => e.default || e)
    }, {
        name: "developers",
        path: "/developers",
        meta: aA || {},
        component: () => Je(() =>
            import ("./CSy9Gn0u.js"), __vite__mapDeps([23, 1, 2, 3, 12, 13, 17, 4, 5, 24]),
            import.meta.url).then(e => e.default || e)
    }, {
        name: "faq",
        path: "/faq",
        meta: lA || {},
        component: () => Je(() =>
            import ("./xp5mA54X.js"), __vite__mapDeps([25, 4, 1, 2, 3, 17, 13, 20, 26, 5, 27]),
            import.meta.url).then(e => e.default || e)
    }, {
        name: "index",
        path: "/",
        component: () => Je(() =>
            import ("./BUj3ONqt.js"), __vite__mapDeps([28, 29, 5, 2, 12, 13, 30, 11, 31, 17, 20, 32, 16, 18, 4, 33, 34]),
            import.meta.url).then(e => e.default || e)
    }, {
        name: "locations",
        path: "/locations",
        meta: rA || {},
        component: () => Je(() =>
            import ("./C3qahrz_.js"), __vite__mapDeps([35, 1, 2, 3, 17, 13, 20, 4, 5, 36]),
            import.meta.url).then(e => e.default || e)
    }, {
        name: "service-provider",
        path: "/service-provider",
        meta: oA || {},
        component: () => Je(() =>
            import ("./CWzil_Hb.js"), __vite__mapDeps([37, 1, 2, 3, 13, 20, 17, 4, 5, 38]),
            import.meta.url).then(e => e.default || e)
    }, {
        name: "signup",
        path: "/signup",
        meta: iA || {},
        component: () => Je(() =>
            import ("./aj6_LuUv.js"), __vite__mapDeps([39, 8, 2, 9, 4]),
            import.meta.url).then(e => e.default || e)
    }, {
        name: "support",
        path: "/support",
        meta: sA || {},
        component: () => Je(() =>
            import ("./B1Uq3l9O.js"), __vite__mapDeps([40, 1, 2, 3, 15, 16, 17, 18, 19, 13, 20, 21, 4, 5, 41]),
            import.meta.url).then(e => e.default || e)
    }],
    uA = (e, t, n) => (t = t === !0 ? {} : t, {
        default: () => {
            var a;
            return t ? ht(e, t, n) : (a = n.default) == null ? void 0 : a.call(n)
        }
    });

function ag(e) {
    const t = (e == null ? void 0 : e.meta.key) ? ? e.path.replace(/(:\w+)\([^)]+\)/g, "$1").replace(/(:\w+)[?+*]/g, "$1").replace(/:\w+/g, n => {
        var a;
        return ((a = e.params[n.slice(1)]) == null ? void 0 : a.toString()) || ""
    });
    return typeof t == "function" ? t(e) : t
}

function cA(e, t) {
    return e === t || t === Mn ? !1 : ag(e) !== ag(t) ? !0 : !e.matched.every((a, l) => {
        var r, o;
        return a.components && a.components.default === ((o = (r = t.matched[l]) == null ? void 0 : r.components) == null ? void 0 : o.default)
    })
}
const dA = {
    scrollBehavior(e, t, n) {
        var u;
        const a = Ye(),
            l = ((u = Vn().options) == null ? void 0 : u.scrollBehaviorType) ? ? "auto";
        let r = n || void 0;
        const o = typeof e.meta.scrollToTop == "function" ? e.meta.scrollToTop(e, t) : e.meta.scrollToTop;
        if (!r && t && e && o !== !1 && cA(e, t) && (r = {
                left: 0,
                top: 0
            }), e.path === t.path) return t.hash && !e.hash ? {
            left: 0,
            top: 0
        } : e.hash ? {
            el: e.hash,
            top: lg(e.hash),
            behavior: l
        } : !1;
        const i = c => !!(c.meta.pageTransition ? ? ld),
            s = i(t) && i(e) ? "page:transition:finish" : "page:finish";
        return new Promise(c => {
            a.hooks.hookOnce(s, async () => {
                await new Promise(d => setTimeout(d, 0)), e.hash && (r = {
                    el: e.hash,
                    top: lg(e.hash),
                    behavior: l
                }), c(r)
            })
        })
    }
};

function lg(e) {
    try {
        const t = document.querySelector(e);
        if (t) return Number.parseFloat(getComputedStyle(t).scrollMarginTop)
    } catch {}
    return 0
}
const fA = {
        hashMode: !1,
        scrollBehaviorType: "auto"
    },
    on = { ...fA,
        ...dA
    },
    vA = async e => {
        var s;
        let t, n;
        if (!((s = e.meta) != null && s.validate)) return;
        const a = Ye(),
            l = Vn();
        if (([t, n] = Xn(() => Promise.resolve(e.meta.validate(e))), t = await t, n(), t) === !0) return;
        const o = du({
                statusCode: 404,
                statusMessage: `Page Not Found: ${e.fullPath}`,
                data: {
                    path: e.fullPath
                }
            }),
            i = l.beforeResolve(u => {
                if (i(), u === e) {
                    const c = l.afterEach(async () => {
                        c(), await a.runWithContext(() => dr(o)), window.history.pushState({}, "", e.fullPath)
                    });
                    return !1
                }
            })
    },
    mA = async e => {
        let t, n;
        const a = ([t, n] = Xn(() => uv(e.path)), t = await t, n(), t);
        if (a.redirect) return aa(a.redirect, {
            acceptRelative: !0
        }) ? (window.location.href = a.redirect, !1) : a.redirect
    },
    hA = [vA, mA],
    yo = {
        auth: () => Je(() =>
            import ("./BZ2idRkj.js"), [],
            import.meta.url)
    };

function gA(e, t, n) {
    const {
        pathname: a,
        search: l,
        hash: r
    } = t, o = e.indexOf("#");
    if (o > -1) {
        const u = r.includes(e.slice(o)) ? e.slice(o).length : 1;
        let c = r.slice(u);
        return c[0] !== "/" && (c = "/" + c), _h(c, "")
    }
    const i = _h(a, e),
        s = !n || ed(i, n, {
            trailingSlash: !0
        }) ? i : n;
    return s + (s.includes("?") ? "" : l) + r
}
const yA = Wt({
        name: "nuxt:router",
        enforce: "pre",
        async setup(e) {
            var y, S;
            let t, n, a = Ut().app.baseURL;
            on.hashMode && !a.includes("#") && (a += "#");
            const l = ((y = on.history) == null ? void 0 : y.call(on, a)) ? ? (on.hashMode ? SV(a) : M_(a)),
                r = ((S = on.routes) == null ? void 0 : S.call(on, ng)) ? ? ng;
            let o;
            const i = KV({ ...on,
                scrollBehavior: (b, p, _) => {
                    if (p === Mn) {
                        o = _;
                        return
                    }
                    if (on.scrollBehavior) {
                        if (i.options.scrollBehavior = on.scrollBehavior, "scrollRestoration" in window.history) {
                            const w = i.beforeEach(() => {
                                w(), window.history.scrollRestoration = "manual"
                            })
                        }
                        return on.scrollBehavior(b, Mn, o || _)
                    }
                },
                history: l,
                routes: r
            });
            "scrollRestoration" in window.history && (window.history.scrollRestoration = "auto"), e.vueApp.use(i);
            const s = fe(i.currentRoute.value);
            i.afterEach((b, p) => {
                s.value = p
            }), Object.defineProperty(e.vueApp.config.globalProperties, "previousRoute", {
                get: () => s.value
            });
            const u = gA(a, window.location, e.payload.path),
                c = fe(i.currentRoute.value),
                d = () => {
                    c.value = i.currentRoute.value
                };
            e.hook("page:finish", d), i.afterEach((b, p) => {
                var _, w, k, E;
                ((w = (_ = b.matched[0]) == null ? void 0 : _.components) == null ? void 0 : w.default) === ((E = (k = p.matched[0]) == null ? void 0 : k.components) == null ? void 0 : E.default) && d()
            });
            const f = {};
            for (const b in c.value) Object.defineProperty(f, b, {
                get: () => c.value[b]
            });
            e._route = Jn(f), e._middleware = e._middleware || {
                global: [],
                named: {}
            };
            const v = cu();
            i.afterEach(async (b, p, _) => {
                delete e._processingMiddleware, !e.isHydrating && v.value && await e.runWithContext(YI), _ && await e.callHook("page:loading:end"), b.matched.length === 0 && await e.runWithContext(() => dr(sd({
                    statusCode: 404,
                    fatal: !1,
                    statusMessage: `Page not found: ${b.fullPath}`,
                    data: {
                        path: b.fullPath
                    }
                })))
            });
            try {
                [t, n] = Xn(() => i.isReady()), await t, n()
            } catch (b) {
                [t, n] = Xn(() => e.runWithContext(() => dr(b))), await t, n()
            }
            const g = u !== i.currentRoute.value.fullPath ? i.resolve(u) : i.currentRoute.value;
            d();
            const h = e.payload.state._layout;
            return i.beforeEach(async (b, p) => {
                var _;
                await e.callHook("page:loading:start"), b.meta = mt(b.meta), e.isHydrating && h && !Ya(b.meta.layout) && (b.meta.layout = h), e._processingMiddleware = !0; {
                    const w = new Set([...hA, ...e._middleware.global]);
                    for (const k of b.matched) {
                        const E = k.meta.middleware;
                        if (E)
                            for (const P of vv(E)) w.add(P)
                    } {
                        const k = await e.runWithContext(() => uv(b.path));
                        if (k.appMiddleware)
                            for (const E in k.appMiddleware) k.appMiddleware[E] ? w.add(E) : w.delete(E)
                    }
                    for (const k of w) {
                        const E = typeof k == "string" ? e._middleware.named[k] || await ((_ = yo[k]) == null ? void 0 : _.call(yo).then(x => x.default || x)) : k;
                        if (!E) throw new Error(`Unknown route middleware: '${k}'.`);
                        const P = await e.runWithContext(() => E(b, p));
                        if (!e.payload.serverRendered && e.isHydrating && (P === !1 || P instanceof Error)) {
                            const x = P || sd({
                                statusCode: 404,
                                statusMessage: `Page Not Found: ${u}`
                            });
                            return await e.runWithContext(() => dr(x)), !1
                        }
                        if (P !== !0 && (P || P === !1)) return P
                    }
                }
            }), i.onError(async () => {
                delete e._processingMiddleware, await e.callHook("page:loading:end")
            }), e.hooks.hookOnce("app:created", async () => {
                try {
                    "name" in g && (g.name = void 0), await i.replace({ ...g,
                        force: !0
                    }), i.options.scrollBehavior = on.scrollBehavior
                } catch (b) {
                    await e.runWithContext(() => dr(b))
                }
            }), {
                provide: {
                    router: i
                }
            }
        }
    }),
    rg = globalThis.requestIdleCallback || (e => {
        const t = Date.now(),
            n = {
                didTimeout: !1,
                timeRemaining: () => Math.max(0, 50 - (Date.now() - t))
            };
        return setTimeout(() => {
            e(n)
        }, 1)
    }),
    jj = globalThis.cancelIdleCallback || (e => {
        clearTimeout(e)
    }),
    mv = e => {
        const t = Ye();
        t.isHydrating ? t.hooks.hookOnce("app:suspense:resolve", () => {
            rg(() => e())
        }) : rg(() => e())
    },
    bA = Wt({
        name: "nuxt:payload",
        setup(e) {
            Vn().beforeResolve(async (t, n) => {
                if (t.path === n.path) return;
                const a = await Nh(t.path);
                a && Object.assign(e.static.data, a.data)
            }), mv(() => {
                var t;
                e.hooks.hook("link:prefetch", async n => {
                    const {
                        hostname: a
                    } = new URL(n, window.location.href);
                    a === window.location.hostname && await Nh(n)
                }), ((t = navigator.connection) == null ? void 0 : t.effectiveType) !== "slow-2g" && setTimeout(fu, 1e3)
            })
        }
    }),
    pA = Wt(() => {
        const e = Vn();
        mv(() => {
            e.beforeResolve(async () => {
                await new Promise(t => {
                    setTimeout(t, 100), requestAnimationFrame(() => {
                        setTimeout(t, 0)
                    })
                })
            })
        })
    }),
    _A = Wt(e => {
        let t;
        async function n() {
            const a = await fu();
            t && clearTimeout(t), t = setTimeout(n, Ch);
            try {
                const l = await $fetch(ov("builds/latest.json") + `?${Date.now()}`);
                l.id !== a.id && e.hooks.callHook("app:manifest:update", l)
            } catch {}
        }
        mv(() => {
            t = setTimeout(n, Ch)
        })
    });

function SA(e = {}) {
    const t = e.path || window.location.pathname;
    let n = {};
    try {
        n = Ao(sessionStorage.getItem("nuxt:reload") || "{}")
    } catch {}
    if (e.force || (n == null ? void 0 : n.path) !== t || (n == null ? void 0 : n.expires) < Date.now()) {
        try {
            sessionStorage.setItem("nuxt:reload", JSON.stringify({
                path: t,
                expires: Date.now() + (e.ttl ? ? 1e4)
            }))
        } catch {}
        if (e.persistState) try {
            sessionStorage.setItem("nuxt:reload:state", JSON.stringify({
                state: Ye().payload.state
            }))
        } catch {}
        window.location.pathname !== t ? window.location.href = t : window.location.reload()
    }
}
const wA = Wt({
        name: "nuxt:chunk-reload",
        setup(e) {
            const t = Vn(),
                n = Ut(),
                a = new Set;
            t.beforeEach(() => {
                a.clear()
            }), e.hook("app:chunkError", ({
                error: r
            }) => {
                a.add(r)
            });

            function l(r) {
                const i = "href" in r && r.href[0] === "#" ? n.app.baseURL + r.href : Ur(n.app.baseURL, r.fullPath);
                SA({
                    path: i,
                    persistState: !0
                })
            }
            e.hook("app:manifest:update", () => {
                t.beforeResolve(l)
            }), t.onError((r, o) => {
                a.has(r) && l(o)
            })
        }
    }),
    kA = !1;
/*!
 * pinia v2.1.7
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */
let j_;
const ii = e => j_ = e,
    U_ = Symbol();

function yd(e) {
    return e && typeof e == "object" && Object.prototype.toString.call(e) === "[object Object]" && typeof e.toJSON != "function"
}
var bo;
(function(e) {
    e.direct = "direct", e.patchObject = "patch object", e.patchFunction = "patch function"
})(bo || (bo = {}));

function CA() {
    const e = xa(!0),
        t = e.run(() => Q({}));
    let n = [],
        a = [];
    const l = Fr({
        install(r) {
            ii(l), l._a = r, r.provide(U_, l), r.config.globalProperties.$pinia = l, a.forEach(o => n.push(o)), a = []
        },
        use(r) {
            return !this._a && !kA ? a.push(r) : n.push(r), this
        },
        _p: n,
        _a: null,
        _e: e,
        _s: new Map,
        state: t
    });
    return l
}
const W_ = () => {};

function og(e, t, n, a = W_) {
    e.push(t);
    const l = () => {
        const r = e.indexOf(t);
        r > -1 && (e.splice(r, 1), a())
    };
    return !n && $r() && kt(l), l
}

function tr(e, ...t) {
    e.slice().forEach(n => {
        n(...t)
    })
}
const xA = e => e();

function bd(e, t) {
    e instanceof Map && t instanceof Map && t.forEach((n, a) => e.set(a, n)), e instanceof Set && t instanceof Set && t.forEach(e.add, e);
    for (const n in t) {
        if (!t.hasOwnProperty(n)) continue;
        const a = t[n],
            l = e[n];
        yd(l) && yd(a) && e.hasOwnProperty(n) && !Ge(a) && !pa(a) ? e[n] = bd(l, a) : e[n] = a
    }
    return e
}
const PA = Symbol();

function EA(e) {
    return !yd(e) || !e.hasOwnProperty(PA)
}
const {
    assign: Ma
} = Object;

function IA(e) {
    return !!(Ge(e) && e.effect)
}

function TA(e, t, n, a) {
    const {
        state: l,
        actions: r,
        getters: o
    } = t, i = n.state.value[e];
    let s;

    function u() {
        i || (n.state.value[e] = l ? l() : {});
        const c = ta(n.state.value[e]);
        return Ma(c, r, Object.keys(o || {}).reduce((d, f) => (d[f] = Fr(C(() => {
            ii(n);
            const v = n._s.get(e);
            return o[f].call(v, v)
        })), d), {}))
    }
    return s = z_(e, u, t, n, a, !0), s
}

function z_(e, t, n = {}, a, l, r) {
    let o;
    const i = Ma({
            actions: {}
        }, n),
        s = {
            deep: !0
        };
    let u, c, d = [],
        f = [],
        v;
    const g = a.state.value[e];
    !r && !g && (a.state.value[e] = {}), Q({});
    let h;

    function y(P) {
        let x;
        u = c = !1, typeof P == "function" ? (P(a.state.value[e]), x = {
            type: bo.patchFunction,
            storeId: e,
            events: v
        }) : (bd(a.state.value[e], P), x = {
            type: bo.patchObject,
            payload: P,
            storeId: e,
            events: v
        });
        const T = h = Symbol();
        Re().then(() => {
            h === T && (u = !0)
        }), c = !0, tr(d, x, a.state.value[e])
    }
    const S = r ? function() {
        const {
            state: x
        } = n, T = x ? x() : {};
        this.$patch(V => {
            Ma(V, T)
        })
    } : W_;

    function b() {
        o.stop(), d = [], f = [], a._s.delete(e)
    }

    function p(P, x) {
        return function() {
            ii(a);
            const T = Array.from(arguments),
                V = [],
                I = [];

            function R(D) {
                V.push(D)
            }

            function B(D) {
                I.push(D)
            }
            tr(f, {
                args: T,
                name: P,
                store: w,
                after: R,
                onError: B
            });
            let $;
            try {
                $ = x.apply(this && this.$id === e ? this : w, T)
            } catch (D) {
                throw tr(I, D), D
            }
            return $ instanceof Promise ? $.then(D => (tr(V, D), D)).catch(D => (tr(I, D), Promise.reject(D))) : (tr(V, $), $)
        }
    }
    const _ = {
            _p: a,
            $id: e,
            $onAction: og.bind(null, f),
            $patch: y,
            $reset: S,
            $subscribe(P, x = {}) {
                const T = og(d, P, x.detached, () => V()),
                    V = o.run(() => de(() => a.state.value[e], I => {
                        (x.flush === "sync" ? c : u) && P({
                            storeId: e,
                            type: bo.direct,
                            events: v
                        }, I)
                    }, Ma({}, s, x)));
                return T
            },
            $dispose: b
        },
        w = mt(_);
    a._s.set(e, w);
    const E = (a._a && a._a.runWithContext || xA)(() => a._e.run(() => (o = xa()).run(t)));
    for (const P in E) {
        const x = E[P];
        if (Ge(x) && !IA(x) || pa(x)) r || (g && EA(x) && (Ge(x) ? x.value = g[P] : bd(x, g[P])), a.state.value[e][P] = x);
        else if (typeof x == "function") {
            const T = p(P, x);
            E[P] = T, i.actions[P] = x
        }
    }
    return Ma(w, E), Ma(xe(w), E), Object.defineProperty(w, "$state", {
        get: () => a.state.value[e],
        set: P => {
            y(x => {
                Ma(x, P)
            })
        }
    }), a._p.forEach(P => {
        Ma(w, o.run(() => P({
            store: w,
            app: a._a,
            pinia: a,
            options: i
        })))
    }), g && r && n.hydrate && n.hydrate(w.$state, g), u = !0, c = !0, w
}

function Uj(e, t, n) {
    let a, l;
    const r = typeof t == "function";
    a = e, l = r ? n : t;

    function o(i, s) {
        const u = nu();
        return i = i || (u ? Te(U_, null) : null), i && ii(i), i = j_, i._s.has(a) || (r ? z_(a, t, l, i) : TA(a, l, i)), i._s.get(a)
    }
    return o.$id = a, o
}
const VA = "$s";

function K_(...e) {
    const t = typeof e[e.length - 1] == "string" ? e.pop() : void 0;
    typeof e[0] != "string" && e.unshift(t);
    const [n, a] = e;
    if (!n || typeof n != "string") throw new TypeError("[nuxt] [useState] key must be a string: " + n);
    if (a !== void 0 && typeof a != "function") throw new Error("[nuxt] [useState] init must be a function: " + a);
    const l = VA + n,
        r = Ye(),
        o = Y(r.payload.state, l);
    if (o.value === void 0 && a) {
        const i = a();
        if (Ge(i)) return r.payload.state[l] = i, i;
        o.value = i
    }
    return o
}

function Kn(e) {
    if (typeof e != "object") return e;
    var t, n, a = Object.prototype.toString.call(e);
    if (a === "[object Object]") {
        if (e.constructor !== Object && typeof e.constructor == "function") {
            n = new e.constructor;
            for (t in e) e.hasOwnProperty(t) && n[t] !== e[t] && (n[t] = Kn(e[t]))
        } else {
            n = {};
            for (t in e) t === "__proto__" ? Object.defineProperty(n, t, {
                value: Kn(e[t]),
                configurable: !0,
                enumerable: !0,
                writable: !0
            }) : n[t] = Kn(e[t])
        }
        return n
    }
    if (a === "[object Array]") {
        for (t = e.length, n = Array(t); t--;) n[t] = Kn(e[t]);
        return n
    }
    return a === "[object Set]" ? (n = new Set, e.forEach(function(l) {
        n.add(Kn(l))
    }), n) : a === "[object Map]" ? (n = new Map, e.forEach(function(l, r) {
        n.set(Kn(r), Kn(l))
    }), n) : a === "[object Date]" ? new Date(+e) : a === "[object RegExp]" ? (n = new RegExp(e.source, e.flags), n.lastIndex = e.lastIndex, n) : a === "[object DataView]" ? new e.constructor(Kn(e.buffer)) : a === "[object ArrayBuffer]" ? e.slice(0) : a.slice(-6) === "Array]" ? new e.constructor(e) : e
}
const AA = {
        path: "/",
        watch: !0,
        decode: e => Ao(decodeURIComponent(e)),
        encode: e => encodeURIComponent(typeof e == "string" ? e : JSON.stringify(e))
    },
    hc = window.cookieStore;

function LA(e, t) {
    var s;
    const n = { ...AA,
            ...t
        },
        a = ig(n) || {};
    let l;
    n.maxAge !== void 0 ? l = n.maxAge * 1e3 : n.expires && (l = n.expires.getTime() - Date.now());
    const r = l !== void 0 && l <= 0,
        o = Kn(r ? void 0 : a[e] ? ? ((s = n.default) == null ? void 0 : s.call(n))),
        i = l && !r ? DA(o, l, n.watch && n.watch !== "shallow") : Q(o); {
        let u = null;
        try {
            !hc && typeof BroadcastChannel < "u" && (u = new BroadcastChannel(`nuxt:cookies:${e}`))
        } catch {}
        const c = () => {
                n.readonly || RI(i.value, a[e]) || (RA(e, i.value, n), a[e] = Kn(i.value), u == null || u.postMessage({
                    value: n.encode(i.value)
                }))
            },
            d = v => {
                var h;
                const g = v.refresh ? (h = ig(n)) == null ? void 0 : h[e] : n.decode(v.value);
                f = !0, a[e] = i.value = g, Re(() => {
                    f = !1
                })
            };
        let f = !1;
        $r() && kt(() => {
            f = !0, c(), u == null || u.close()
        }), hc ? hc.onchange = v => {
            const g = v.changed.find(h => h.name === e);
            g && d({
                value: g.value
            })
        } : u && (u.onmessage = ({
            data: v
        }) => d(v)), n.watch ? de(i, () => {
            f || c()
        }, {
            deep: n.watch !== "shallow"
        }) : c()
    }
    return i
}

function ig(e = {}) {
    return vI(document.cookie, e)
}

function OA(e, t, n = {}) {
    return t == null ? Ph(e, t, { ...n,
        maxAge: -1
    }) : Ph(e, t, n)
}

function RA(e, t, n = {}) {
    document.cookie = OA(e, t, n)
}
const sg = 2147483647;

function DA(e, t, n) {
    let a, l, r = 0;
    const o = n ? Q(e) : {
        value: e
    };
    return $r() && kt(() => {
        l == null || l(), clearTimeout(a)
    }), Rf((i, s) => {
        n && (l = de(o, s));

        function u() {
            r = 0, clearTimeout(a);
            const c = t - r,
                d = c < sg ? c : sg;
            a = setTimeout(() => {
                if (r += d, r < t) return u();
                o.value = void 0, s()
            }, d)
        }
        return {
            get() {
                return i(), o.value
            },
            set(c) {
                u(), o.value = c, s()
            }
        }
    })
}
const MA = Wt(e => {
        const t = CA();
        return e.vueApp.use(t), ii(t), e.payload && e.payload.pinia && (t.state.value = e.payload.pinia), {
            provide: {
                pinia: t
            }
        }
    }),
    NA = mn(() => Je(() =>
        import ("./CLNxb9WD.js"), [],
        import.meta.url).then(e => e.default || e.default || e)),
    $A = mn(() => Je(() =>
        import ("./BMaMpx8f.js"), [],
        import.meta.url).then(e => e.default || e.default || e)),
    BA = mn(() => Je(() =>
        import ("./DwB8LVhX.js"), [],
        import.meta.url).then(e => e.default || e.default || e)),
    FA = mn(() => Je(() =>
        import ("./CJzAXa1o.js"), __vite__mapDeps([42, 11]),
        import.meta.url).then(e => e.default || e.default || e)),
    HA = mn(() => Je(() =>
        import ("./CUL8VHWe.js"), __vite__mapDeps([16, 17, 2, 18]),
        import.meta.url).then(e => e.default || e.default || e)),
    jA = mn(() => Je(() =>
        import ("./CRPEHUN9.js"), __vite__mapDeps([31, 17, 20, 2, 32]),
        import.meta.url).then(e => e.default || e.default || e)),
    UA = mn(() => Je(() =>
        import ("./uLEzMdSq.js"), [],
        import.meta.url).then(e => e.default || e.default || e)),
    WA = mn(() => Je(() =>
        import ("./BqdLsTte.js"), __vite__mapDeps([43, 17, 2, 44]),
        import.meta.url).then(e => e.default || e.default || e)),
    zA = mn(() => Je(() =>
        import ("./DQQXC2SP.js"), __vite__mapDeps([45, 46, 17]),
        import.meta.url).then(e => e.default || e.default || e)),
    KA = mn(() => Je(() =>
        import ("./DfTI8JQj.js"), __vite__mapDeps([47, 46, 17]),
        import.meta.url).then(e => e.default || e.default || e)),
    GA = [
        ["AttributeChangeModal", NA],
        ["Card", $A],
        ["HtmlRenderer", BA],
        ["Loader", FA],
        ["MessageDialog", HA],
        ["Modal", jA],
        ["PageHeader", UA],
        ["ReadMore", WA],
        ["SplitActionViewLeftSection", zA],
        ["SplitActionView", KA]
    ],
    YA = Wt({
        name: "nuxt:global-components",
        setup(e) {
            for (const [t, n] of GA) e.vueApp.component(t, n), e.vueApp.component("Lazy" + t, n)
        }
    }),
    Mi = {
        default: () => Je(() =>
            import ("./BPD5qkZX.js"), __vite__mapDeps([48, 12, 13, 49, 19, 20, 17, 50]),
            import.meta.url).then(e => e.default || e),
        public: () => Je(() =>
            import ("./Y4_1m0aC.js"), __vite__mapDeps([51, 33, 29, 5, 2, 12, 13, 30, 49, 52]),
            import.meta.url).then(e => e.default || e)
    },
    qA = Wt({
        name: "nuxt:prefetch",
        setup(e) {
            const t = Vn();
            e.hooks.hook("app:mounted", () => {
                t.beforeEach(async n => {
                    var l;
                    const a = (l = n == null ? void 0 : n.meta) == null ? void 0 : l.layout;
                    a && typeof Mi[a] == "function" && await Mi[a]()
                })
            }), e.hooks.hook("link:prefetch", n => {
                if (aa(n)) return;
                const a = t.resolve(n);
                if (!a) return;
                const l = a.meta.layout;
                let r = vv(a.meta.middleware);
                r = r.filter(o => typeof o == "string");
                for (const o of r) typeof yo[o] == "function" && yo[o]();
                l && typeof Mi[l] == "function" && Mi[l]()
            })
        }
    });
var en = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

function si(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}

function XA(e) {
    if (e.__esModule) return e;
    var t = e.default;
    if (typeof t == "function") {
        var n = function a() {
            return this instanceof a ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments)
        };
        n.prototype = t.prototype
    } else n = {};
    return Object.defineProperty(n, "__esModule", {
        value: !0
    }), Object.keys(e).forEach(function(a) {
        var l = Object.getOwnPropertyDescriptor(e, a);
        Object.defineProperty(n, a, l.get ? l : {
            enumerable: !0,
            get: function() {
                return e[a]
            }
        })
    }), n
}
var G_ = {
    exports: {}
};
(function(e, t) {
    (function(n, a) {
        e.exports = a()
    })(en, function() {
        var n = 1e3,
            a = 6e4,
            l = 36e5,
            r = "millisecond",
            o = "second",
            i = "minute",
            s = "hour",
            u = "day",
            c = "week",
            d = "month",
            f = "quarter",
            v = "year",
            g = "date",
            h = "Invalid Date",
            y = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
            S = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
            b = {
                name: "en",
                weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                ordinal: function(B) {
                    var $ = ["th", "st", "nd", "rd"],
                        D = B % 100;
                    return "[" + B + ($[(D - 20) % 10] || $[D] || $[0]) + "]"
                }
            },
            p = function(B, $, D) {
                var z = String(B);
                return !z || z.length >= $ ? B : "" + Array($ + 1 - z.length).join(D) + B
            },
            _ = {
                s: p,
                z: function(B) {
                    var $ = -B.utcOffset(),
                        D = Math.abs($),
                        z = Math.floor(D / 60),
                        N = D % 60;
                    return ($ <= 0 ? "+" : "-") + p(z, 2, "0") + ":" + p(N, 2, "0")
                },
                m: function B($, D) {
                    if ($.date() < D.date()) return -B(D, $);
                    var z = 12 * (D.year() - $.year()) + (D.month() - $.month()),
                        N = $.clone().add(z, d),
                        H = D - N < 0,
                        F = $.clone().add(z + (H ? -1 : 1), d);
                    return +(-(z + (D - N) / (H ? N - F : F - N)) || 0)
                },
                a: function(B) {
                    return B < 0 ? Math.ceil(B) || 0 : Math.floor(B)
                },
                p: function(B) {
                    return {
                        M: d,
                        y: v,
                        w: c,
                        d: u,
                        D: g,
                        h: s,
                        m: i,
                        s: o,
                        ms: r,
                        Q: f
                    }[B] || String(B || "").toLowerCase().replace(/s$/, "")
                },
                u: function(B) {
                    return B === void 0
                }
            },
            w = "en",
            k = {};
        k[w] = b;
        var E = "$isDayjsObject",
            P = function(B) {
                return B instanceof I || !(!B || !B[E])
            },
            x = function B($, D, z) {
                var N;
                if (!$) return w;
                if (typeof $ == "string") {
                    var H = $.toLowerCase();
                    k[H] && (N = H), D && (k[H] = D, N = H);
                    var F = $.split("-");
                    if (!N && F.length > 1) return B(F[0])
                } else {
                    var j = $.name;
                    k[j] = $, N = j
                }
                return !z && N && (w = N), N || !z && w
            },
            T = function(B, $) {
                if (P(B)) return B.clone();
                var D = typeof $ == "object" ? $ : {};
                return D.date = B, D.args = arguments, new I(D)
            },
            V = _;
        V.l = x, V.i = P, V.w = function(B, $) {
            return T(B, {
                locale: $.$L,
                utc: $.$u,
                x: $.$x,
                $offset: $.$offset
            })
        };
        var I = function() {
                function B(D) {
                    this.$L = x(D.locale, null, !0), this.parse(D), this.$x = this.$x || D.x || {}, this[E] = !0
                }
                var $ = B.prototype;
                return $.parse = function(D) {
                    this.$d = function(z) {
                        var N = z.date,
                            H = z.utc;
                        if (N === null) return new Date(NaN);
                        if (V.u(N)) return new Date;
                        if (N instanceof Date) return new Date(N);
                        if (typeof N == "string" && !/Z$/i.test(N)) {
                            var F = N.match(y);
                            if (F) {
                                var j = F[2] - 1 || 0,
                                    ae = (F[7] || "0").substring(0, 3);
                                return H ? new Date(Date.UTC(F[1], j, F[3] || 1, F[4] || 0, F[5] || 0, F[6] || 0, ae)) : new Date(F[1], j, F[3] || 1, F[4] || 0, F[5] || 0, F[6] || 0, ae)
                            }
                        }
                        return new Date(N)
                    }(D), this.init()
                }, $.init = function() {
                    var D = this.$d;
                    this.$y = D.getFullYear(), this.$M = D.getMonth(), this.$D = D.getDate(), this.$W = D.getDay(), this.$H = D.getHours(), this.$m = D.getMinutes(), this.$s = D.getSeconds(), this.$ms = D.getMilliseconds()
                }, $.$utils = function() {
                    return V
                }, $.isValid = function() {
                    return this.$d.toString() !== h
                }, $.isSame = function(D, z) {
                    var N = T(D);
                    return this.startOf(z) <= N && N <= this.endOf(z)
                }, $.isAfter = function(D, z) {
                    return T(D) < this.startOf(z)
                }, $.isBefore = function(D, z) {
                    return this.endOf(z) < T(D)
                }, $.$g = function(D, z, N) {
                    return V.u(D) ? this[z] : this.set(N, D)
                }, $.unix = function() {
                    return Math.floor(this.valueOf() / 1e3)
                }, $.valueOf = function() {
                    return this.$d.getTime()
                }, $.startOf = function(D, z) {
                    var N = this,
                        H = !!V.u(z) || z,
                        F = V.p(D),
                        j = function(se, ce) {
                            var re = V.w(N.$u ? Date.UTC(N.$y, ce, se) : new Date(N.$y, ce, se), N);
                            return H ? re : re.endOf(u)
                        },
                        ae = function(se, ce) {
                            return V.w(N.toDate()[se].apply(N.toDate("s"), (H ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(ce)), N)
                        },
                        he = this.$W,
                        ve = this.$M,
                        we = this.$D,
                        ee = "set" + (this.$u ? "UTC" : "");
                    switch (F) {
                        case v:
                            return H ? j(1, 0) : j(31, 11);
                        case d:
                            return H ? j(1, ve) : j(0, ve + 1);
                        case c:
                            var G = this.$locale().weekStart || 0,
                                le = (he < G ? he + 7 : he) - G;
                            return j(H ? we - le : we + (6 - le), ve);
                        case u:
                        case g:
                            return ae(ee + "Hours", 0);
                        case s:
                            return ae(ee + "Minutes", 1);
                        case i:
                            return ae(ee + "Seconds", 2);
                        case o:
                            return ae(ee + "Milliseconds", 3);
                        default:
                            return this.clone()
                    }
                }, $.endOf = function(D) {
                    return this.startOf(D, !1)
                }, $.$set = function(D, z) {
                    var N, H = V.p(D),
                        F = "set" + (this.$u ? "UTC" : ""),
                        j = (N = {}, N[u] = F + "Date", N[g] = F + "Date", N[d] = F + "Month", N[v] = F + "FullYear", N[s] = F + "Hours", N[i] = F + "Minutes", N[o] = F + "Seconds", N[r] = F + "Milliseconds", N)[H],
                        ae = H === u ? this.$D + (z - this.$W) : z;
                    if (H === d || H === v) {
                        var he = this.clone().set(g, 1);
                        he.$d[j](ae), he.init(), this.$d = he.set(g, Math.min(this.$D, he.daysInMonth())).$d
                    } else j && this.$d[j](ae);
                    return this.init(), this
                }, $.set = function(D, z) {
                    return this.clone().$set(D, z)
                }, $.get = function(D) {
                    return this[V.p(D)]()
                }, $.add = function(D, z) {
                    var N, H = this;
                    D = Number(D);
                    var F = V.p(z),
                        j = function(ve) {
                            var we = T(H);
                            return V.w(we.date(we.date() + Math.round(ve * D)), H)
                        };
                    if (F === d) return this.set(d, this.$M + D);
                    if (F === v) return this.set(v, this.$y + D);
                    if (F === u) return j(1);
                    if (F === c) return j(7);
                    var ae = (N = {}, N[i] = a, N[s] = l, N[o] = n, N)[F] || 1,
                        he = this.$d.getTime() + D * ae;
                    return V.w(he, this)
                }, $.subtract = function(D, z) {
                    return this.add(-1 * D, z)
                }, $.format = function(D) {
                    var z = this,
                        N = this.$locale();
                    if (!this.isValid()) return N.invalidDate || h;
                    var H = D || "YYYY-MM-DDTHH:mm:ssZ",
                        F = V.z(this),
                        j = this.$H,
                        ae = this.$m,
                        he = this.$M,
                        ve = N.weekdays,
                        we = N.months,
                        ee = N.meridiem,
                        G = function(ce, re, pe, A) {
                            return ce && (ce[re] || ce(z, H)) || pe[re].slice(0, A)
                        },
                        le = function(ce) {
                            return V.s(j % 12 || 12, ce, "0")
                        },
                        se = ee || function(ce, re, pe) {
                            var A = ce < 12 ? "AM" : "PM";
                            return pe ? A.toLowerCase() : A
                        };
                    return H.replace(S, function(ce, re) {
                        return re || function(pe) {
                            switch (pe) {
                                case "YY":
                                    return String(z.$y).slice(-2);
                                case "YYYY":
                                    return V.s(z.$y, 4, "0");
                                case "M":
                                    return he + 1;
                                case "MM":
                                    return V.s(he + 1, 2, "0");
                                case "MMM":
                                    return G(N.monthsShort, he, we, 3);
                                case "MMMM":
                                    return G(we, he);
                                case "D":
                                    return z.$D;
                                case "DD":
                                    return V.s(z.$D, 2, "0");
                                case "d":
                                    return String(z.$W);
                                case "dd":
                                    return G(N.weekdaysMin, z.$W, ve, 2);
                                case "ddd":
                                    return G(N.weekdaysShort, z.$W, ve, 3);
                                case "dddd":
                                    return ve[z.$W];
                                case "H":
                                    return String(j);
                                case "HH":
                                    return V.s(j, 2, "0");
                                case "h":
                                    return le(1);
                                case "hh":
                                    return le(2);
                                case "a":
                                    return se(j, ae, !0);
                                case "A":
                                    return se(j, ae, !1);
                                case "m":
                                    return String(ae);
                                case "mm":
                                    return V.s(ae, 2, "0");
                                case "s":
                                    return String(z.$s);
                                case "ss":
                                    return V.s(z.$s, 2, "0");
                                case "SSS":
                                    return V.s(z.$ms, 3, "0");
                                case "Z":
                                    return F
                            }
                            return null
                        }(ce) || F.replace(":", "")
                    })
                }, $.utcOffset = function() {
                    return 15 * -Math.round(this.$d.getTimezoneOffset() / 15)
                }, $.diff = function(D, z, N) {
                    var H, F = this,
                        j = V.p(z),
                        ae = T(D),
                        he = (ae.utcOffset() - this.utcOffset()) * a,
                        ve = this - ae,
                        we = function() {
                            return V.m(F, ae)
                        };
                    switch (j) {
                        case v:
                            H = we() / 12;
                            break;
                        case d:
                            H = we();
                            break;
                        case f:
                            H = we() / 3;
                            break;
                        case c:
                            H = (ve - he) / 6048e5;
                            break;
                        case u:
                            H = (ve - he) / 864e5;
                            break;
                        case s:
                            H = ve / l;
                            break;
                        case i:
                            H = ve / a;
                            break;
                        case o:
                            H = ve / n;
                            break;
                        default:
                            H = ve
                    }
                    return N ? H : V.a(H)
                }, $.daysInMonth = function() {
                    return this.endOf(d).$D
                }, $.$locale = function() {
                    return k[this.$L]
                }, $.locale = function(D, z) {
                    if (!D) return this.$L;
                    var N = this.clone(),
                        H = x(D, z, !0);
                    return H && (N.$L = H), N
                }, $.clone = function() {
                    return V.w(this.$d, this)
                }, $.toDate = function() {
                    return new Date(this.valueOf())
                }, $.toJSON = function() {
                    return this.isValid() ? this.toISOString() : null
                }, $.toISOString = function() {
                    return this.$d.toISOString()
                }, $.toString = function() {
                    return this.$d.toUTCString()
                }, B
            }(),
            R = I.prototype;
        return T.prototype = R, [
            ["$ms", r],
            ["$s", o],
            ["$m", i],
            ["$H", s],
            ["$W", u],
            ["$M", d],
            ["$y", v],
            ["$D", g]
        ].forEach(function(B) {
            R[B[1]] = function($) {
                return this.$g($, B[0], B[1])
            }
        }), T.extend = function(B, $) {
            return B.$i || (B($, I, T), B.$i = !0), T
        }, T.locale = x, T.isDayjs = P, T.unix = function(B) {
            return T(1e3 * B)
        }, T.en = k[w], T.Ls = k, T.p = {}, T
    })
})(G_);
var JA = G_.exports;
const jl = si(JA);
var Y_ = {
    exports: {}
};
(function(e, t) {
    (function(n, a) {
        e.exports = a()
    })(en, function() {
        return function(n, a, l) {
            l.updateLocale = function(r, o) {
                var i = l.Ls[r];
                if (i) return (o ? Object.keys(o) : []).forEach(function(s) {
                    i[s] = o[s]
                }), i
            }
        }
    })
})(Y_);
var ZA = Y_.exports;
const QA = si(ZA);
var eL = {
    exports: {}
};
(function(e, t) {
    (function(n, a) {
        e.exports = a()
    })(en, function() {
        return {
            name: "en",
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            ordinal: function(n) {
                var a = ["th", "st", "nd", "rd"],
                    l = n % 100;
                return "[" + n + (a[(l - 20) % 10] || a[l] || a[0]) + "]"
            }
        }
    })
})(eL);
var q_ = {
    exports: {}
};
(function(e, t) {
    (function(n, a) {
        e.exports = a()
    })(en, function() {
        return function(n, a, l) {
            n = n || {};
            var r = a.prototype,
                o = {
                    future: "in %s",
                    past: "%s ago",
                    s: "a few seconds",
                    m: "a minute",
                    mm: "%d minutes",
                    h: "an hour",
                    hh: "%d hours",
                    d: "a day",
                    dd: "%d days",
                    M: "a month",
                    MM: "%d months",
                    y: "a year",
                    yy: "%d years"
                };

            function i(u, c, d, f) {
                return r.fromToBase(u, c, d, f)
            }
            l.en.relativeTime = o, r.fromToBase = function(u, c, d, f, v) {
                for (var g, h, y, S = d.$locale().relativeTime || o, b = n.thresholds || [{
                        l: "s",
                        r: 44,
                        d: "second"
                    }, {
                        l: "m",
                        r: 89
                    }, {
                        l: "mm",
                        r: 44,
                        d: "minute"
                    }, {
                        l: "h",
                        r: 89
                    }, {
                        l: "hh",
                        r: 21,
                        d: "hour"
                    }, {
                        l: "d",
                        r: 35
                    }, {
                        l: "dd",
                        r: 25,
                        d: "day"
                    }, {
                        l: "M",
                        r: 45
                    }, {
                        l: "MM",
                        r: 10,
                        d: "month"
                    }, {
                        l: "y",
                        r: 17
                    }, {
                        l: "yy",
                        d: "year"
                    }], p = b.length, _ = 0; _ < p; _ += 1) {
                    var w = b[_];
                    w.d && (g = f ? l(u).diff(d, w.d, !0) : d.diff(u, w.d, !0));
                    var k = (n.rounding || Math.round)(Math.abs(g));
                    if (y = g > 0, k <= w.r || !w.r) {
                        k <= 1 && _ > 0 && (w = b[_ - 1]);
                        var E = S[w.l];
                        v && (k = v("" + k)), h = typeof E == "string" ? E.replace("%d", k) : E(k, c, w.l, y);
                        break
                    }
                }
                if (c) return h;
                var P = y ? S.future : S.past;
                return typeof P == "function" ? P(h) : P.replace("%s", h)
            }, r.to = function(u, c) {
                return i(u, c, this, !0)
            }, r.from = function(u, c) {
                return i(u, c, this)
            };
            var s = function(u) {
                return u.$u ? l.utc() : l()
            };
            r.toNow = function(u) {
                return this.to(s(this), u)
            }, r.fromNow = function(u) {
                return this.from(s(this), u)
            }
        }
    })
})(q_);
var tL = q_.exports;
const nL = si(tL);
var X_ = {
    exports: {}
};
(function(e, t) {
    (function(n, a) {
        e.exports = a()
    })(en, function() {
        var n = "minute",
            a = /[+-]\d\d(?::?\d\d)?/g,
            l = /([+-]|\d\d)/g;
        return function(r, o, i) {
            var s = o.prototype;
            i.utc = function(h) {
                var y = {
                    date: h,
                    utc: !0,
                    args: arguments
                };
                return new o(y)
            }, s.utc = function(h) {
                var y = i(this.toDate(), {
                    locale: this.$L,
                    utc: !0
                });
                return h ? y.add(this.utcOffset(), n) : y
            }, s.local = function() {
                return i(this.toDate(), {
                    locale: this.$L,
                    utc: !1
                })
            };
            var u = s.parse;
            s.parse = function(h) {
                h.utc && (this.$u = !0), this.$utils().u(h.$offset) || (this.$offset = h.$offset), u.call(this, h)
            };
            var c = s.init;
            s.init = function() {
                if (this.$u) {
                    var h = this.$d;
                    this.$y = h.getUTCFullYear(), this.$M = h.getUTCMonth(), this.$D = h.getUTCDate(), this.$W = h.getUTCDay(), this.$H = h.getUTCHours(), this.$m = h.getUTCMinutes(), this.$s = h.getUTCSeconds(), this.$ms = h.getUTCMilliseconds()
                } else c.call(this)
            };
            var d = s.utcOffset;
            s.utcOffset = function(h, y) {
                var S = this.$utils().u;
                if (S(h)) return this.$u ? 0 : S(this.$offset) ? d.call(this) : this.$offset;
                if (typeof h == "string" && (h = function(w) {
                        w === void 0 && (w = "");
                        var k = w.match(a);
                        if (!k) return null;
                        var E = ("" + k[0]).match(l) || ["-", 0, 0],
                            P = E[0],
                            x = 60 * +E[1] + +E[2];
                        return x === 0 ? 0 : P === "+" ? x : -x
                    }(h), h === null)) return this;
                var b = Math.abs(h) <= 16 ? 60 * h : h,
                    p = this;
                if (y) return p.$offset = b, p.$u = h === 0, p;
                if (h !== 0) {
                    var _ = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
                    (p = this.local().add(b + _, n)).$offset = b, p.$x.$localOffset = _
                } else p = this.utc();
                return p
            };
            var f = s.format;
            s.format = function(h) {
                var y = h || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
                return f.call(this, y)
            }, s.valueOf = function() {
                var h = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
                return this.$d.valueOf() - 6e4 * h
            }, s.isUTC = function() {
                return !!this.$u
            }, s.toISOString = function() {
                return this.toDate().toISOString()
            }, s.toString = function() {
                return this.toDate().toUTCString()
            };
            var v = s.toDate;
            s.toDate = function(h) {
                return h === "s" && this.$offset ? i(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : v.call(this)
            };
            var g = s.diff;
            s.diff = function(h, y, S) {
                if (h && this.$u === h.$u) return g.call(this, h, y, S);
                var b = this.local(),
                    p = i(h).local();
                return g.call(b, p, y, S)
            }
        }
    })
})(X_);
var aL = X_.exports;
const lL = si(aL);
var J_ = {
    exports: {}
};
(function(e, t) {
    (function(n, a) {
        e.exports = a()
    })(en, function() {
        var n = {
                year: 0,
                month: 1,
                day: 2,
                hour: 3,
                minute: 4,
                second: 5
            },
            a = {};
        return function(l, r, o) {
            var i, s = function(f, v, g) {
                    g === void 0 && (g = {});
                    var h = new Date(f),
                        y = function(S, b) {
                            b === void 0 && (b = {});
                            var p = b.timeZoneName || "short",
                                _ = S + "|" + p,
                                w = a[_];
                            return w || (w = new Intl.DateTimeFormat("en-US", {
                                hour12: !1,
                                timeZone: S,
                                year: "numeric",
                                month: "2-digit",
                                day: "2-digit",
                                hour: "2-digit",
                                minute: "2-digit",
                                second: "2-digit",
                                timeZoneName: p
                            }), a[_] = w), w
                        }(v, g);
                    return y.formatToParts(h)
                },
                u = function(f, v) {
                    for (var g = s(f, v), h = [], y = 0; y < g.length; y += 1) {
                        var S = g[y],
                            b = S.type,
                            p = S.value,
                            _ = n[b];
                        _ >= 0 && (h[_] = parseInt(p, 10))
                    }
                    var w = h[3],
                        k = w === 24 ? 0 : w,
                        E = h[0] + "-" + h[1] + "-" + h[2] + " " + k + ":" + h[4] + ":" + h[5] + ":000",
                        P = +f;
                    return (o.utc(E).valueOf() - (P -= P % 1e3)) / 6e4
                },
                c = r.prototype;
            c.tz = function(f, v) {
                f === void 0 && (f = i);
                var g = this.utcOffset(),
                    h = this.toDate(),
                    y = h.toLocaleString("en-US", {
                        timeZone: f
                    }),
                    S = Math.round((h - new Date(y)) / 1e3 / 60),
                    b = o(y, {
                        locale: this.$L
                    }).$set("millisecond", this.$ms).utcOffset(15 * -Math.round(h.getTimezoneOffset() / 15) - S, !0);
                if (v) {
                    var p = b.utcOffset();
                    b = b.add(g - p, "minute")
                }
                return b.$x.$timezone = f, b
            }, c.offsetName = function(f) {
                var v = this.$x.$timezone || o.tz.guess(),
                    g = s(this.valueOf(), v, {
                        timeZoneName: f
                    }).find(function(h) {
                        return h.type.toLowerCase() === "timezonename"
                    });
                return g && g.value
            };
            var d = c.startOf;
            c.startOf = function(f, v) {
                if (!this.$x || !this.$x.$timezone) return d.call(this, f, v);
                var g = o(this.format("YYYY-MM-DD HH:mm:ss:SSS"), {
                    locale: this.$L
                });
                return d.call(g, f, v).tz(this.$x.$timezone, !0)
            }, o.tz = function(f, v, g) {
                var h = g && v,
                    y = g || v || i,
                    S = u(+o(), y);
                if (typeof f != "string") return o(f).tz(y);
                var b = function(k, E, P) {
                        var x = k - 60 * E * 1e3,
                            T = u(x, P);
                        if (E === T) return [x, E];
                        var V = u(x -= 60 * (T - E) * 1e3, P);
                        return T === V ? [x, T] : [k - 60 * Math.min(T, V) * 1e3, Math.max(T, V)]
                    }(o.utc(f, h).valueOf(), S, y),
                    p = b[0],
                    _ = b[1],
                    w = o(p).utcOffset(_);
                return w.$x.$timezone = y, w
            }, o.tz.guess = function() {
                return Intl.DateTimeFormat().resolvedOptions().timeZone
            }, o.tz.setDefault = function(f) {
                i = f
            }
        }
    })
})(J_);
var rL = J_.exports;
const oL = si(rL);
jl.extend(QA);
jl.extend(nL);
jl.extend(lL);
jl.extend(oL);
jl.updateLocale("en");
jl.locale("en");
const iL = Wt(async e => e.provide("dayjs", jl));
/*!
 * shared v9.13.1
 * (c) 2024 kazuya kawaguchi
 * Released under the MIT License.
 */
const Ss = typeof window < "u",
    el = (e, t = !1) => t ? Symbol.for(e) : Symbol(e),
    sL = (e, t, n) => uL({
        l: e,
        k: t,
        s: n
    }),
    uL = e => JSON.stringify(e).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027"),
    At = e => typeof e == "number" && isFinite(e),
    cL = e => Q_(e) === "[object Date]",
    ws = e => Q_(e) === "[object RegExp]",
    mu = e => Fe(e) && Object.keys(e).length === 0,
    yt = Object.assign;
let ug;
const hv = () => ug || (ug = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});

function cg(e) {
    return e.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;")
}
const dL = Object.prototype.hasOwnProperty;

function ks(e, t) {
    return dL.call(e, t)
}
const gt = Array.isArray,
    Ze = e => typeof e == "function",
    ke = e => typeof e == "string",
    dt = e => typeof e == "boolean",
    fL = e => typeof e == "symbol",
    $e = e => e !== null && typeof e == "object",
    vL = e => $e(e) && Ze(e.then) && Ze(e.catch),
    Z_ = Object.prototype.toString,
    Q_ = e => Z_.call(e),
    Fe = e => {
        if (!$e(e)) return !1;
        const t = Object.getPrototypeOf(e);
        return t === null || t.constructor === Object
    },
    mL = e => e == null ? "" : gt(e) || Fe(e) && e.toString === Z_ ? JSON.stringify(e, null, 2) : String(e);

function gv(e, t = "") {
    return e.reduce((n, a, l) => l === 0 ? n + a : n + t + a, "")
}

function hu(e) {
    let t = e;
    return () => ++t
}

function hL(e, t) {
    typeof console < "u" && (console.warn("[intlify] " + e), t && console.warn(t.stack))
}
const Ni = e => !$e(e) || gt(e);

function kl(e, t) {
    if (Ni(e) || Ni(t)) throw new Error("Invalid value");
    const n = [{
        src: e,
        des: t
    }];
    for (; n.length;) {
        const {
            src: a,
            des: l
        } = n.pop();
        Object.keys(a).forEach(r => {
            Ni(a[r]) || Ni(l[r]) ? l[r] = a[r] : n.push({
                src: a[r],
                des: l[r]
            })
        })
    }
}
/*!
 * message-compiler v9.13.1
 * (c) 2024 kazuya kawaguchi
 * Released under the MIT License.
 */
function gL(e, t, n) {
    return {
        line: e,
        column: t,
        offset: n
    }
}

function Cs(e, t, n) {
    return {
        start: e,
        end: t
    }
}
const e0 = {
    USE_MODULO_SYNTAX: 1,
    __EXTEND_POINT__: 2
};

function yL(e, t, ...n) {
    const l = {
        message: String(e),
        code: e
    };
    return t && (l.location = t), l
}
const ze = {
    EXPECTED_TOKEN: 1,
    INVALID_TOKEN_IN_PLACEHOLDER: 2,
    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
    UNKNOWN_ESCAPE_SEQUENCE: 4,
    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
    UNBALANCED_CLOSING_BRACE: 6,
    UNTERMINATED_CLOSING_BRACE: 7,
    EMPTY_PLACEHOLDER: 8,
    NOT_ALLOW_NEST_PLACEHOLDER: 9,
    INVALID_LINKED_FORMAT: 10,
    MUST_HAVE_MESSAGES_IN_PLURAL: 11,
    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
    UNEXPECTED_EMPTY_LINKED_KEY: 13,
    UNEXPECTED_LEXICAL_ANALYSIS: 14,
    UNHANDLED_CODEGEN_NODE_TYPE: 15,
    UNHANDLED_MINIFIER_NODE_TYPE: 16,
    __EXTEND_POINT__: 17
};

function gu(e, t, n = {}) {
    const {
        domain: a,
        messages: l,
        args: r
    } = n, o = e, i = new SyntaxError(String(o));
    return i.code = e, t && (i.location = t), i.domain = a, i
}

function bL(e) {
    throw e
}
const da = " ",
    pL = "\r",
    Gt = `
`,
    _L = "\u2028",
    SL = "\u2029";

function wL(e) {
    const t = e;
    let n = 0,
        a = 1,
        l = 1,
        r = 0;
    const o = E => t[E] === pL && t[E + 1] === Gt,
        i = E => t[E] === Gt,
        s = E => t[E] === SL,
        u = E => t[E] === _L,
        c = E => o(E) || i(E) || s(E) || u(E),
        d = () => n,
        f = () => a,
        v = () => l,
        g = () => r,
        h = E => o(E) || s(E) || u(E) ? Gt : t[E],
        y = () => h(n),
        S = () => h(n + r);

    function b() {
        return r = 0, c(n) && (a++, l = 0), o(n) && n++, n++, l++, t[n]
    }

    function p() {
        return o(n + r) && r++, r++, t[n + r]
    }

    function _() {
        n = 0, a = 1, l = 1, r = 0
    }

    function w(E = 0) {
        r = E
    }

    function k() {
        const E = n + r;
        for (; E !== n;) b();
        r = 0
    }
    return {
        index: d,
        line: f,
        column: v,
        peekOffset: g,
        charAt: h,
        currentChar: y,
        currentPeek: S,
        next: b,
        peek: p,
        reset: _,
        resetPeek: w,
        skipToPeek: k
    }
}
const Ra = void 0,
    kL = ".",
    dg = "'",
    CL = "tokenizer";

function xL(e, t = {}) {
    const n = t.location !== !1,
        a = wL(e),
        l = () => a.index(),
        r = () => gL(a.line(), a.column(), a.index()),
        o = r(),
        i = l(),
        s = {
            currentType: 14,
            offset: i,
            startLoc: o,
            endLoc: o,
            lastType: 14,
            lastOffset: i,
            lastStartLoc: o,
            lastEndLoc: o,
            braceNest: 0,
            inLinked: !1,
            text: ""
        },
        u = () => s,
        {
            onError: c
        } = t;

    function d(L, M, U, ...ie) {
        const _e = u();
        if (M.column += U, M.offset += U, c) {
            const me = n ? Cs(_e.startLoc, M) : null,
                q = gu(L, me, {
                    domain: CL,
                    args: ie
                });
            c(q)
        }
    }

    function f(L, M, U) {
        L.endLoc = r(), L.currentType = M;
        const ie = {
            type: M
        };
        return n && (ie.loc = Cs(L.startLoc, L.endLoc)), U != null && (ie.value = U), ie
    }
    const v = L => f(L, 14);

    function g(L, M) {
        return L.currentChar() === M ? (L.next(), M) : (d(ze.EXPECTED_TOKEN, r(), 0, M), "")
    }

    function h(L) {
        let M = "";
        for (; L.currentPeek() === da || L.currentPeek() === Gt;) M += L.currentPeek(), L.peek();
        return M
    }

    function y(L) {
        const M = h(L);
        return L.skipToPeek(), M
    }

    function S(L) {
        if (L === Ra) return !1;
        const M = L.charCodeAt(0);
        return M >= 97 && M <= 122 || M >= 65 && M <= 90 || M === 95
    }

    function b(L) {
        if (L === Ra) return !1;
        const M = L.charCodeAt(0);
        return M >= 48 && M <= 57
    }

    function p(L, M) {
        const {
            currentType: U
        } = M;
        if (U !== 2) return !1;
        h(L);
        const ie = S(L.currentPeek());
        return L.resetPeek(), ie
    }

    function _(L, M) {
        const {
            currentType: U
        } = M;
        if (U !== 2) return !1;
        h(L);
        const ie = L.currentPeek() === "-" ? L.peek() : L.currentPeek(),
            _e = b(ie);
        return L.resetPeek(), _e
    }

    function w(L, M) {
        const {
            currentType: U
        } = M;
        if (U !== 2) return !1;
        h(L);
        const ie = L.currentPeek() === dg;
        return L.resetPeek(), ie
    }

    function k(L, M) {
        const {
            currentType: U
        } = M;
        if (U !== 8) return !1;
        h(L);
        const ie = L.currentPeek() === ".";
        return L.resetPeek(), ie
    }

    function E(L, M) {
        const {
            currentType: U
        } = M;
        if (U !== 9) return !1;
        h(L);
        const ie = S(L.currentPeek());
        return L.resetPeek(), ie
    }

    function P(L, M) {
        const {
            currentType: U
        } = M;
        if (!(U === 8 || U === 12)) return !1;
        h(L);
        const ie = L.currentPeek() === ":";
        return L.resetPeek(), ie
    }

    function x(L, M) {
        const {
            currentType: U
        } = M;
        if (U !== 10) return !1;
        const ie = () => {
                const me = L.currentPeek();
                return me === "{" ? S(L.peek()) : me === "@" || me === "%" || me === "|" || me === ":" || me === "." || me === da || !me ? !1 : me === Gt ? (L.peek(), ie()) : I(L, !1)
            },
            _e = ie();
        return L.resetPeek(), _e
    }

    function T(L) {
        h(L);
        const M = L.currentPeek() === "|";
        return L.resetPeek(), M
    }

    function V(L) {
        const M = h(L),
            U = L.currentPeek() === "%" && L.peek() === "{";
        return L.resetPeek(), {
            isModulo: U,
            hasSpace: M.length > 0
        }
    }

    function I(L, M = !0) {
        const U = (_e = !1, me = "", q = !1) => {
                const oe = L.currentPeek();
                return oe === "{" ? me === "%" ? !1 : _e : oe === "@" || !oe ? me === "%" ? !0 : _e : oe === "%" ? (L.peek(), U(_e, "%", !0)) : oe === "|" ? me === "%" || q ? !0 : !(me === da || me === Gt) : oe === da ? (L.peek(), U(!0, da, q)) : oe === Gt ? (L.peek(), U(!0, Gt, q)) : !0
            },
            ie = U();
        return M && L.resetPeek(), ie
    }

    function R(L, M) {
        const U = L.currentChar();
        return U === Ra ? Ra : M(U) ? (L.next(), U) : null
    }

    function B(L) {
        const M = L.charCodeAt(0);
        return M >= 97 && M <= 122 || M >= 65 && M <= 90 || M >= 48 && M <= 57 || M === 95 || M === 36
    }

    function $(L) {
        return R(L, B)
    }

    function D(L) {
        const M = L.charCodeAt(0);
        return M >= 97 && M <= 122 || M >= 65 && M <= 90 || M >= 48 && M <= 57 || M === 95 || M === 36 || M === 45
    }

    function z(L) {
        return R(L, D)
    }

    function N(L) {
        const M = L.charCodeAt(0);
        return M >= 48 && M <= 57
    }

    function H(L) {
        return R(L, N)
    }

    function F(L) {
        const M = L.charCodeAt(0);
        return M >= 48 && M <= 57 || M >= 65 && M <= 70 || M >= 97 && M <= 102
    }

    function j(L) {
        return R(L, F)
    }

    function ae(L) {
        let M = "",
            U = "";
        for (; M = H(L);) U += M;
        return U
    }

    function he(L) {
        y(L);
        const M = L.currentChar();
        return M !== "%" && d(ze.EXPECTED_TOKEN, r(), 0, M), L.next(), "%"
    }

    function ve(L) {
        let M = "";
        for (;;) {
            const U = L.currentChar();
            if (U === "{" || U === "}" || U === "@" || U === "|" || !U) break;
            if (U === "%")
                if (I(L)) M += U, L.next();
                else break;
            else if (U === da || U === Gt)
                if (I(L)) M += U, L.next();
                else {
                    if (T(L)) break;
                    M += U, L.next()
                }
            else M += U, L.next()
        }
        return M
    }

    function we(L) {
        y(L);
        let M = "",
            U = "";
        for (; M = z(L);) U += M;
        return L.currentChar() === Ra && d(ze.UNTERMINATED_CLOSING_BRACE, r(), 0), U
    }

    function ee(L) {
        y(L);
        let M = "";
        return L.currentChar() === "-" ? (L.next(), M += `-${ae(L)}`) : M += ae(L), L.currentChar() === Ra && d(ze.UNTERMINATED_CLOSING_BRACE, r(), 0), M
    }

    function G(L) {
        return L !== dg && L !== Gt
    }

    function le(L) {
        y(L), g(L, "'");
        let M = "",
            U = "";
        for (; M = R(L, G);) M === "\\" ? U += se(L) : U += M;
        const ie = L.currentChar();
        return ie === Gt || ie === Ra ? (d(ze.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, r(), 0), ie === Gt && (L.next(), g(L, "'")), U) : (g(L, "'"), U)
    }

    function se(L) {
        const M = L.currentChar();
        switch (M) {
            case "\\":
            case "'":
                return L.next(), `\\${M}`;
            case "u":
                return ce(L, M, 4);
            case "U":
                return ce(L, M, 6);
            default:
                return d(ze.UNKNOWN_ESCAPE_SEQUENCE, r(), 0, M), ""
        }
    }

    function ce(L, M, U) {
        g(L, M);
        let ie = "";
        for (let _e = 0; _e < U; _e++) {
            const me = j(L);
            if (!me) {
                d(ze.INVALID_UNICODE_ESCAPE_SEQUENCE, r(), 0, `\\${M}${ie}${L.currentChar()}`);
                break
            }
            ie += me
        }
        return `\\${M}${ie}`
    }

    function re(L) {
        return L !== "{" && L !== "}" && L !== da && L !== Gt
    }

    function pe(L) {
        y(L);
        let M = "",
            U = "";
        for (; M = R(L, re);) U += M;
        return U
    }

    function A(L) {
        let M = "",
            U = "";
        for (; M = $(L);) U += M;
        return U
    }

    function O(L) {
        const M = U => {
            const ie = L.currentChar();
            return ie === "{" || ie === "%" || ie === "@" || ie === "|" || ie === "(" || ie === ")" || !ie || ie === da ? U : (U += ie, L.next(), M(U))
        };
        return M("")
    }

    function K(L) {
        y(L);
        const M = g(L, "|");
        return y(L), M
    }

    function J(L, M) {
        let U = null;
        switch (L.currentChar()) {
            case "{":
                return M.braceNest >= 1 && d(ze.NOT_ALLOW_NEST_PLACEHOLDER, r(), 0), L.next(), U = f(M, 2, "{"), y(L), M.braceNest++, U;
            case "}":
                return M.braceNest > 0 && M.currentType === 2 && d(ze.EMPTY_PLACEHOLDER, r(), 0), L.next(), U = f(M, 3, "}"), M.braceNest--, M.braceNest > 0 && y(L), M.inLinked && M.braceNest === 0 && (M.inLinked = !1), U;
            case "@":
                return M.braceNest > 0 && d(ze.UNTERMINATED_CLOSING_BRACE, r(), 0), U = X(L, M) || v(M), M.braceNest = 0, U;
            default:
                {
                    let _e = !0,
                        me = !0,
                        q = !0;
                    if (T(L)) return M.braceNest > 0 && d(ze.UNTERMINATED_CLOSING_BRACE, r(), 0), U = f(M, 1, K(L)), M.braceNest = 0, M.inLinked = !1, U;
                    if (M.braceNest > 0 && (M.currentType === 5 || M.currentType === 6 || M.currentType === 7)) return d(ze.UNTERMINATED_CLOSING_BRACE, r(), 0), M.braceNest = 0, ue(L, M);
                    if (_e = p(L, M)) return U = f(M, 5, we(L)), y(L), U;
                    if (me = _(L, M)) return U = f(M, 6, ee(L)), y(L), U;
                    if (q = w(L, M)) return U = f(M, 7, le(L)), y(L), U;
                    if (!_e && !me && !q) return U = f(M, 13, pe(L)), d(ze.INVALID_TOKEN_IN_PLACEHOLDER, r(), 0, U.value), y(L), U;
                    break
                }
        }
        return U
    }

    function X(L, M) {
        const {
            currentType: U
        } = M;
        let ie = null;
        const _e = L.currentChar();
        switch ((U === 8 || U === 9 || U === 12 || U === 10) && (_e === Gt || _e === da) && d(ze.INVALID_LINKED_FORMAT, r(), 0), _e) {
            case "@":
                return L.next(), ie = f(M, 8, "@"), M.inLinked = !0, ie;
            case ".":
                return y(L), L.next(), f(M, 9, ".");
            case ":":
                return y(L), L.next(), f(M, 10, ":");
            default:
                return T(L) ? (ie = f(M, 1, K(L)), M.braceNest = 0, M.inLinked = !1, ie) : k(L, M) || P(L, M) ? (y(L), X(L, M)) : E(L, M) ? (y(L), f(M, 12, A(L))) : x(L, M) ? (y(L), _e === "{" ? J(L, M) || ie : f(M, 11, O(L))) : (U === 8 && d(ze.INVALID_LINKED_FORMAT, r(), 0), M.braceNest = 0, M.inLinked = !1, ue(L, M))
        }
    }

    function ue(L, M) {
        let U = {
            type: 14
        };
        if (M.braceNest > 0) return J(L, M) || v(M);
        if (M.inLinked) return X(L, M) || v(M);
        switch (L.currentChar()) {
            case "{":
                return J(L, M) || v(M);
            case "}":
                return d(ze.UNBALANCED_CLOSING_BRACE, r(), 0), L.next(), f(M, 3, "}");
            case "@":
                return X(L, M) || v(M);
            default:
                {
                    if (T(L)) return U = f(M, 1, K(L)), M.braceNest = 0, M.inLinked = !1, U;
                    const {
                        isModulo: _e,
                        hasSpace: me
                    } = V(L);
                    if (_e) return me ? f(M, 0, ve(L)) : f(M, 4, he(L));
                    if (I(L)) return f(M, 0, ve(L));
                    break
                }
        }
        return U
    }

    function be() {
        const {
            currentType: L,
            offset: M,
            startLoc: U,
            endLoc: ie
        } = s;
        return s.lastType = L, s.lastOffset = M, s.lastStartLoc = U, s.lastEndLoc = ie, s.offset = l(), s.startLoc = r(), a.currentChar() === Ra ? f(s, 14) : ue(a, s)
    }
    return {
        nextToken: be,
        currentOffset: l,
        currentPosition: r,
        context: u
    }
}
const PL = "parser",
    EL = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;

function IL(e, t, n) {
    switch (e) {
        case "\\\\":
            return "\\";
        case "\\'":
            return "'";
        default:
            {
                const a = parseInt(t || n, 16);
                return a <= 55295 || a >= 57344 ? String.fromCodePoint(a) : "�"
            }
    }
}

function TL(e = {}) {
    const t = e.location !== !1,
        {
            onError: n,
            onWarn: a
        } = e;

    function l(p, _, w, k, ...E) {
        const P = p.currentPosition();
        if (P.offset += k, P.column += k, n) {
            const x = t ? Cs(w, P) : null,
                T = gu(_, x, {
                    domain: PL,
                    args: E
                });
            n(T)
        }
    }

    function r(p, _, w, k, ...E) {
        const P = p.currentPosition();
        if (P.offset += k, P.column += k, a) {
            const x = t ? Cs(w, P) : null;
            a(yL(_, x, E))
        }
    }

    function o(p, _, w) {
        const k = {
            type: p
        };
        return t && (k.start = _, k.end = _, k.loc = {
            start: w,
            end: w
        }), k
    }

    function i(p, _, w, k) {
        t && (p.end = _, p.loc && (p.loc.end = w))
    }

    function s(p, _) {
        const w = p.context(),
            k = o(3, w.offset, w.startLoc);
        return k.value = _, i(k, p.currentOffset(), p.currentPosition()), k
    }

    function u(p, _) {
        const w = p.context(),
            {
                lastOffset: k,
                lastStartLoc: E
            } = w,
            P = o(5, k, E);
        return P.index = parseInt(_, 10), p.nextToken(), i(P, p.currentOffset(), p.currentPosition()), P
    }

    function c(p, _, w) {
        const k = p.context(),
            {
                lastOffset: E,
                lastStartLoc: P
            } = k,
            x = o(4, E, P);
        return x.key = _, w === !0 && (x.modulo = !0), p.nextToken(), i(x, p.currentOffset(), p.currentPosition()), x
    }

    function d(p, _) {
        const w = p.context(),
            {
                lastOffset: k,
                lastStartLoc: E
            } = w,
            P = o(9, k, E);
        return P.value = _.replace(EL, IL), p.nextToken(), i(P, p.currentOffset(), p.currentPosition()), P
    }

    function f(p) {
        const _ = p.nextToken(),
            w = p.context(),
            {
                lastOffset: k,
                lastStartLoc: E
            } = w,
            P = o(8, k, E);
        return _.type !== 12 ? (l(p, ze.UNEXPECTED_EMPTY_LINKED_MODIFIER, w.lastStartLoc, 0), P.value = "", i(P, k, E), {
            nextConsumeToken: _,
            node: P
        }) : (_.value == null && l(p, ze.UNEXPECTED_LEXICAL_ANALYSIS, w.lastStartLoc, 0, Dn(_)), P.value = _.value || "", i(P, p.currentOffset(), p.currentPosition()), {
            node: P
        })
    }

    function v(p, _) {
        const w = p.context(),
            k = o(7, w.offset, w.startLoc);
        return k.value = _, i(k, p.currentOffset(), p.currentPosition()), k
    }

    function g(p) {
        const _ = p.context(),
            w = o(6, _.offset, _.startLoc);
        let k = p.nextToken();
        if (k.type === 9) {
            const E = f(p);
            w.modifier = E.node, k = E.nextConsumeToken || p.nextToken()
        }
        switch (k.type !== 10 && l(p, ze.UNEXPECTED_LEXICAL_ANALYSIS, _.lastStartLoc, 0, Dn(k)), k = p.nextToken(), k.type === 2 && (k = p.nextToken()), k.type) {
            case 11:
                k.value == null && l(p, ze.UNEXPECTED_LEXICAL_ANALYSIS, _.lastStartLoc, 0, Dn(k)), w.key = v(p, k.value || "");
                break;
            case 5:
                k.value == null && l(p, ze.UNEXPECTED_LEXICAL_ANALYSIS, _.lastStartLoc, 0, Dn(k)), w.key = c(p, k.value || "");
                break;
            case 6:
                k.value == null && l(p, ze.UNEXPECTED_LEXICAL_ANALYSIS, _.lastStartLoc, 0, Dn(k)), w.key = u(p, k.value || "");
                break;
            case 7:
                k.value == null && l(p, ze.UNEXPECTED_LEXICAL_ANALYSIS, _.lastStartLoc, 0, Dn(k)), w.key = d(p, k.value || "");
                break;
            default:
                {
                    l(p, ze.UNEXPECTED_EMPTY_LINKED_KEY, _.lastStartLoc, 0);
                    const E = p.context(),
                        P = o(7, E.offset, E.startLoc);
                    return P.value = "",
                    i(P, E.offset, E.startLoc),
                    w.key = P,
                    i(w, E.offset, E.startLoc),
                    {
                        nextConsumeToken: k,
                        node: w
                    }
                }
        }
        return i(w, p.currentOffset(), p.currentPosition()), {
            node: w
        }
    }

    function h(p) {
        const _ = p.context(),
            w = _.currentType === 1 ? p.currentOffset() : _.offset,
            k = _.currentType === 1 ? _.endLoc : _.startLoc,
            E = o(2, w, k);
        E.items = [];
        let P = null,
            x = null;
        do {
            const I = P || p.nextToken();
            switch (P = null, I.type) {
                case 0:
                    I.value == null && l(p, ze.UNEXPECTED_LEXICAL_ANALYSIS, _.lastStartLoc, 0, Dn(I)), E.items.push(s(p, I.value || ""));
                    break;
                case 6:
                    I.value == null && l(p, ze.UNEXPECTED_LEXICAL_ANALYSIS, _.lastStartLoc, 0, Dn(I)), E.items.push(u(p, I.value || ""));
                    break;
                case 4:
                    x = !0;
                    break;
                case 5:
                    I.value == null && l(p, ze.UNEXPECTED_LEXICAL_ANALYSIS, _.lastStartLoc, 0, Dn(I)), E.items.push(c(p, I.value || "", !!x)), x && (r(p, e0.USE_MODULO_SYNTAX, _.lastStartLoc, 0, Dn(I)), x = null);
                    break;
                case 7:
                    I.value == null && l(p, ze.UNEXPECTED_LEXICAL_ANALYSIS, _.lastStartLoc, 0, Dn(I)), E.items.push(d(p, I.value || ""));
                    break;
                case 8:
                    {
                        const R = g(p);E.items.push(R.node),
                        P = R.nextConsumeToken || null;
                        break
                    }
            }
        } while (_.currentType !== 14 && _.currentType !== 1);
        const T = _.currentType === 1 ? _.lastOffset : p.currentOffset(),
            V = _.currentType === 1 ? _.lastEndLoc : p.currentPosition();
        return i(E, T, V), E
    }

    function y(p, _, w, k) {
        const E = p.context();
        let P = k.items.length === 0;
        const x = o(1, _, w);
        x.cases = [], x.cases.push(k);
        do {
            const T = h(p);
            P || (P = T.items.length === 0), x.cases.push(T)
        } while (E.currentType !== 14);
        return P && l(p, ze.MUST_HAVE_MESSAGES_IN_PLURAL, w, 0), i(x, p.currentOffset(), p.currentPosition()), x
    }

    function S(p) {
        const _ = p.context(),
            {
                offset: w,
                startLoc: k
            } = _,
            E = h(p);
        return _.currentType === 14 ? E : y(p, w, k, E)
    }

    function b(p) {
        const _ = xL(p, yt({}, e)),
            w = _.context(),
            k = o(0, w.offset, w.startLoc);
        return t && k.loc && (k.loc.source = p), k.body = S(_), e.onCacheKey && (k.cacheKey = e.onCacheKey(p)), w.currentType !== 14 && l(_, ze.UNEXPECTED_LEXICAL_ANALYSIS, w.lastStartLoc, 0, p[w.offset] || ""), i(k, _.currentOffset(), _.currentPosition()), k
    }
    return {
        parse: b
    }
}

function Dn(e) {
    if (e.type === 14) return "EOF";
    const t = (e.value || "").replace(/\r?\n/gu, "\\n");
    return t.length > 10 ? t.slice(0, 9) + "…" : t
}

function VL(e, t = {}) {
    const n = {
        ast: e,
        helpers: new Set
    };
    return {
        context: () => n,
        helper: r => (n.helpers.add(r), r)
    }
}

function fg(e, t) {
    for (let n = 0; n < e.length; n++) yv(e[n], t)
}

function yv(e, t) {
    switch (e.type) {
        case 1:
            fg(e.cases, t), t.helper("plural");
            break;
        case 2:
            fg(e.items, t);
            break;
        case 6:
            {
                yv(e.key, t),
                t.helper("linked"),
                t.helper("type");
                break
            }
        case 5:
            t.helper("interpolate"), t.helper("list");
            break;
        case 4:
            t.helper("interpolate"), t.helper("named");
            break
    }
}

function AL(e, t = {}) {
    const n = VL(e);
    n.helper("normalize"), e.body && yv(e.body, n);
    const a = n.context();
    e.helpers = Array.from(a.helpers)
}

function LL(e) {
    const t = e.body;
    return t.type === 2 ? vg(t) : t.cases.forEach(n => vg(n)), e
}

function vg(e) {
    if (e.items.length === 1) {
        const t = e.items[0];
        (t.type === 3 || t.type === 9) && (e.static = t.value, delete t.value)
    } else {
        const t = [];
        for (let n = 0; n < e.items.length; n++) {
            const a = e.items[n];
            if (!(a.type === 3 || a.type === 9) || a.value == null) break;
            t.push(a.value)
        }
        if (t.length === e.items.length) {
            e.static = gv(t);
            for (let n = 0; n < e.items.length; n++) {
                const a = e.items[n];
                (a.type === 3 || a.type === 9) && delete a.value
            }
        }
    }
}

function ur(e) {
    switch (e.t = e.type, e.type) {
        case 0:
            {
                const t = e;ur(t.body),
                t.b = t.body,
                delete t.body;
                break
            }
        case 1:
            {
                const t = e,
                    n = t.cases;
                for (let a = 0; a < n.length; a++) ur(n[a]);t.c = n,
                delete t.cases;
                break
            }
        case 2:
            {
                const t = e,
                    n = t.items;
                for (let a = 0; a < n.length; a++) ur(n[a]);t.i = n,
                delete t.items,
                t.static && (t.s = t.static, delete t.static);
                break
            }
        case 3:
        case 9:
        case 8:
        case 7:
            {
                const t = e;t.value && (t.v = t.value, delete t.value);
                break
            }
        case 6:
            {
                const t = e;ur(t.key),
                t.k = t.key,
                delete t.key,
                t.modifier && (ur(t.modifier), t.m = t.modifier, delete t.modifier);
                break
            }
        case 5:
            {
                const t = e;t.i = t.index,
                delete t.index;
                break
            }
        case 4:
            {
                const t = e;t.k = t.key,
                delete t.key;
                break
            }
    }
    delete e.type
}

function OL(e, t) {
    const {
        sourceMap: n,
        filename: a,
        breakLineCode: l,
        needIndent: r
    } = t, o = t.location !== !1, i = {
        filename: a,
        code: "",
        column: 1,
        line: 1,
        offset: 0,
        map: void 0,
        breakLineCode: l,
        needIndent: r,
        indentLevel: 0
    };
    o && e.loc && (i.source = e.loc.source);
    const s = () => i;

    function u(y, S) {
        i.code += y
    }

    function c(y, S = !0) {
        const b = S ? l : "";
        u(r ? b + "  ".repeat(y) : b)
    }

    function d(y = !0) {
        const S = ++i.indentLevel;
        y && c(S)
    }

    function f(y = !0) {
        const S = --i.indentLevel;
        y && c(S)
    }

    function v() {
        c(i.indentLevel)
    }
    return {
        context: s,
        push: u,
        indent: d,
        deindent: f,
        newline: v,
        helper: y => `_${y}`,
        needIndent: () => i.needIndent
    }
}

function RL(e, t) {
    const {
        helper: n
    } = e;
    e.push(`${n("linked")}(`), Er(e, t.key), t.modifier ? (e.push(", "), Er(e, t.modifier), e.push(", _type")) : e.push(", undefined, _type"), e.push(")")
}

function DL(e, t) {
    const {
        helper: n,
        needIndent: a
    } = e;
    e.push(`${n("normalize")}([`), e.indent(a());
    const l = t.items.length;
    for (let r = 0; r < l && (Er(e, t.items[r]), r !== l - 1); r++) e.push(", ");
    e.deindent(a()), e.push("])")
}

function ML(e, t) {
    const {
        helper: n,
        needIndent: a
    } = e;
    if (t.cases.length > 1) {
        e.push(`${n("plural")}([`), e.indent(a());
        const l = t.cases.length;
        for (let r = 0; r < l && (Er(e, t.cases[r]), r !== l - 1); r++) e.push(", ");
        e.deindent(a()), e.push("])")
    }
}

function NL(e, t) {
    t.body ? Er(e, t.body) : e.push("null")
}

function Er(e, t) {
    const {
        helper: n
    } = e;
    switch (t.type) {
        case 0:
            NL(e, t);
            break;
        case 1:
            ML(e, t);
            break;
        case 2:
            DL(e, t);
            break;
        case 6:
            RL(e, t);
            break;
        case 8:
            e.push(JSON.stringify(t.value), t);
            break;
        case 7:
            e.push(JSON.stringify(t.value), t);
            break;
        case 5:
            e.push(`${n("interpolate")}(${n("list")}(${t.index}))`, t);
            break;
        case 4:
            e.push(`${n("interpolate")}(${n("named")}(${JSON.stringify(t.key)}))`, t);
            break;
        case 9:
            e.push(JSON.stringify(t.value), t);
            break;
        case 3:
            e.push(JSON.stringify(t.value), t);
            break
    }
}
const $L = (e, t = {}) => {
    const n = ke(t.mode) ? t.mode : "normal",
        a = ke(t.filename) ? t.filename : "message.intl",
        l = !!t.sourceMap,
        r = t.breakLineCode != null ? t.breakLineCode : n === "arrow" ? ";" : `
`,
        o = t.needIndent ? t.needIndent : n !== "arrow",
        i = e.helpers || [],
        s = OL(e, {
            mode: n,
            filename: a,
            sourceMap: l,
            breakLineCode: r,
            needIndent: o
        });
    s.push(n === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"), s.indent(o), i.length > 0 && (s.push(`const { ${gv(i.map(d=>`${d}: _${d}`),", ")} } = ctx`), s.newline()), s.push("return "), Er(s, e), s.deindent(o), s.push("}"), delete e.helpers;
    const {
        code: u,
        map: c
    } = s.context();
    return {
        ast: e,
        code: u,
        map: c ? c.toJSON() : void 0
    }
};

function BL(e, t = {}) {
    const n = yt({}, t),
        a = !!n.jit,
        l = !!n.minify,
        r = n.optimize == null ? !0 : n.optimize,
        i = TL(n).parse(e);
    return a ? (r && LL(i), l && ur(i), {
        ast: i,
        code: ""
    }) : (AL(i, n), $L(i, n))
}
/*!
 * core-base v9.13.1
 * (c) 2024 kazuya kawaguchi
 * Released under the MIT License.
 */
function FL() {
    typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (hv().__INTLIFY_PROD_DEVTOOLS__ = !1)
}
const tl = [];
tl[0] = {
    w: [0],
    i: [3, 0],
    "[": [4],
    o: [7]
};
tl[1] = {
    w: [1],
    ".": [2],
    "[": [4],
    o: [7]
};
tl[2] = {
    w: [2],
    i: [3, 0],
    0: [3, 0]
};
tl[3] = {
    i: [3, 0],
    0: [3, 0],
    w: [1, 1],
    ".": [2, 1],
    "[": [4, 1],
    o: [7, 1]
};
tl[4] = {
    "'": [5, 0],
    '"': [6, 0],
    "[": [4, 2],
    "]": [1, 3],
    o: 8,
    l: [4, 0]
};
tl[5] = {
    "'": [4, 0],
    o: 8,
    l: [5, 0]
};
tl[6] = {
    '"': [4, 0],
    o: 8,
    l: [6, 0]
};
const HL = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;

function jL(e) {
    return HL.test(e)
}

function UL(e) {
    const t = e.charCodeAt(0),
        n = e.charCodeAt(e.length - 1);
    return t === n && (t === 34 || t === 39) ? e.slice(1, -1) : e
}

function WL(e) {
    if (e == null) return "o";
    switch (e.charCodeAt(0)) {
        case 91:
        case 93:
        case 46:
        case 34:
        case 39:
            return e;
        case 95:
        case 36:
        case 45:
            return "i";
        case 9:
        case 10:
        case 13:
        case 160:
        case 65279:
        case 8232:
        case 8233:
            return "w"
    }
    return "i"
}

function zL(e) {
    const t = e.trim();
    return e.charAt(0) === "0" && isNaN(parseInt(e)) ? !1 : jL(t) ? UL(t) : "*" + t
}

function KL(e) {
    const t = [];
    let n = -1,
        a = 0,
        l = 0,
        r, o, i, s, u, c, d;
    const f = [];
    f[0] = () => {
        o === void 0 ? o = i : o += i
    }, f[1] = () => {
        o !== void 0 && (t.push(o), o = void 0)
    }, f[2] = () => {
        f[0](), l++
    }, f[3] = () => {
        if (l > 0) l--, a = 4, f[0]();
        else {
            if (l = 0, o === void 0 || (o = zL(o), o === !1)) return !1;
            f[1]()
        }
    };

    function v() {
        const g = e[n + 1];
        if (a === 5 && g === "'" || a === 6 && g === '"') return n++, i = "\\" + g, f[0](), !0
    }
    for (; a !== null;)
        if (n++, r = e[n], !(r === "\\" && v())) {
            if (s = WL(r), d = tl[a], u = d[s] || d.l || 8, u === 8 || (a = u[0], u[1] !== void 0 && (c = f[u[1]], c && (i = r, c() === !1)))) return;
            if (a === 7) return t
        }
}
const mg = new Map;

function GL(e, t) {
    return $e(e) ? e[t] : null
}

function YL(e, t) {
    if (!$e(e)) return null;
    let n = mg.get(t);
    if (n || (n = KL(t), n && mg.set(t, n)), !n) return null;
    const a = n.length;
    let l = e,
        r = 0;
    for (; r < a;) {
        const o = l[n[r]];
        if (o === void 0 || Ze(l)) return null;
        l = o, r++
    }
    return l
}
const qL = e => e,
    XL = e => "",
    JL = "text",
    ZL = e => e.length === 0 ? "" : gv(e),
    QL = mL;

function hg(e, t) {
    return e = Math.abs(e), t === 2 ? e ? e > 1 ? 1 : 0 : 1 : e ? Math.min(e, 2) : 0
}

function eO(e) {
    const t = At(e.pluralIndex) ? e.pluralIndex : -1;
    return e.named && (At(e.named.count) || At(e.named.n)) ? At(e.named.count) ? e.named.count : At(e.named.n) ? e.named.n : t : t
}

function tO(e, t) {
    t.count || (t.count = e), t.n || (t.n = e)
}

function nO(e = {}) {
    const t = e.locale,
        n = eO(e),
        a = $e(e.pluralRules) && ke(t) && Ze(e.pluralRules[t]) ? e.pluralRules[t] : hg,
        l = $e(e.pluralRules) && ke(t) && Ze(e.pluralRules[t]) ? hg : void 0,
        r = S => S[a(n, S.length, l)],
        o = e.list || [],
        i = S => o[S],
        s = e.named || {};
    At(e.pluralIndex) && tO(n, s);
    const u = S => s[S];

    function c(S) {
        const b = Ze(e.messages) ? e.messages(S) : $e(e.messages) ? e.messages[S] : !1;
        return b || (e.parent ? e.parent.message(S) : XL)
    }
    const d = S => e.modifiers ? e.modifiers[S] : qL,
        f = Fe(e.processor) && Ze(e.processor.normalize) ? e.processor.normalize : ZL,
        v = Fe(e.processor) && Ze(e.processor.interpolate) ? e.processor.interpolate : QL,
        g = Fe(e.processor) && ke(e.processor.type) ? e.processor.type : JL,
        y = {
            list: i,
            named: u,
            plural: r,
            linked: (S, ...b) => {
                const [p, _] = b;
                let w = "text",
                    k = "";
                b.length === 1 ? $e(p) ? (k = p.modifier || k, w = p.type || w) : ke(p) && (k = p || k) : b.length === 2 && (ke(p) && (k = p || k), ke(_) && (w = _ || w));
                const E = c(S)(y),
                    P = w === "vnode" && gt(E) && k ? E[0] : E;
                return k ? d(k)(P, w) : P
            },
            message: c,
            type: g,
            interpolate: v,
            normalize: f,
            values: yt({}, o, s)
        };
    return y
}
let Ro = null;

function aO(e) {
    Ro = e
}

function lO(e, t, n) {
    Ro && Ro.emit("i18n:init", {
        timestamp: Date.now(),
        i18n: e,
        version: t,
        meta: n
    })
}
const rO = oO("function:translate");

function oO(e) {
    return t => Ro && Ro.emit(e, t)
}
const t0 = e0.__EXTEND_POINT__,
    ul = hu(t0),
    iO = {
        NOT_FOUND_KEY: t0,
        FALLBACK_TO_TRANSLATE: ul(),
        CANNOT_FORMAT_NUMBER: ul(),
        FALLBACK_TO_NUMBER_FORMAT: ul(),
        CANNOT_FORMAT_DATE: ul(),
        FALLBACK_TO_DATE_FORMAT: ul(),
        EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: ul(),
        __EXTEND_POINT__: ul()
    },
    n0 = ze.__EXTEND_POINT__,
    cl = hu(n0),
    Zn = {
        INVALID_ARGUMENT: n0,
        INVALID_DATE_ARGUMENT: cl(),
        INVALID_ISO_DATE_ARGUMENT: cl(),
        NOT_SUPPORT_NON_STRING_MESSAGE: cl(),
        NOT_SUPPORT_LOCALE_PROMISE_VALUE: cl(),
        NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: cl(),
        NOT_SUPPORT_LOCALE_TYPE: cl(),
        __EXTEND_POINT__: cl()
    };

function ga(e) {
    return gu(e, null, void 0)
}

function bv(e, t) {
    return t.locale != null ? gg(t.locale) : gg(e.locale)
}
let gc;

function gg(e) {
    if (ke(e)) return e;
    if (Ze(e)) {
        if (e.resolvedOnce && gc != null) return gc;
        if (e.constructor.name === "Function") {
            const t = e();
            if (vL(t)) throw ga(Zn.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
            return gc = t
        } else throw ga(Zn.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION)
    } else throw ga(Zn.NOT_SUPPORT_LOCALE_TYPE)
}

function sO(e, t, n) {
    return [...new Set([n, ...gt(t) ? t : $e(t) ? Object.keys(t) : ke(t) ? [t] : [n]])]
}

function a0(e, t, n) {
    const a = ke(n) ? n : xs,
        l = e;
    l.__localeChainCache || (l.__localeChainCache = new Map);
    let r = l.__localeChainCache.get(a);
    if (!r) {
        r = [];
        let o = [n];
        for (; gt(o);) o = yg(r, o, t);
        const i = gt(t) || !Fe(t) ? t : t.default ? t.default : null;
        o = ke(i) ? [i] : i, gt(o) && yg(r, o, !1), l.__localeChainCache.set(a, r)
    }
    return r
}

function yg(e, t, n) {
    let a = !0;
    for (let l = 0; l < t.length && dt(a); l++) {
        const r = t[l];
        ke(r) && (a = uO(e, t[l], n))
    }
    return a
}

function uO(e, t, n) {
    let a;
    const l = t.split("-");
    do {
        const r = l.join("-");
        a = cO(e, r, n), l.splice(-1, 1)
    } while (l.length && a === !0);
    return a
}

function cO(e, t, n) {
    let a = !1;
    if (!e.includes(t) && (a = !0, t)) {
        a = t[t.length - 1] !== "!";
        const l = t.replace(/!/g, "");
        e.push(l), (gt(n) || Fe(n)) && n[l] && (a = n[l])
    }
    return a
}
const dO = "9.13.1",
    yu = -1,
    xs = "en-US",
    bg = "",
    pg = e => `${e.charAt(0).toLocaleUpperCase()}${e.substr(1)}`;

function fO() {
    return {
        upper: (e, t) => t === "text" && ke(e) ? e.toUpperCase() : t === "vnode" && $e(e) && "__v_isVNode" in e ? e.children.toUpperCase() : e,
        lower: (e, t) => t === "text" && ke(e) ? e.toLowerCase() : t === "vnode" && $e(e) && "__v_isVNode" in e ? e.children.toLowerCase() : e,
        capitalize: (e, t) => t === "text" && ke(e) ? pg(e) : t === "vnode" && $e(e) && "__v_isVNode" in e ? pg(e.children) : e
    }
}
let l0;

function vO(e) {
    l0 = e
}
let r0;

function mO(e) {
    r0 = e
}
let o0;

function hO(e) {
    o0 = e
}
let i0 = null;
const gO = e => {
        i0 = e
    },
    yO = () => i0;
let s0 = null;
const _g = e => {
        s0 = e
    },
    bO = () => s0;
let Sg = 0;

function pO(e = {}) {
    const t = Ze(e.onWarn) ? e.onWarn : hL,
        n = ke(e.version) ? e.version : dO,
        a = ke(e.locale) || Ze(e.locale) ? e.locale : xs,
        l = Ze(a) ? xs : a,
        r = gt(e.fallbackLocale) || Fe(e.fallbackLocale) || ke(e.fallbackLocale) || e.fallbackLocale === !1 ? e.fallbackLocale : l,
        o = Fe(e.messages) ? e.messages : {
            [l]: {}
        },
        i = Fe(e.datetimeFormats) ? e.datetimeFormats : {
            [l]: {}
        },
        s = Fe(e.numberFormats) ? e.numberFormats : {
            [l]: {}
        },
        u = yt({}, e.modifiers || {}, fO()),
        c = e.pluralRules || {},
        d = Ze(e.missing) ? e.missing : null,
        f = dt(e.missingWarn) || ws(e.missingWarn) ? e.missingWarn : !0,
        v = dt(e.fallbackWarn) || ws(e.fallbackWarn) ? e.fallbackWarn : !0,
        g = !!e.fallbackFormat,
        h = !!e.unresolving,
        y = Ze(e.postTranslation) ? e.postTranslation : null,
        S = Fe(e.processor) ? e.processor : null,
        b = dt(e.warnHtmlMessage) ? e.warnHtmlMessage : !0,
        p = !!e.escapeParameter,
        _ = Ze(e.messageCompiler) ? e.messageCompiler : l0,
        w = Ze(e.messageResolver) ? e.messageResolver : r0 || GL,
        k = Ze(e.localeFallbacker) ? e.localeFallbacker : o0 || sO,
        E = $e(e.fallbackContext) ? e.fallbackContext : void 0,
        P = e,
        x = $e(P.__datetimeFormatters) ? P.__datetimeFormatters : new Map,
        T = $e(P.__numberFormatters) ? P.__numberFormatters : new Map,
        V = $e(P.__meta) ? P.__meta : {};
    Sg++;
    const I = {
        version: n,
        cid: Sg,
        locale: a,
        fallbackLocale: r,
        messages: o,
        modifiers: u,
        pluralRules: c,
        missing: d,
        missingWarn: f,
        fallbackWarn: v,
        fallbackFormat: g,
        unresolving: h,
        postTranslation: y,
        processor: S,
        warnHtmlMessage: b,
        escapeParameter: p,
        messageCompiler: _,
        messageResolver: w,
        localeFallbacker: k,
        fallbackContext: E,
        onWarn: t,
        __meta: V
    };
    return I.datetimeFormats = i, I.numberFormats = s, I.__datetimeFormatters = x, I.__numberFormatters = T, __INTLIFY_PROD_DEVTOOLS__ && lO(I, n, V), I
}

function pv(e, t, n, a, l) {
    const {
        missing: r,
        onWarn: o
    } = e;
    if (r !== null) {
        const i = r(e, n, t, l);
        return ke(i) ? i : t
    } else return t
}

function ao(e, t, n) {
    const a = e;
    a.__localeChainCache = new Map, e.localeFallbacker(e, n, t)
}

function _O(e, t) {
    return e === t ? !1 : e.split("-")[0] === t.split("-")[0]
}

function SO(e, t) {
    const n = t.indexOf(e);
    if (n === -1) return !1;
    for (let a = n + 1; a < t.length; a++)
        if (_O(e, t[a])) return !0;
    return !1
}

function yc(e) {
    return n => wO(n, e)
}

function wO(e, t) {
    const n = t.b || t.body;
    if ((n.t || n.type) === 1) {
        const a = n,
            l = a.c || a.cases;
        return e.plural(l.reduce((r, o) => [...r, wg(e, o)], []))
    } else return wg(e, n)
}

function wg(e, t) {
    const n = t.s || t.static;
    if (n) return e.type === "text" ? n : e.normalize([n]); {
        const a = (t.i || t.items).reduce((l, r) => [...l, pd(e, r)], []);
        return e.normalize(a)
    }
}

function pd(e, t) {
    const n = t.t || t.type;
    switch (n) {
        case 3:
            {
                const a = t;
                return a.v || a.value
            }
        case 9:
            {
                const a = t;
                return a.v || a.value
            }
        case 4:
            {
                const a = t;
                return e.interpolate(e.named(a.k || a.key))
            }
        case 5:
            {
                const a = t;
                return e.interpolate(e.list(a.i != null ? a.i : a.index))
            }
        case 6:
            {
                const a = t,
                    l = a.m || a.modifier;
                return e.linked(pd(e, a.k || a.key), l ? pd(e, l) : void 0, e.type)
            }
        case 7:
            {
                const a = t;
                return a.v || a.value
            }
        case 8:
            {
                const a = t;
                return a.v || a.value
            }
        default:
            throw new Error(`unhandled node type on format message part: ${n}`)
    }
}
const kO = e => e;
let $i = Object.create(null);
const Ir = e => $e(e) && (e.t === 0 || e.type === 0) && ("b" in e || "body" in e);

function CO(e, t = {}) {
    let n = !1;
    const a = t.onError || bL;
    return t.onError = l => {
        n = !0, a(l)
    }, { ...BL(e, t),
        detectError: n
    }
}

function xO(e, t) {
    if (ke(e)) {
        dt(t.warnHtmlMessage) && t.warnHtmlMessage;
        const a = (t.onCacheKey || kO)(e),
            l = $i[a];
        if (l) return l;
        const {
            ast: r,
            detectError: o
        } = CO(e, { ...t,
            location: !1,
            jit: !0
        }), i = yc(r);
        return o ? i : $i[a] = i
    } else {
        const n = e.cacheKey;
        if (n) {
            const a = $i[n];
            return a || ($i[n] = yc(e))
        } else return yc(e)
    }
}
const kg = () => "",
    xn = e => Ze(e);

function Cg(e, ...t) {
    const {
        fallbackFormat: n,
        postTranslation: a,
        unresolving: l,
        messageCompiler: r,
        fallbackLocale: o,
        messages: i
    } = e, [s, u] = _d(...t), c = dt(u.missingWarn) ? u.missingWarn : e.missingWarn, d = dt(u.fallbackWarn) ? u.fallbackWarn : e.fallbackWarn, f = dt(u.escapeParameter) ? u.escapeParameter : e.escapeParameter, v = !!u.resolvedMessage, g = ke(u.default) || dt(u.default) ? dt(u.default) ? r ? s : () => s : u.default : n ? r ? s : () => s : "", h = n || g !== "", y = bv(e, u);
    f && PO(u);
    let [S, b, p] = v ? [s, y, i[y] || {}] : u0(e, s, y, o, d, c), _ = S, w = s;
    if (!v && !(ke(_) || Ir(_) || xn(_)) && h && (_ = g, w = _), !v && (!(ke(_) || Ir(_) || xn(_)) || !ke(b))) return l ? yu : s;
    let k = !1;
    const E = () => {
            k = !0
        },
        P = xn(_) ? _ : c0(e, s, b, _, w, E);
    if (k) return _;
    const x = TO(e, b, p, u),
        T = nO(x),
        V = EO(e, P, T),
        I = a ? a(V, s) : V;
    if (__INTLIFY_PROD_DEVTOOLS__) {
        const R = {
            timestamp: Date.now(),
            key: ke(s) ? s : xn(_) ? _.key : "",
            locale: b || (xn(_) ? _.locale : ""),
            format: ke(_) ? _ : xn(_) ? _.source : "",
            message: I
        };
        R.meta = yt({}, e.__meta, yO() || {}), rO(R)
    }
    return I
}

function PO(e) {
    gt(e.list) ? e.list = e.list.map(t => ke(t) ? cg(t) : t) : $e(e.named) && Object.keys(e.named).forEach(t => {
        ke(e.named[t]) && (e.named[t] = cg(e.named[t]))
    })
}

function u0(e, t, n, a, l, r) {
    const {
        messages: o,
        onWarn: i,
        messageResolver: s,
        localeFallbacker: u
    } = e, c = u(e, a, n);
    let d = {},
        f, v = null;
    const g = "translate";
    for (let h = 0; h < c.length && (f = c[h], d = o[f] || {}, (v = s(d, t)) === null && (v = d[t]), !(ke(v) || Ir(v) || xn(v))); h++)
        if (!SO(f, c)) {
            const y = pv(e, t, f, r, g);
            y !== t && (v = y)
        }
    return [v, f, d]
}

function c0(e, t, n, a, l, r) {
    const {
        messageCompiler: o,
        warnHtmlMessage: i
    } = e;
    if (xn(a)) {
        const u = a;
        return u.locale = u.locale || n, u.key = u.key || t, u
    }
    if (o == null) {
        const u = () => a;
        return u.locale = n, u.key = t, u
    }
    const s = o(a, IO(e, n, l, a, i, r));
    return s.locale = n, s.key = t, s.source = a, s
}

function EO(e, t, n) {
    return t(n)
}

function _d(...e) {
    const [t, n, a] = e, l = {};
    if (!ke(t) && !At(t) && !xn(t) && !Ir(t)) throw ga(Zn.INVALID_ARGUMENT);
    const r = At(t) ? String(t) : (xn(t), t);
    return At(n) ? l.plural = n : ke(n) ? l.default = n : Fe(n) && !mu(n) ? l.named = n : gt(n) && (l.list = n), At(a) ? l.plural = a : ke(a) ? l.default = a : Fe(a) && yt(l, a), [r, l]
}

function IO(e, t, n, a, l, r) {
    return {
        locale: t,
        key: n,
        warnHtmlMessage: l,
        onError: o => {
            throw r && r(o), o
        },
        onCacheKey: o => sL(t, n, o)
    }
}

function TO(e, t, n, a) {
    const {
        modifiers: l,
        pluralRules: r,
        messageResolver: o,
        fallbackLocale: i,
        fallbackWarn: s,
        missingWarn: u,
        fallbackContext: c
    } = e, f = {
        locale: t,
        modifiers: l,
        pluralRules: r,
        messages: v => {
            let g = o(n, v);
            if (g == null && c) {
                const [, , h] = u0(c, v, t, i, s, u);
                g = o(h, v)
            }
            if (ke(g) || Ir(g)) {
                let h = !1;
                const S = c0(e, v, t, g, v, () => {
                    h = !0
                });
                return h ? kg : S
            } else return xn(g) ? g : kg
        }
    };
    return e.processor && (f.processor = e.processor), a.list && (f.list = a.list), a.named && (f.named = a.named), At(a.plural) && (f.pluralIndex = a.plural), f
}

function xg(e, ...t) {
    const {
        datetimeFormats: n,
        unresolving: a,
        fallbackLocale: l,
        onWarn: r,
        localeFallbacker: o
    } = e, {
        __datetimeFormatters: i
    } = e, [s, u, c, d] = Sd(...t), f = dt(c.missingWarn) ? c.missingWarn : e.missingWarn;
    dt(c.fallbackWarn) ? c.fallbackWarn : e.fallbackWarn;
    const v = !!c.part,
        g = bv(e, c),
        h = o(e, l, g);
    if (!ke(s) || s === "") return new Intl.DateTimeFormat(g, d).format(u);
    let y = {},
        S, b = null;
    const p = "datetime format";
    for (let k = 0; k < h.length && (S = h[k], y = n[S] || {}, b = y[s], !Fe(b)); k++) pv(e, s, S, f, p);
    if (!Fe(b) || !ke(S)) return a ? yu : s;
    let _ = `${S}__${s}`;
    mu(d) || (_ = `${_}__${JSON.stringify(d)}`);
    let w = i.get(_);
    return w || (w = new Intl.DateTimeFormat(S, yt({}, b, d)), i.set(_, w)), v ? w.formatToParts(u) : w.format(u)
}
const d0 = ["localeMatcher", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "formatMatcher", "hour12", "timeZone", "dateStyle", "timeStyle", "calendar", "dayPeriod", "numberingSystem", "hourCycle", "fractionalSecondDigits"];

function Sd(...e) {
    const [t, n, a, l] = e, r = {};
    let o = {},
        i;
    if (ke(t)) {
        const s = t.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
        if (!s) throw ga(Zn.INVALID_ISO_DATE_ARGUMENT);
        const u = s[3] ? s[3].trim().startsWith("T") ? `${s[1].trim()}${s[3].trim()}` : `${s[1].trim()}T${s[3].trim()}` : s[1].trim();
        i = new Date(u);
        try {
            i.toISOString()
        } catch {
            throw ga(Zn.INVALID_ISO_DATE_ARGUMENT)
        }
    } else if (cL(t)) {
        if (isNaN(t.getTime())) throw ga(Zn.INVALID_DATE_ARGUMENT);
        i = t
    } else if (At(t)) i = t;
    else throw ga(Zn.INVALID_ARGUMENT);
    return ke(n) ? r.key = n : Fe(n) && Object.keys(n).forEach(s => {
        d0.includes(s) ? o[s] = n[s] : r[s] = n[s]
    }), ke(a) ? r.locale = a : Fe(a) && (o = a), Fe(l) && (o = l), [r.key || "", i, r, o]
}

function Pg(e, t, n) {
    const a = e;
    for (const l in n) {
        const r = `${t}__${l}`;
        a.__datetimeFormatters.has(r) && a.__datetimeFormatters.delete(r)
    }
}

function Eg(e, ...t) {
    const {
        numberFormats: n,
        unresolving: a,
        fallbackLocale: l,
        onWarn: r,
        localeFallbacker: o
    } = e, {
        __numberFormatters: i
    } = e, [s, u, c, d] = wd(...t), f = dt(c.missingWarn) ? c.missingWarn : e.missingWarn;
    dt(c.fallbackWarn) ? c.fallbackWarn : e.fallbackWarn;
    const v = !!c.part,
        g = bv(e, c),
        h = o(e, l, g);
    if (!ke(s) || s === "") return new Intl.NumberFormat(g, d).format(u);
    let y = {},
        S, b = null;
    const p = "number format";
    for (let k = 0; k < h.length && (S = h[k], y = n[S] || {}, b = y[s], !Fe(b)); k++) pv(e, s, S, f, p);
    if (!Fe(b) || !ke(S)) return a ? yu : s;
    let _ = `${S}__${s}`;
    mu(d) || (_ = `${_}__${JSON.stringify(d)}`);
    let w = i.get(_);
    return w || (w = new Intl.NumberFormat(S, yt({}, b, d)), i.set(_, w)), v ? w.formatToParts(u) : w.format(u)
}
const f0 = ["localeMatcher", "style", "currency", "currencyDisplay", "currencySign", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits", "compactDisplay", "notation", "signDisplay", "unit", "unitDisplay", "roundingMode", "roundingPriority", "roundingIncrement", "trailingZeroDisplay"];

function wd(...e) {
    const [t, n, a, l] = e, r = {};
    let o = {};
    if (!At(t)) throw ga(Zn.INVALID_ARGUMENT);
    const i = t;
    return ke(n) ? r.key = n : Fe(n) && Object.keys(n).forEach(s => {
        f0.includes(s) ? o[s] = n[s] : r[s] = n[s]
    }), ke(a) ? r.locale = a : Fe(a) && (o = a), Fe(l) && (o = l), [r.key || "", i, r, o]
}

function Ig(e, t, n) {
    const a = e;
    for (const l in n) {
        const r = `${t}__${l}`;
        a.__numberFormatters.has(r) && a.__numberFormatters.delete(r)
    }
}
FL();
/*!
 * vue-i18n v9.13.1
 * (c) 2024 kazuya kawaguchi
 * Released under the MIT License.
 */
const VO = "9.13.1";

function AO() {
    typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (hv().__INTLIFY_PROD_DEVTOOLS__ = !1)
}
const v0 = iO.__EXTEND_POINT__,
    fa = hu(v0);
fa(), fa(), fa(), fa(), fa(), fa(), fa(), fa(), fa();
const m0 = Zn.__EXTEND_POINT__,
    qt = hu(m0),
    An = {
        UNEXPECTED_RETURN_TYPE: m0,
        INVALID_ARGUMENT: qt(),
        MUST_BE_CALL_SETUP_TOP: qt(),
        NOT_INSTALLED: qt(),
        NOT_AVAILABLE_IN_LEGACY_MODE: qt(),
        REQUIRED_VALUE: qt(),
        INVALID_VALUE: qt(),
        CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: qt(),
        NOT_INSTALLED_WITH_PROVIDE: qt(),
        UNEXPECTED_ERROR: qt(),
        NOT_COMPATIBLE_LEGACY_VUE_I18N: qt(),
        BRIDGE_SUPPORT_VUE_2_ONLY: qt(),
        MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: qt(),
        NOT_AVAILABLE_COMPOSITION_IN_LEGACY: qt(),
        __EXTEND_POINT__: qt()
    };

function Fn(e, ...t) {
    return gu(e, null, void 0)
}
const kd = el("__translateVNode"),
    Cd = el("__datetimeParts"),
    xd = el("__numberParts"),
    LO = el("__setPluralRules"),
    OO = el("__injectWithOption"),
    Pd = el("__dispose");

function Do(e) {
    if (!$e(e)) return e;
    for (const t in e)
        if (ks(e, t))
            if (!t.includes(".")) $e(e[t]) && Do(e[t]);
            else {
                const n = t.split("."),
                    a = n.length - 1;
                let l = e,
                    r = !1;
                for (let o = 0; o < a; o++) {
                    if (n[o] in l || (l[n[o]] = {}), !$e(l[n[o]])) {
                        r = !0;
                        break
                    }
                    l = l[n[o]]
                }
                r || (l[n[a]] = e[t], delete e[t]), $e(l[n[a]]) && Do(l[n[a]])
            }
    return e
}

function h0(e, t) {
    const {
        messages: n,
        __i18n: a,
        messageResolver: l,
        flatJson: r
    } = t, o = Fe(n) ? n : gt(a) ? {} : {
        [e]: {}
    };
    if (gt(a) && a.forEach(i => {
            if ("locale" in i && "resource" in i) {
                const {
                    locale: s,
                    resource: u
                } = i;
                s ? (o[s] = o[s] || {}, kl(u, o[s])) : kl(u, o)
            } else ke(i) && kl(JSON.parse(i), o)
        }), l == null && r)
        for (const i in o) ks(o, i) && Do(o[i]);
    return o
}

function g0(e) {
    return e.type
}

function RO(e, t, n) {
    let a = $e(t.messages) ? t.messages : {};
    "__i18nGlobal" in n && (a = h0(e.locale.value, {
        messages: a,
        __i18n: n.__i18nGlobal
    }));
    const l = Object.keys(a);
    l.length && l.forEach(r => {
        e.mergeLocaleMessage(r, a[r])
    }); {
        if ($e(t.datetimeFormats)) {
            const r = Object.keys(t.datetimeFormats);
            r.length && r.forEach(o => {
                e.mergeDateTimeFormat(o, t.datetimeFormats[o])
            })
        }
        if ($e(t.numberFormats)) {
            const r = Object.keys(t.numberFormats);
            r.length && r.forEach(o => {
                e.mergeNumberFormat(o, t.numberFormats[o])
            })
        }
    }
}

function Tg(e) {
    return m(Sa, null, e, 0)
}
const Vg = "__INTLIFY_META__",
    Ag = () => [],
    DO = () => !1;
let Lg = 0;

function Og(e) {
    return (t, n, a, l) => e(n, a, nn() || void 0, l)
}
const MO = () => {
    const e = nn();
    let t = null;
    return e && (t = g0(e)[Vg]) ? {
        [Vg]: t
    } : null
};

function y0(e = {}, t) {
    const {
        __root: n,
        __injectWithOption: a
    } = e, l = n === void 0, r = e.flatJson, o = Ss ? Q : fe, i = !!e.translateExistCompatible;
    let s = dt(e.inheritLocale) ? e.inheritLocale : !0;
    const u = o(n && s ? n.locale.value : ke(e.locale) ? e.locale : xs),
        c = o(n && s ? n.fallbackLocale.value : ke(e.fallbackLocale) || gt(e.fallbackLocale) || Fe(e.fallbackLocale) || e.fallbackLocale === !1 ? e.fallbackLocale : u.value),
        d = o(h0(u.value, e)),
        f = o(Fe(e.datetimeFormats) ? e.datetimeFormats : {
            [u.value]: {}
        }),
        v = o(Fe(e.numberFormats) ? e.numberFormats : {
            [u.value]: {}
        });
    let g = n ? n.missingWarn : dt(e.missingWarn) || ws(e.missingWarn) ? e.missingWarn : !0,
        h = n ? n.fallbackWarn : dt(e.fallbackWarn) || ws(e.fallbackWarn) ? e.fallbackWarn : !0,
        y = n ? n.fallbackRoot : dt(e.fallbackRoot) ? e.fallbackRoot : !0,
        S = !!e.fallbackFormat,
        b = Ze(e.missing) ? e.missing : null,
        p = Ze(e.missing) ? Og(e.missing) : null,
        _ = Ze(e.postTranslation) ? e.postTranslation : null,
        w = n ? n.warnHtmlMessage : dt(e.warnHtmlMessage) ? e.warnHtmlMessage : !0,
        k = !!e.escapeParameter;
    const E = n ? n.modifiers : Fe(e.modifiers) ? e.modifiers : {};
    let P = e.pluralRules || n && n.pluralRules,
        x;
    x = (() => {
        l && _g(null);
        const q = {
            version: VO,
            locale: u.value,
            fallbackLocale: c.value,
            messages: d.value,
            modifiers: E,
            pluralRules: P,
            missing: p === null ? void 0 : p,
            missingWarn: g,
            fallbackWarn: h,
            fallbackFormat: S,
            unresolving: !0,
            postTranslation: _ === null ? void 0 : _,
            warnHtmlMessage: w,
            escapeParameter: k,
            messageResolver: e.messageResolver,
            messageCompiler: e.messageCompiler,
            __meta: {
                framework: "vue"
            }
        };
        q.datetimeFormats = f.value, q.numberFormats = v.value, q.__datetimeFormatters = Fe(x) ? x.__datetimeFormatters : void 0, q.__numberFormatters = Fe(x) ? x.__numberFormatters : void 0;
        const oe = pO(q);
        return l && _g(oe), oe
    })(), ao(x, u.value, c.value);

    function V() {
        return [u.value, c.value, d.value, f.value, v.value]
    }
    const I = C({
            get: () => u.value,
            set: q => {
                u.value = q, x.locale = u.value
            }
        }),
        R = C({
            get: () => c.value,
            set: q => {
                c.value = q, x.fallbackLocale = c.value, ao(x, u.value, q)
            }
        }),
        B = C(() => d.value),
        $ = C(() => f.value),
        D = C(() => v.value);

    function z() {
        return Ze(_) ? _ : null
    }

    function N(q) {
        _ = q, x.postTranslation = q
    }

    function H() {
        return b
    }

    function F(q) {
        q !== null && (p = Og(q)), b = q, x.missing = p
    }
    const j = (q, oe, Ee, Oe, et, Bt) => {
        V();
        let ln;
        try {
            __INTLIFY_PROD_DEVTOOLS__,
            l || (x.fallbackContext = n ? bO() : void 0),
            ln = q(x)
        }
        finally {
            __INTLIFY_PROD_DEVTOOLS__,
            l || (x.fallbackContext = void 0)
        }
        if (Ee !== "translate exists" && At(ln) && ln === yu || Ee === "translate exists" && !ln) {
            const [pi, er] = oe();
            return n && y ? Oe(n) : et(pi)
        } else {
            if (Bt(ln)) return ln;
            throw Fn(An.UNEXPECTED_RETURN_TYPE)
        }
    };

    function ae(...q) {
        return j(oe => Reflect.apply(Cg, null, [oe, ...q]), () => _d(...q), "translate", oe => Reflect.apply(oe.t, oe, [...q]), oe => oe, oe => ke(oe))
    }

    function he(...q) {
        const [oe, Ee, Oe] = q;
        if (Oe && !$e(Oe)) throw Fn(An.INVALID_ARGUMENT);
        return ae(oe, Ee, yt({
            resolvedMessage: !0
        }, Oe || {}))
    }

    function ve(...q) {
        return j(oe => Reflect.apply(xg, null, [oe, ...q]), () => Sd(...q), "datetime format", oe => Reflect.apply(oe.d, oe, [...q]), () => bg, oe => ke(oe))
    }

    function we(...q) {
        return j(oe => Reflect.apply(Eg, null, [oe, ...q]), () => wd(...q), "number format", oe => Reflect.apply(oe.n, oe, [...q]), () => bg, oe => ke(oe))
    }

    function ee(q) {
        return q.map(oe => ke(oe) || At(oe) || dt(oe) ? Tg(String(oe)) : oe)
    }
    const le = {
        normalize: ee,
        interpolate: q => q,
        type: "vnode"
    };

    function se(...q) {
        return j(oe => {
            let Ee;
            const Oe = oe;
            try {
                Oe.processor = le, Ee = Reflect.apply(Cg, null, [Oe, ...q])
            } finally {
                Oe.processor = null
            }
            return Ee
        }, () => _d(...q), "translate", oe => oe[kd](...q), oe => [Tg(oe)], oe => gt(oe))
    }

    function ce(...q) {
        return j(oe => Reflect.apply(Eg, null, [oe, ...q]), () => wd(...q), "number format", oe => oe[xd](...q), Ag, oe => ke(oe) || gt(oe))
    }

    function re(...q) {
        return j(oe => Reflect.apply(xg, null, [oe, ...q]), () => Sd(...q), "datetime format", oe => oe[Cd](...q), Ag, oe => ke(oe) || gt(oe))
    }

    function pe(q) {
        P = q, x.pluralRules = P
    }

    function A(q, oe) {
        return j(() => {
            if (!q) return !1;
            const Ee = ke(oe) ? oe : u.value,
                Oe = J(Ee),
                et = x.messageResolver(Oe, q);
            return i ? et != null : Ir(et) || xn(et) || ke(et)
        }, () => [q], "translate exists", Ee => Reflect.apply(Ee.te, Ee, [q, oe]), DO, Ee => dt(Ee))
    }

    function O(q) {
        let oe = null;
        const Ee = a0(x, c.value, u.value);
        for (let Oe = 0; Oe < Ee.length; Oe++) {
            const et = d.value[Ee[Oe]] || {},
                Bt = x.messageResolver(et, q);
            if (Bt != null) {
                oe = Bt;
                break
            }
        }
        return oe
    }

    function K(q) {
        const oe = O(q);
        return oe ? ? (n ? n.tm(q) || {} : {})
    }

    function J(q) {
        return d.value[q] || {}
    }

    function X(q, oe) {
        if (r) {
            const Ee = {
                [q]: oe
            };
            for (const Oe in Ee) ks(Ee, Oe) && Do(Ee[Oe]);
            oe = Ee[q]
        }
        d.value[q] = oe, x.messages = d.value
    }

    function ue(q, oe) {
        d.value[q] = d.value[q] || {};
        const Ee = {
            [q]: oe
        };
        if (r)
            for (const Oe in Ee) ks(Ee, Oe) && Do(Ee[Oe]);
        oe = Ee[q], kl(oe, d.value[q]), x.messages = d.value
    }

    function be(q) {
        return f.value[q] || {}
    }

    function L(q, oe) {
        f.value[q] = oe, x.datetimeFormats = f.value, Pg(x, q, oe)
    }

    function M(q, oe) {
        f.value[q] = yt(f.value[q] || {}, oe), x.datetimeFormats = f.value, Pg(x, q, oe)
    }

    function U(q) {
        return v.value[q] || {}
    }

    function ie(q, oe) {
        v.value[q] = oe, x.numberFormats = v.value, Ig(x, q, oe)
    }

    function _e(q, oe) {
        v.value[q] = yt(v.value[q] || {}, oe), x.numberFormats = v.value, Ig(x, q, oe)
    }
    Lg++, n && Ss && (de(n.locale, q => {
        s && (u.value = q, x.locale = q, ao(x, u.value, c.value))
    }), de(n.fallbackLocale, q => {
        s && (c.value = q, x.fallbackLocale = q, ao(x, u.value, c.value))
    }));
    const me = {
        id: Lg,
        locale: I,
        fallbackLocale: R,
        get inheritLocale() {
            return s
        },
        set inheritLocale(q) {
            s = q, q && n && (u.value = n.locale.value, c.value = n.fallbackLocale.value, ao(x, u.value, c.value))
        },
        get availableLocales() {
            return Object.keys(d.value).sort()
        },
        messages: B,
        get modifiers() {
            return E
        },
        get pluralRules() {
            return P || {}
        },
        get isGlobal() {
            return l
        },
        get missingWarn() {
            return g
        },
        set missingWarn(q) {
            g = q, x.missingWarn = g
        },
        get fallbackWarn() {
            return h
        },
        set fallbackWarn(q) {
            h = q, x.fallbackWarn = h
        },
        get fallbackRoot() {
            return y
        },
        set fallbackRoot(q) {
            y = q
        },
        get fallbackFormat() {
            return S
        },
        set fallbackFormat(q) {
            S = q, x.fallbackFormat = S
        },
        get warnHtmlMessage() {
            return w
        },
        set warnHtmlMessage(q) {
            w = q, x.warnHtmlMessage = q
        },
        get escapeParameter() {
            return k
        },
        set escapeParameter(q) {
            k = q, x.escapeParameter = q
        },
        t: ae,
        getLocaleMessage: J,
        setLocaleMessage: X,
        mergeLocaleMessage: ue,
        getPostTranslationHandler: z,
        setPostTranslationHandler: N,
        getMissingHandler: H,
        setMissingHandler: F,
        [LO]: pe
    };
    return me.datetimeFormats = $, me.numberFormats = D, me.rt = he, me.te = A, me.tm = K, me.d = ve, me.n = we, me.getDateTimeFormat = be, me.setDateTimeFormat = L, me.mergeDateTimeFormat = M, me.getNumberFormat = U, me.setNumberFormat = ie, me.mergeNumberFormat = _e, me[OO] = a, me[kd] = se, me[Cd] = re, me[xd] = ce, me
}
const _v = {
    tag: {
        type: [String, Object]
    },
    locale: {
        type: String
    },
    scope: {
        type: String,
        validator: e => e === "parent" || e === "global",
        default: "parent"
    },
    i18n: {
        type: Object
    }
};

function NO({
    slots: e
}, t) {
    return t.length === 1 && t[0] === "default" ? (e.default ? e.default() : []).reduce((a, l) => [...a, ...l.type === ye ? l.children : [l]], []) : t.reduce((n, a) => {
        const l = e[a];
        return l && (n[a] = l()), n
    }, {})
}

function b0(e) {
    return ye
}
const $O = Ln({
        name: "i18n-t",
        props: yt({
            keypath: {
                type: String,
                required: !0
            },
            plural: {
                type: [Number, String],
                validator: e => At(e) || !isNaN(e)
            }
        }, _v),
        setup(e, t) {
            const {
                slots: n,
                attrs: a
            } = t, l = e.i18n || ui({
                useScope: e.scope,
                __useComponent: !0
            });
            return () => {
                const r = Object.keys(n).filter(d => d !== "_"),
                    o = {};
                e.locale && (o.locale = e.locale), e.plural !== void 0 && (o.plural = ke(e.plural) ? +e.plural : e.plural);
                const i = NO(t, r),
                    s = l[kd](e.keypath, i, o),
                    u = yt({}, a),
                    c = ke(e.tag) || $e(e.tag) ? e.tag : b0();
                return ht(c, u, s)
            }
        }
    }),
    Rg = $O;

function BO(e) {
    return gt(e) && !ke(e[0])
}

function p0(e, t, n, a) {
    const {
        slots: l,
        attrs: r
    } = t;
    return () => {
        const o = {
            part: !0
        };
        let i = {};
        e.locale && (o.locale = e.locale), ke(e.format) ? o.key = e.format : $e(e.format) && (ke(e.format.key) && (o.key = e.format.key), i = Object.keys(e.format).reduce((f, v) => n.includes(v) ? yt({}, f, {
            [v]: e.format[v]
        }) : f, {}));
        const s = a(e.value, o, i);
        let u = [o.key];
        gt(s) ? u = s.map((f, v) => {
            const g = l[f.type],
                h = g ? g({
                    [f.type]: f.value,
                    index: v,
                    parts: s
                }) : [f.value];
            return BO(h) && (h[0].key = `${f.type}-${v}`), h
        }) : ke(s) && (u = [s]);
        const c = yt({}, r),
            d = ke(e.tag) || $e(e.tag) ? e.tag : b0();
        return ht(d, c, u)
    }
}
const FO = Ln({
        name: "i18n-n",
        props: yt({
            value: {
                type: Number,
                required: !0
            },
            format: {
                type: [String, Object]
            }
        }, _v),
        setup(e, t) {
            const n = e.i18n || ui({
                useScope: e.scope,
                __useComponent: !0
            });
            return p0(e, t, f0, (...a) => n[xd](...a))
        }
    }),
    Dg = FO,
    HO = Ln({
        name: "i18n-d",
        props: yt({
            value: {
                type: [Number, Date],
                required: !0
            },
            format: {
                type: [String, Object]
            }
        }, _v),
        setup(e, t) {
            const n = e.i18n || ui({
                useScope: e.scope,
                __useComponent: !0
            });
            return p0(e, t, d0, (...a) => n[Cd](...a))
        }
    }),
    Mg = HO;

function jO(e, t) {
    const n = e;
    if (e.mode === "composition") return n.__getInstance(t) || e.global; {
        const a = n.__getInstance(t);
        return a != null ? a.__composer : e.global.__composer
    }
}

function UO(e) {
    const t = o => {
        const {
            instance: i,
            modifiers: s,
            value: u
        } = o;
        if (!i || !i.$) throw Fn(An.UNEXPECTED_ERROR);
        const c = jO(e, i.$),
            d = Ng(u);
        return [Reflect.apply(c.t, c, [...$g(d)]), c]
    };
    return {
        created: (o, i) => {
            const [s, u] = t(i);
            Ss && e.global === u && (o.__i18nWatcher = de(u.locale, () => {
                i.instance && i.instance.$forceUpdate()
            })), o.__composer = u, o.textContent = s
        },
        unmounted: o => {
            Ss && o.__i18nWatcher && (o.__i18nWatcher(), o.__i18nWatcher = void 0, delete o.__i18nWatcher), o.__composer && (o.__composer = void 0, delete o.__composer)
        },
        beforeUpdate: (o, {
            value: i
        }) => {
            if (o.__composer) {
                const s = o.__composer,
                    u = Ng(i);
                o.textContent = Reflect.apply(s.t, s, [...$g(u)])
            }
        },
        getSSRProps: o => {
            const [i] = t(o);
            return {
                textContent: i
            }
        }
    }
}

function Ng(e) {
    if (ke(e)) return {
        path: e
    };
    if (Fe(e)) {
        if (!("path" in e)) throw Fn(An.REQUIRED_VALUE, "path");
        return e
    } else throw Fn(An.INVALID_VALUE)
}

function $g(e) {
    const {
        path: t,
        locale: n,
        args: a,
        choice: l,
        plural: r
    } = e, o = {}, i = a || {};
    return ke(n) && (o.locale = n), At(l) && (o.plural = l), At(r) && (o.plural = r), [t, i, o]
}

function WO(e, t, ...n) {
    const a = Fe(n[0]) ? n[0] : {},
        l = !!a.useI18nComponentName;
    (dt(a.globalInstall) ? a.globalInstall : !0) && ([l ? "i18n" : Rg.name, "I18nT"].forEach(o => e.component(o, Rg)), [Dg.name, "I18nN"].forEach(o => e.component(o, Dg)), [Mg.name, "I18nD"].forEach(o => e.component(o, Mg))), e.directive("t", UO(t))
}
const zO = el("global-vue-i18n");

function KO(e = {}, t) {
    const n = dt(e.globalInjection) ? e.globalInjection : !0,
        a = !0,
        l = new Map,
        [r, o] = GO(e),
        i = el("");

    function s(d) {
        return l.get(d) || null
    }

    function u(d, f) {
        l.set(d, f)
    }

    function c(d) {
        l.delete(d)
    } {
        const d = {
            get mode() {
                return "composition"
            },
            get allowComposition() {
                return a
            },
            async install(f, ...v) {
                if (f.__VUE_I18N_SYMBOL__ = i, f.provide(f.__VUE_I18N_SYMBOL__, d), Fe(v[0])) {
                    const y = v[0];
                    d.__composerExtend = y.__composerExtend, d.__vueI18nExtend = y.__vueI18nExtend
                }
                let g = null;
                n && (g = tR(f, d.global)), WO(f, d, ...v);
                const h = f.unmount;
                f.unmount = () => {
                    g && g(), d.dispose(), h()
                }
            },
            get global() {
                return o
            },
            dispose() {
                r.stop()
            },
            __instances: l,
            __getInstance: s,
            __setInstance: u,
            __deleteInstance: c
        };
        return d
    }
}

function ui(e = {}) {
    const t = nn();
    if (t == null) throw Fn(An.MUST_BE_CALL_SETUP_TOP);
    if (!t.isCE && t.appContext.app != null && !t.appContext.app.__VUE_I18N_SYMBOL__) throw Fn(An.NOT_INSTALLED);
    const n = YO(t),
        a = XO(n),
        l = g0(t),
        r = qO(e, l);
    if (r === "global") return RO(a, e, l), a;
    if (r === "parent") {
        let s = JO(n, t, e.__useComponent);
        return s == null && (s = a), s
    }
    const o = n;
    let i = o.__getInstance(t);
    if (i == null) {
        const s = yt({}, e);
        "__i18n" in l && (s.__i18n = l.__i18n), a && (s.__root = a), i = y0(s), o.__composerExtend && (i[Pd] = o.__composerExtend(i)), QO(o, t, i), o.__setInstance(t, i)
    }
    return i
}

function GO(e, t, n) {
    const a = xa(); {
        const l = a.run(() => y0(e));
        if (l == null) throw Fn(An.UNEXPECTED_ERROR);
        return [a, l]
    }
}

function YO(e) {
    {
        const t = Te(e.isCE ? zO : e.appContext.app.__VUE_I18N_SYMBOL__);
        if (!t) throw Fn(e.isCE ? An.NOT_INSTALLED_WITH_PROVIDE : An.UNEXPECTED_ERROR);
        return t
    }
}

function qO(e, t) {
    return mu(e) ? "__i18n" in t ? "local" : "global" : e.useScope ? e.useScope : "local"
}

function XO(e) {
    return e.mode === "composition" ? e.global : e.global.__composer
}

function JO(e, t, n = !1) {
    let a = null;
    const l = t.root;
    let r = ZO(t, n);
    for (; r != null;) {
        const o = e;
        if (e.mode === "composition" && (a = o.__getInstance(r)), a != null || l === r) break;
        r = r.parent
    }
    return a
}

function ZO(e, t = !1) {
    return e == null ? null : t && e.vnode.ctx || e.parent
}

function QO(e, t, n) {
    it(() => {}, t), jr(() => {
        const a = n;
        e.__deleteInstance(t);
        const l = a[Pd];
        l && (l(), delete a[Pd])
    }, t)
}
const eR = ["locale", "fallbackLocale", "availableLocales"],
    Bg = ["t", "rt", "d", "n", "tm", "te"];

function tR(e, t) {
    const n = Object.create(null);
    return eR.forEach(l => {
        const r = Object.getOwnPropertyDescriptor(t, l);
        if (!r) throw Fn(An.UNEXPECTED_ERROR);
        const o = Ge(r.value) ? {
            get() {
                return r.value.value
            },
            set(i) {
                r.value.value = i
            }
        } : {
            get() {
                return r.get && r.get()
            }
        };
        Object.defineProperty(n, l, o)
    }), e.config.globalProperties.$i18n = n, Bg.forEach(l => {
        const r = Object.getOwnPropertyDescriptor(t, l);
        if (!r || !r.value) throw Fn(An.UNEXPECTED_ERROR);
        Object.defineProperty(e.config.globalProperties, `$${l}`, r)
    }), () => {
        delete e.config.globalProperties.$i18n, Bg.forEach(l => {
            delete e.config.globalProperties[`$${l}`]
        })
    }
}
AO();
vO(xO);
mO(YL);
hO(a0);
if (__INTLIFY_PROD_DEVTOOLS__) {
    const e = hv();
    e.__INTLIFY__ = !0, aO(e.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__)
}
const Al = ["ar-AE", "en-US"],
    Ps = {
        "ar-AE": [{
            key: "../locales/ar-AE.js",
            load: () => Je(() =>
                import ("./6KkS06ME.js"), [],
                import.meta.url),
            cache: !0
        }],
        "en-US": [{
            key: "../locales/en-US.js",
            load: () => Je(() =>
                import ("./BR4nEVJX.js"), [],
                import.meta.url),
            cache: !0
        }]
    },
    nR = [() => Je(() =>
        import ("./B-MQlEFZ.js"), [],
        import.meta.url)],
    bu = [{
        code: "ar-AE",
        name: "العربية",
        dir: "rtl",
        files: [{
            path: "locales/ar-AE.js"
        }]
    }, {
        code: "en-US",
        name: "English",
        files: [{
            path: "locales/en-US.js"
        }]
    }],
    _0 = "@nuxtjs/i18n",
    aR = !1,
    lR = !1,
    rR = "nuxtI18n",
    oR = "i18n_redirected",
    Fg = "nuxt-i18n-slp",
    po = new Map;
async function iR(e, t) {
    const n = {
        messages: {}
    };
    for (const a of e) {
        const {
            default: l
        } = await a(), r = typeof l == "function" ? await t.runWithContext(async () => await l()) : l;
        kl(r, n)
    }
    return n
}

function S0(e, t) {
    let n = [];
    if (gt(e)) n = e;
    else if ($e(e)) {
        const a = [...t, "default"];
        for (const l of a) e[l] && (n = [...n, ...e[l].filter(Boolean)])
    } else ke(e) && t.every(a => a !== e) && n.push(e);
    return n
}
async function sR(e, t, n) {
    const {
        defaultLocale: a,
        initialLocale: l,
        localeCodes: r,
        fallbackLocale: o,
        lazy: i
    } = n;
    if (i && o) {
        const u = S0(o, [a, l]);
        await Promise.all(u.map(c => Hg(c, t, e)))
    }
    const s = i ? [...new Set().add(a).add(l)] : r;
    return await Promise.all(s.map(u => Hg(u, t, e))), e
}
async function uR(e, {
    key: t,
    load: n
}) {
    let a = null;
    try {
        const l = await n().then(r => r.default || r);
        Ze(l) ? a = await l(e) : (a = l, a != null && po && po.set(t, a))
    } catch (l) {
        console.error("Failed locale loading: " + l.message)
    }
    return a
}
async function Es(e, t, n) {
    const a = t[e];
    if (a == null) {
        console.warn("Could not find messages for locale code: " + e);
        return
    }
    const l = {};
    for (const r of a) {
        let o = null;
        po && po.has(r.key) && r.cache ? o = po.get(r.key) : o = await uR(e, r), o != null && kl(o, l)
    }
    n(e, l)
}
async function Hg(e, t, n) {
    await Es(e, t, (l, r) => {
        const o = n[l] || {};
        kl(r, o), n[l] = o
    })
}
const cR = typeof window < "u";

function dR(e) {
    e = e || [];
    const t = [];
    for (const n of e) ke(n) ? t.push({
        code: n
    }) : t.push(n);
    return t
}

function fR(e) {
    return e != null && "global" in e && "mode" in e
}

function vR(e) {
    return e != null && !("__composer" in e) && "locale" in e && Ge(e.locale)
}

function w0(e) {
    return e != null && "__composer" in e
}

function nl(e) {
    return fR(e) ? e.global : e
}

function Tr(e) {
    const t = nl(e);
    return vR(t) ? t : w0(t) ? t.__composer : t
}

function pu(e) {
    return Ie(nl(e).locale)
}

function mR(e) {
    return Ie(nl(e).locales)
}

function hR(e) {
    return Ie(nl(e).localeCodes)
}

function k0(e, t) {
    const n = nl(e);
    Ge(n.locale) ? n.locale.value = t : n.locale = t
}

function C0(e) {
    return ke(e) ? e : fL(e) ? e.toString() : "(null)"
}

function jg(e, t, {
    defaultLocale: n,
    strategy: a,
    routesNameSeparator: l,
    defaultLocaleRouteNameSuffix: r
}) {
    let o = C0(e) + (a === "no_prefix" ? "" : l + t);
    return t === n && a === "prefix_and_default" && (o += l + r), o
}

function Ug(e, t) {
    return Ze(e) ? e(t) : e
}

function gR(e, t) {
    const n = [];
    for (const [a, l] of t.entries()) {
        const r = e.find(o => o.iso.toLowerCase() === l.toLowerCase());
        if (r) {
            n.push({
                code: r.code,
                score: 1 - a / t.length
            });
            break
        }
    }
    for (const [a, l] of t.entries()) {
        const r = l.split("-")[0].toLowerCase(),
            o = e.find(i => i.iso.split("-")[0].toLowerCase() === r);
        if (o) {
            n.push({
                code: o.code,
                score: .999 - a / t.length
            });
            break
        }
    }
    return n
}
const yR = gR;

function bR(e, t) {
    return e.score === t.score ? t.code.length - e.code.length : t.score - e.score
}
const pR = bR;

function _R(e, t, {
    matcher: n = yR,
    comparer: a = pR
} = {}) {
    const l = [];
    for (const o of e) {
        const {
            code: i
        } = o, s = o.iso || i;
        l.push({
            code: i,
            iso: s
        })
    }
    const r = n(l, t);
    return r.length > 1 && r.sort(a), r.length ? r[0].code : ""
}

function Is(e) {
    return new RegExp(`^/(${e.join("|")})(?:/|$)`, "i")
}

function SR(e, t) {
    return [e.slice(0, t), e.slice(t)]
}

function wR(e) {
    const {
        fullPath: t,
        query: n,
        hash: a,
        name: l,
        path: r,
        params: o,
        meta: i,
        redirectedFrom: s,
        matched: u
    } = e;
    return {
        fullPath: t,
        params: o,
        query: n,
        hash: a,
        name: l,
        path: r,
        meta: i,
        matched: u,
        redirectedFrom: s
    }
}

function kR({
    router: e
}, t, n, a) {
    var u, c;
    if (n !== "prefix") return e.resolve(t);
    const [l, r] = SR(t.path, 1), o = `${l}${a}${r===""?r:`/${r}`}`, i = (c = (u = e.options) == null ? void 0 : u.routes) == null ? void 0 : c.find(d => d.path === o);
    if (i == null) return t;
    const s = yt({}, t, i);
    return s.path = o, e.resolve(s)
}
const CR = new Set(["prefix_and_default", "prefix_except_default"]);

function xR(e) {
    const {
        currentLocale: t,
        defaultLocale: n,
        strategy: a
    } = e;
    return !(t === n && CR.has(a)) && a !== "no_prefix"
}
const PR = xR;

function Vr(e, t) {
    const {
        routesNameSeparator: n
    } = e.runtimeConfig.public.i18n, a = Ie(t);
    return a == null || !a.name ? void 0 : C0(a.name).split(n)[0]
}

function Sv(e, t, n) {
    var l;
    if (typeof t == "string" && aa(t, {
            acceptRelative: !0
        })) return t;
    const a = _u(e, t, n);
    return a == null ? "" : ((l = a.redirectedFrom) == null ? void 0 : l.fullPath) || a.fullPath
}

function wv(e, t, n) {
    return _u(e, t, n) ? ? void 0
}

function ER(e, t, n) {
    return _u(e, t, n) ? ? void 0
}

function _u(e, t, n) {
    const {
        router: a,
        i18n: l
    } = e, r = n || pu(l), {
        routesNameSeparator: o,
        defaultLocale: i,
        defaultLocaleRouteNameSuffix: s,
        strategy: u,
        trailingSlash: c
    } = e.runtimeConfig.public.i18n, d = HR(e.runtimeConfig);
    let f;
    if (ke(t))
        if (t[0] === "/") {
            const {
                pathname: h,
                search: y,
                hash: S
            } = td(t), b = n_(y);
            f = {
                path: h,
                query: b,
                hash: S
            }
        } else f = {
            name: t
        };
    else f = t;
    let v = yt({}, f);
    if ((h => "path" in h && !!h.path && !("name" in h))(v)) {
        const h = kR(e, v, u, r),
            y = Vr(e, h);
        ke(y) ? (v = {
            name: jg(y, r, {
                defaultLocale: i,
                strategy: u,
                routesNameSeparator: o,
                defaultLocaleRouteNameSuffix: s
            }),
            params: h.params,
            query: h.query,
            hash: h.hash
        }, v.state = h.state) : (d({
            currentLocale: r,
            defaultLocale: i,
            strategy: u
        }) && (v.path = `/${r}${v.path}`), v.path = c ? gs(v.path, !0) : su(v.path, !0))
    } else !v.name && !("path" in v) && (v.name = Vr(e, a.currentRoute.value)), v.name = jg(v.name, r, {
        defaultLocale: i,
        strategy: u,
        routesNameSeparator: o,
        defaultLocaleRouteNameSuffix: s
    });
    try {
        const h = a.resolve(v);
        return h.name ? h : a.resolve(t)
    } catch (h) {
        if (typeof h == "object" && "type" in h && h.type === 1) return null
    }
}
const IR = e => e;

function TR(e, t) {
    var a;
    if (e.runtimeConfig.public.i18n.experimental.switchLocalePathLinkSSR) return Ie(e.metaState.value);
    const n = t.meta || {};
    return ((a = Ie(n)) == null ? void 0 : a[rR]) || {}
}

function Ar(e, t, n) {
    const a = n ? ? e.router.currentRoute.value,
        l = Vr(e, a);
    if (!l) return "";
    const r = jR(e.runtimeConfig),
        o = wR(a),
        i = TR(e, a)[t],
        s = { ...o,
            name: l,
            params: { ...o.params,
                ...i
            }
        },
        u = Sv(e, s, t);
    return r(u, t)
}

function x0(e, {
    addDirAttribute: t = !1,
    addSeoAttributes: n = !0,
    identifierAttribute: a = "hid"
}) {
    const {
        defaultDirection: l
    } = Ut().public.i18n, r = Tr(e.i18n), o = {
        htmlAttrs: {},
        link: [],
        meta: []
    };
    if (Ie(r.locales) == null || Ie(r.baseUrl) == null) return o;
    const i = pu(e.i18n),
        s = mR(e.i18n),
        u = dR(s).find(f => f.code === i) || {
            code: i
        },
        c = u.iso,
        d = u.dir || l;
    return t && (o.htmlAttrs.dir = d), n && i && Ie(r.locales) && (c && (o.htmlAttrs.lang = c), o.link.push(...VR(e, Ie(s), a), ...AR(e, a, n)), o.meta.push(...LR(e, a, n), ...OR(u, c, a), ...RR(Ie(s), c, a))), o
}

function kv() {
    const e = Ye(),
        t = Tr(e.$i18n);
    return Ur(Ie(t.baseUrl), e.$config.app.baseURL)
}

function VR(e, t, n) {
    const a = kv(),
        {
            defaultLocale: l,
            strategy: r
        } = Ut().public.i18n,
        o = [];
    if (r === "no_prefix") return o;
    const i = new Map;
    for (const s of t) {
        const u = s.iso;
        if (!u) {
            console.warn("Locale ISO code is required to generate alternate link");
            continue
        }
        const [c, d] = u.split("-");
        c && d && (s.isCatchallLocale || !i.has(c)) && i.set(c, s), i.set(u, s)
    }
    for (const [s, u] of i.entries()) {
        const c = Ar(e, u.code);
        c && o.push({
            [n]: `i18n-alt-${s}`,
            rel: "alternate",
            href: Ed(c, a),
            hreflang: s
        })
    }
    if (l) {
        const s = Ar(e, l);
        s && o.push({
            [n]: "i18n-xd",
            rel: "alternate",
            href: Ed(s, a),
            hreflang: "x-default"
        })
    }
    return o
}

function P0(e, t, n) {
    const a = e.router.currentRoute.value,
        l = wv(e, { ...a,
            path: void 0,
            name: Vr(e, a)
        });
    if (!l) return "";
    let r = Ed(l.path, t);
    const o = $e(n) && n.canonicalQueries || [],
        i = l.query,
        s = new URLSearchParams;
    for (const c of o)
        if (c in i) {
            const d = i[c];
            gt(d) ? d.forEach(f => s.append(c, f || "")) : s.append(c, d || "")
        }
    const u = s.toString();
    return u && (r = `${r}?${u}`), r
}

function AR(e, t, n) {
    const a = kv(),
        l = P0(e, a, n);
    return l ? [{
        [t]: "i18n-can",
        rel: "canonical",
        href: l
    }] : []
}

function LR(e, t, n) {
    const a = kv(),
        l = P0(e, a, n);
    return l ? [{
        [t]: "i18n-og-url",
        property: "og:url",
        content: l
    }] : []
}

function OR(e, t, n) {
    return !e || !t ? [] : [{
        [n]: "i18n-og",
        property: "og:locale",
        content: E0(t)
    }]
}

function RR(e, t, n) {
    return e.filter(l => l.iso && l.iso !== t).map(l => ({
        [n]: `i18n-og-alt-${l.iso}`,
        property: "og:locale:alternate",
        content: E0(l.iso)
    }))
}

function E0(e) {
    return (e || "").replace(/-/g, "_")
}

function Ed(e, t) {
    return e.match(/^https?:\/\//) ? e : Ur(t, e)
}

function DR(e, t) {
    return Su(e, "setLocaleCookie", t)
}

function I0(e, t, n) {
    return Su(e, "mergeLocaleMessage", t, n)
}

function MR(e, t, n, a, l) {
    return Su(e, "onBeforeLanguageSwitch", t, n, a, l)
}

function NR(e, t, n) {
    return Su(e, "onLanguageSwitched", t, n)
}

function Cv(e) {
    return {
        i18n: e ? ? Ye().$i18n,
        router: Vn(),
        runtimeConfig: Ut(),
        metaState: K_("nuxt-i18n-meta", () => ({}))
    }
}
async function Wg(e, t, n, a = !1) {
    const {
        differentDomains: l,
        skipSettingLocaleOnNavigate: r,
        lazy: o
    } = n, i = ci(n), s = Ye(), u = pu(t), c = hR(t);

    function d(v = u) {
        i === !1 || !i.useCookie || r || DR(t, v)
    }
    if (!e || !a && l || u === e) return d(), !1;
    const f = await MR(t, u, e, a, s);
    if (f && c.includes(f)) {
        if (u === f) return d(), !1;
        e = f
    }
    if (o) {
        const v = WR(t, "fallbackLocale"),
            g = (h, y) => I0(t, h, y);
        if (v) {
            const h = S0(v, [e]);
            await Promise.all(h.map(y => Es(y, Ps, g)))
        }
        await Es(e, Ps, g)
    }
    return r ? !1 : (d(e), k0(t, e), await NR(t, u, e), !0)
}

function zg(e, t, n, a, l, r) {
    const {
        strategy: o,
        defaultLocale: i,
        differentDomains: s
    } = r, u = ci(r), c = Ze(a) ? a() : a, {
        ssg: d,
        callType: f,
        firstAccess: v,
        localeCookie: g
    } = l, {
        locale: h,
        stat: y,
        reason: S,
        from: b
    } = u ? YR(e, n, l, c) : GR;
    if (S === "detect_ignore_on_ssg") return c;
    if ((b === "navigator_or_header" || b === "cookie" || b === "fallback") && h) return h;
    let p = h;
    return p || (s ? p = XR(bu, o, e) : o !== "no_prefix" ? p = t(e) : u || (p = c)), !p && u && u.useCookie && (p = g || ""), p || (p = i || ""), p
}

function Kg({
    route: e,
    targetLocale: t,
    routeLocaleGetter: n,
    calledWithRouting: a = !1
}) {
    const l = Ye(),
        r = Cv(),
        {
            strategy: o,
            differentDomains: i
        } = r.runtimeConfig.public.i18n;
    let s = "";
    const {
        fullPath: u
    } = e.to;
    if (!i && (a || o !== "no_prefix") && n(e.to) !== t) {
        const c = l.$switchLocalePath(t) || l.$localePath(u, t);
        ke(c) && c && !ed(c, u) && !c.startsWith("//") && (s = e.from && e.from.fullPath === c ? "" : c)
    }
    if ((i || lR) && n(e.to) !== t) {
        const c = Ar(r, t, e.to);
        ke(c) && c && !ed(c, u) && !c.startsWith("//") && (s = c)
    }
    return s
}

function $R(e) {
    return $e(e) && "path" in e && "statusCode" in e
}
const BR = () => K_(_0 + ":redirect", () => "");

function Gg(e, t) {
    return KI(e, {
        redirectCode: t
    })
}
async function Yg(e, {
    status: t = 302,
    enableNavigate: n = !1
} = {}) {
    const {
        nuxtApp: a,
        i18n: l,
        locale: r,
        route: o
    } = e, {
        rootRedirect: i,
        differentDomains: s,
        skipSettingLocaleOnNavigate: u
    } = a.$config.public.i18n;
    let {
        redirectPath: c
    } = e;
    if (o.path === "/" && i) return ke(i) ? c = "/" + i : $R(i) && (c = "/" + i.path, t = i.statusCode), c = a.$localePath(c, r), Gg(c, t);
    if (!(u && (l.__pendingLocale = r, l.__pendingLocalePromise = new Promise(d => {
            l.__resolvePendingLocalePromise = d
        }), !n))) {
        if (s) {
            const d = BR();
            d.value && d.value !== c && (d.value = "", window.location.assign(c))
        } else if (c) return Gg(c, t)
    }
}

function FR(e, t) {
    nr(e, "$i18n", nl(t)), nr(e, "$getRouteBaseName", un(Vr)), nr(e, "$localePath", un(Sv)), nr(e, "$localeRoute", un(wv)), nr(e, "$switchLocalePath", un(Ar)), nr(e, "$localeHead", un(x0))
}

function HR(e = Ut()) {
    return t => PR(t) && !e.public.i18n.differentDomains
}

function jR(e = Ut()) {
    return (t, n) => {
        if (e.public.i18n.differentDomains) {
            const a = A0(n);
            return a ? Ur(a, t) : t
        } else return IR(t)
    }
}

function UR() {
    return () => {
        const e = Ye(),
            {
                baseUrl: t,
                defaultLocale: n,
                differentDomains: a
            } = e.$config.public.i18n;
        if (Ze(t)) return t(e);
        const l = Ze(n) ? n() : n;
        if (a && l) {
            const r = A0(l);
            if (r) return r
        }
        return t
    }
}

function T0(e) {
    return _0 + " " + e
}

function Su(e, t, ...n) {
    const a = nl(e),
        [l, r] = [a, a[t]];
    return Reflect.apply(r, l, [...n])
}

function WR(e, t) {
    const n = nl(e);
    return Ie(n[t])
}

function nr(e, t, n) {
    Object.defineProperty(e, t, {
        get: () => n
    })
}

function un(e, t = Cv()) {
    return (...n) => e(t, ...n)
}

function V0() {
    let e;
    return navigator.languages && (e = _R(bu, navigator.languages)), e
}

function zR() {
    const e = ci(),
        t = e && e.cookieKey || oR,
        n = new Date,
        a = {
            expires: new Date(n.setDate(n.getDate() + 365)),
            path: "/",
            sameSite: e && e.cookieCrossOrigin ? "none" : "lax",
            secure: e && e.cookieCrossOrigin || e && e.cookieSecure
        };
    return e && e.cookieDomain && (a.domain = e.cookieDomain), LA(t, a)
}

function bc(e, t, n) {
    if (t === !1 || !t.useCookie) return;
    const a = e.value ? ? void 0;
    if (a != null) {
        if (Al.includes(a)) return a;
        if (n) return e.value = n, n;
        e.value = void 0
    }
}

function KR(e, t, n) {
    n === !1 || !n.useCookie || (e.value = t)
}
const GR = {
    locale: "",
    stat: !1,
    reason: "unknown",
    from: "unknown"
};

function YR(e, t, n, a = "") {
    const {
        strategy: l
    } = Ut().public.i18n, {
        ssg: r,
        callType: o,
        firstAccess: i,
        localeCookie: s
    } = n;
    if (!i) return {
        locale: l === "no_prefix" ? a : "",
        stat: !1,
        reason: "first_access_only"
    };
    const {
        redirectOn: u,
        alwaysRedirect: c,
        useCookie: d,
        fallbackLocale: f
    } = ci(), v = ke(e) ? e : e.path;
    if (l !== "no_prefix") {
        if (u === "root") {
            if (v !== "/") return {
                locale: "",
                stat: !1,
                reason: "not_redirect_on_root"
            }
        } else if (u === "no prefix" && !c && v.match(Is(Al))) return {
            locale: "",
            stat: !1,
            reason: "not_redirect_on_no_prefix"
        }
    }
    let g = "unknown",
        h, y;
    d && (y = h = s, g = "cookie"), y || (y = V0(), g = "navigator_or_header");
    const S = y || f;
    !y && f && (g = "fallback");
    const b = a || t;
    if (S && (!d || c || !h)) {
        if (l === "no_prefix") return {
            locale: S,
            stat: !0,
            from: g
        };
        if (o === "setup" && S !== b) return {
            locale: S,
            stat: !0,
            from: g
        };
        if (c) {
            const p = v === "/",
                _ = u === "all",
                w = u === "no prefix" && !v.match(Is(Al));
            if (p || _ || w) return {
                locale: S,
                stat: !0,
                from: g
            }
        }
    }
    return r === "ssg_setup" && S ? {
        locale: S,
        stat: !0,
        from: g
    } : (g === "navigator_or_header" || g === "cookie") && S ? {
        locale: S,
        stat: !0,
        from: g
    } : {
        locale: "",
        stat: !1,
        reason: "not_found_match"
    }
}

function qR() {
    let e;
    return e = window.location.host, e
}

function XR(e, t, n) {
    let a = qR() || "";
    if (a) {
        let l;
        const r = e.filter(o => {
            if (o && o.domain) {
                let i = o.domain;
                return aa(o.domain) && (i = o.domain.replace(/(http|https):\/\//, "")), i === a
            }
            return !1
        });
        if (r.length === 1) l = r[0];
        else if (r.length > 1)
            if (t === "no_prefix") console.warn(T0("Multiple matching domains found! This is not supported for no_prefix strategy in combination with differentDomains!")), l = r[0];
            else {
                if (n) {
                    const o = $e(n) ? n.path : ke(n) ? n : "";
                    if (o && o !== "") {
                        const i = o.match(Is(r.map(s => s.code)));
                        i && i.length > 1 && (l = r.find(s => s.code === i[1]))
                    }
                }
                l || (l = r.find(o => o.domainDefault))
            }
        if (l) return l.code;
        a = ""
    }
    return a
}

function A0(e) {
    var r, o;
    const t = Ut();
    Ye();
    const n = t.public.i18n,
        a = bu.find(i => i.code === e),
        l = ((o = (r = n == null ? void 0 : n.locales) == null ? void 0 : r[e]) == null ? void 0 : o.domain) ? ? (a == null ? void 0 : a.domain);
    if (l) {
        if (aa(l, {
                strict: !0
            })) return l;
        let i;
        return i = new URL(window.location.origin).protocol, i + "//" + l
    }
    console.warn(T0("Could not find domain name for locale " + e))
}
const ci = (e = Ut().public.i18n) => (e == null ? void 0 : e.detectBrowserLanguage) === !1 ? !1 : e == null ? void 0 : e.detectBrowserLanguage;

function JR() {
    return un(Ar)
}

function ZR(e, {
    locales: t = [],
    localeCodes: n = [],
    baseUrl: a = "",
    hooks: l = {},
    context: r = {}
} = {}) {
    const o = xa(),
        i = e.install;
    return e.install = (s, ...u) => {
        const c = tD(u[0]) ? yt({}, u[0]) : {
            inject: !0
        };
        c.inject == null && (c.inject = !0);
        const d = c.__composerExtend;
        if (c.__composerExtend = h => {
                const y = Tr(e);
                h.locales = C(() => y.locales.value), h.localeCodes = C(() => y.localeCodes.value), h.baseUrl = C(() => y.baseUrl.value);
                let S;
                return Ze(d) && (S = Reflect.apply(d, c, [h])), () => {
                    S && S()
                }
            }, e.mode === "legacy") {
            const h = c.__vueI18nExtend;
            c.__vueI18nExtend = y => {
                qg(y, l.onExtendVueI18n);
                let S;
                return Ze(h) && (S = Reflect.apply(h, c, [y])), () => {
                    S && S()
                }
            }
        }
        u[0] = c, Reflect.apply(i, e, [s, ...u]);
        const f = Tr(e);
        o.run(() => {
            QR(f, {
                locales: t,
                localeCodes: n,
                baseUrl: a,
                hooks: l,
                context: r
            }), e.mode === "legacy" && w0(e.global) && qg(e.global, l.onExtendVueI18n)
        });
        const v = s,
            g = e.mode === "composition" ? v.config.globalProperties.$i18n : null;
        if (g && eD(g, f, l.onExtendExportedGlobal), c.inject) {
            const h = Cv(e);
            s.mixin({
                methods: {
                    getRouteBaseName: un(Vr, h),
                    resolveRoute: un(_u, h),
                    localePath: un(Sv, h),
                    localeRoute: un(wv, h),
                    localeLocation: un(ER, h),
                    switchLocalePath: un(Ar, h),
                    localeHead: un(x0, h)
                }
            })
        }
        if (v.unmount) {
            const h = v.unmount;
            v.unmount = () => {
                o.stop(), h()
            }
        }
    }, o
}

function QR(e, t) {
    const {
        locales: n,
        localeCodes: a,
        baseUrl: l,
        context: r
    } = t, o = Q(n), i = Q(a), s = Q("");
    e.locales = C(() => o.value), e.localeCodes = C(() => i.value), e.baseUrl = C(() => s.value), cR ? de(e.locale, () => {
        s.value = Ug(l, r)
    }, {
        immediate: !0
    }) : s.value = Ug(l, r), t.hooks && t.hooks.onExtendComposer && t.hooks.onExtendComposer(e)
}

function L0(e, t, n) {
    const a = [{
        locales: {
            get() {
                return e.locales.value
            }
        },
        localeCodes: {
            get() {
                return e.localeCodes.value
            }
        },
        baseUrl: {
            get() {
                return e.baseUrl.value
            }
        }
    }];
    n && a.push(n(e));
    for (const l of a)
        for (const [r, o] of Object.entries(l)) Object.defineProperty(t, r, o)
}

function eD(e, t, n) {
    L0(t, e, n)
}

function qg(e, t) {
    const n = Tr(e);
    L0(n, e, t)
}

function tD(e) {
    return $e(e) && ("inject" in e || "__composerExtend" in e || "__vueI18nExtend" in e)
}

function nD() {
    const {
        routesNameSeparator: e,
        defaultLocaleRouteNameSuffix: t
    } = Ut().public.i18n, n = `(${Al.join("|")})`, a = `(?:${e}${t})?`, l = new RegExp(`${e}${n}${a}$`, "i"), r = Is(Al);
    return i => {
        if ($e(i)) {
            if (i.name) {
                const u = (ke(i.name) ? i.name : i.name.toString()).match(l);
                if (u && u.length > 1) return u[1]
            } else if (i.path) {
                const s = i.path.match(r);
                if (s && s.length > 1) return s[1]
            }
        } else if (ke(i)) {
            const s = i.match(r);
            if (s && s.length > 1) return s[1]
        }
        return ""
    }
}
const aD = Wt({
    name: "i18n:plugin",
    parallel: aR,
    async setup(e) {
        let t, n;
        const a = iv(),
            {
                vueApp: l
            } = e,
            r = e,
            o = { ...r.$config.public.i18n
            };
        o.baseUrl = UR();
        const i = ci(),
            s = ([t, n] = Xn(() => iR(nR, Ye())), t = await t, n(), t);
        s.messages = s.messages || {}, s.fallbackLocale = s.fallbackLocale ? ? !1;
        const u = nD(),
            c = b => b || s.locale || "en-US",
            d = zR();
        let f = zg(a, u, s.locale, c(o.defaultLocale), {
            ssg: "normal",
            callType: "setup",
            firstAccess: !0,
            localeCookie: bc(d, i, o.defaultLocale)
        }, o);
        s.messages = ([t, n] = Xn(() => sR(s.messages, Ps, {
            localeCodes: Al,
            initialLocale: f,
            lazy: o.lazy,
            defaultLocale: o.defaultLocale,
            fallbackLocale: s.fallbackLocale
        })), t = await t, n(), t), f = c(f);
        const v = KO({ ...s,
            locale: f
        });
        let g = !0;
        const h = b => f !== b && g;
        ZR(v, {
            locales: o.configLocales,
            localeCodes: Al,
            baseUrl: o.baseUrl,
            context: r,
            hooks: {
                onExtendComposer(b) {
                    b.strategy = o.strategy, b.localeProperties = C(() => bu.find(p => p.code === b.locale.value) || {
                        code: b.locale.value
                    }), b.setLocale = async p => {
                        const _ = h(p);
                        await Wg(p, v, o, _) && _ && (g = !1);
                        const k = await r.runWithContext(() => Kg({
                            route: {
                                to: a
                            },
                            targetLocale: p,
                            routeLocaleGetter: u
                        }));
                        await r.runWithContext(async () => await Yg({
                            nuxtApp: r,
                            i18n: v,
                            redirectPath: k,
                            locale: p,
                            route: a
                        }, {
                            enableNavigate: !0
                        }))
                    }, b.loadLocaleMessages = async p => {
                        await Es(p, Ps, (w, k) => I0(v, w, k))
                    }, b.differentDomains = o.differentDomains, b.defaultLocale = o.defaultLocale, b.getBrowserLocale = () => V0(), b.getLocaleCookie = () => bc(d, i, o.defaultLocale), b.setLocaleCookie = p => KR(d, p, i), b.onBeforeLanguageSwitch = (p, _, w, k) => e.callHook("i18n:beforeLocaleSwitch", {
                        oldLocale: p,
                        newLocale: _,
                        initialSetup: w,
                        context: k
                    }), b.onLanguageSwitched = (p, _) => e.callHook("i18n:localeSwitched", {
                        oldLocale: p,
                        newLocale: _
                    }), b.finalizePendingLocaleChange = async () => {
                        v.__pendingLocale && (k0(v, v.__pendingLocale), v.__resolvePendingLocalePromise && await v.__resolvePendingLocalePromise(), v.__pendingLocale = void 0)
                    }, b.waitForPendingLocaleChange = async () => {
                        v.__pendingLocale && v.__pendingLocalePromise && await v.__pendingLocalePromise
                    }
                },
                onExtendExportedGlobal(b) {
                    return {
                        strategy: {
                            get() {
                                return b.strategy
                            }
                        },
                        localeProperties: {
                            get() {
                                return b.localeProperties.value
                            }
                        },
                        setLocale: {
                            get() {
                                return async p => Reflect.apply(b.setLocale, b, [p])
                            }
                        },
                        differentDomains: {
                            get() {
                                return b.differentDomains
                            }
                        },
                        defaultLocale: {
                            get() {
                                return b.defaultLocale
                            }
                        },
                        getBrowserLocale: {
                            get() {
                                return () => Reflect.apply(b.getBrowserLocale, b, [])
                            }
                        },
                        getLocaleCookie: {
                            get() {
                                return () => Reflect.apply(b.getLocaleCookie, b, [])
                            }
                        },
                        setLocaleCookie: {
                            get() {
                                return p => Reflect.apply(b.setLocaleCookie, b, [p])
                            }
                        },
                        onBeforeLanguageSwitch: {
                            get() {
                                return (p, _, w, k) => Reflect.apply(b.onBeforeLanguageSwitch, b, [p, _, w, k])
                            }
                        },
                        onLanguageSwitched: {
                            get() {
                                return (p, _) => Reflect.apply(b.onLanguageSwitched, b, [p, _])
                            }
                        },
                        finalizePendingLocaleChange: {
                            get() {
                                return () => Reflect.apply(b.finalizePendingLocaleChange, b, [])
                            }
                        },
                        waitForPendingLocaleChange: {
                            get() {
                                return () => Reflect.apply(b.waitForPendingLocaleChange, b, [])
                            }
                        }
                    }
                },
                onExtendVueI18n(b) {
                    return {
                        strategy: {
                            get() {
                                return b.strategy
                            }
                        },
                        localeProperties: {
                            get() {
                                return b.localeProperties.value
                            }
                        },
                        setLocale: {
                            get() {
                                return async p => Reflect.apply(b.setLocale, b, [p])
                            }
                        },
                        loadLocaleMessages: {
                            get() {
                                return async p => Reflect.apply(b.loadLocaleMessages, b, [p])
                            }
                        },
                        differentDomains: {
                            get() {
                                return b.differentDomains
                            }
                        },
                        defaultLocale: {
                            get() {
                                return b.defaultLocale
                            }
                        },
                        getBrowserLocale: {
                            get() {
                                return () => Reflect.apply(b.getBrowserLocale, b, [])
                            }
                        },
                        getLocaleCookie: {
                            get() {
                                return () => Reflect.apply(b.getLocaleCookie, b, [])
                            }
                        },
                        setLocaleCookie: {
                            get() {
                                return p => Reflect.apply(b.setLocaleCookie, b, [p])
                            }
                        },
                        onBeforeLanguageSwitch: {
                            get() {
                                return (p, _, w, k) => Reflect.apply(b.onBeforeLanguageSwitch, b, [p, _, w, k])
                            }
                        },
                        onLanguageSwitched: {
                            get() {
                                return (p, _) => Reflect.apply(b.onLanguageSwitched, b, [p, _])
                            }
                        },
                        finalizePendingLocaleChange: {
                            get() {
                                return () => Reflect.apply(b.finalizePendingLocaleChange, b, [])
                            }
                        },
                        waitForPendingLocaleChange: {
                            get() {
                                return () => Reflect.apply(b.waitForPendingLocaleChange, b, [])
                            }
                        }
                    }
                }
            }
        });
        const y = {
            __composerExtend: b => {
                const p = Tr(v);
                return b.strategy = p.strategy, b.localeProperties = C(() => p.localeProperties.value), b.setLocale = p.setLocale, b.differentDomains = p.differentDomains, b.getBrowserLocale = p.getBrowserLocale, b.getLocaleCookie = p.getLocaleCookie, b.setLocaleCookie = p.setLocaleCookie, b.onBeforeLanguageSwitch = p.onBeforeLanguageSwitch, b.onLanguageSwitched = p.onLanguageSwitched, b.finalizePendingLocaleChange = p.finalizePendingLocaleChange, b.waitForPendingLocaleChange = p.waitForPendingLocaleChange, () => {}
            }
        };
        if (l.use(v, y), FR(r, v), o.experimental.switchLocalePathLinkSSR === !0) {
            const b = JR(),
                p = new RegExp([`<!--${Fg}-\\[(\\w+)\\]-->`, ".+?", `<!--/${Fg}-->`].join(""), "g");
            e.hook("app:rendered", _ => {
                var w;
                ((w = _.renderResult) == null ? void 0 : w.html) != null && (_.renderResult.html = _.renderResult.html.replaceAll(p, (k, E) => k.replace(/href="([^"]+)"/, `href="${b(E??"")}"`)))
            })
        }
        let S = 0;
        WI("locale-changing", async (b, p) => {
            let _, w;
            const k = zg(b, u, s.locale, () => pu(v) || c(o.defaultLocale), {
                    ssg: "normal",
                    callType: "routing",
                    firstAccess: S === 0,
                    localeCookie: bc(d, i, o.defaultLocale)
                }, o),
                E = h(k);
            ([_, w] = Xn(() => Wg(k, v, o, E)), _ = await _, w(), _) && E && (g = !1);
            const x = ([_, w] = Xn(() => r.runWithContext(() => Kg({
                route: {
                    to: b,
                    from: p
                },
                targetLocale: k,
                routeLocaleGetter: o.strategy === "no_prefix" ? () => k : u,
                calledWithRouting: !0
            }))), _ = await _, w(), _);
            return S++, [_, w] = Xn(() => r.runWithContext(async () => Yg({
                nuxtApp: r,
                i18n: v,
                redirectPath: x,
                locale: k,
                route: b
            }))), _ = await _, w(), _
        }, {
            global: !0
        })
    }
});
var Mo = {},
    O0 = {},
    Lr = {},
    di = {},
    lD = en && en.__awaiter || function(e, t, n, a) {
        function l(r) {
            return r instanceof n ? r : new n(function(o) {
                o(r)
            })
        }
        return new(n || (n = Promise))(function(r, o) {
            function i(c) {
                try {
                    u(a.next(c))
                } catch (d) {
                    o(d)
                }
            }

            function s(c) {
                try {
                    u(a.throw(c))
                } catch (d) {
                    o(d)
                }
            }

            function u(c) {
                c.done ? r(c.value) : l(c.value).then(i, s)
            }
            u((a = a.apply(e, t || [])).next())
        })
    },
    rD = en && en.__generator || function(e, t) {
        var n = {
                label: 0,
                sent: function() {
                    if (r[0] & 1) throw r[1];
                    return r[1]
                },
                trys: [],
                ops: []
            },
            a, l, r, o;
        return o = {
            next: i(0),
            throw: i(1),
            return: i(2)
        }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
            return this
        }), o;

        function i(u) {
            return function(c) {
                return s([u, c])
            }
        }

        function s(u) {
            if (a) throw new TypeError("Generator is already executing.");
            for (; n;) try {
                if (a = 1, l && (r = u[0] & 2 ? l.return : u[0] ? l.throw || ((r = l.return) && r.call(l), 0) : l.next) && !(r = r.call(l, u[1])).done) return r;
                switch (l = 0, r && (u = [u[0] & 2, r.value]), u[0]) {
                    case 0:
                    case 1:
                        r = u;
                        break;
                    case 4:
                        return n.label++, {
                            value: u[1],
                            done: !1
                        };
                    case 5:
                        n.label++, l = u[1], u = [0];
                        continue;
                    case 7:
                        u = n.ops.pop(), n.trys.pop();
                        continue;
                    default:
                        if (r = n.trys, !(r = r.length > 0 && r[r.length - 1]) && (u[0] === 6 || u[0] === 2)) {
                            n = 0;
                            continue
                        }
                        if (u[0] === 3 && (!r || u[1] > r[0] && u[1] < r[3])) {
                            n.label = u[1];
                            break
                        }
                        if (u[0] === 6 && n.label < r[1]) {
                            n.label = r[1], r = u;
                            break
                        }
                        if (r && n.label < r[2]) {
                            n.label = r[2], n.ops.push(u);
                            break
                        }
                        r[2] && n.ops.pop(), n.trys.pop();
                        continue
                }
                u = t.call(e, n)
            } catch (c) {
                u = [6, c], l = 0
            } finally {
                a = r = 0
            }
            if (u[0] & 5) throw u[1];
            return {
                value: u[0] ? u[1] : void 0,
                done: !0
            }
        }
    };
Object.defineProperty(di, "__esModule", {
    value: !0
});
di.ReCaptchaInstance = void 0;
var oD = function() {
    function e(t, n, a) {
        this.siteKey = t, this.recaptchaID = n, this.recaptcha = a, this.styleContainer = null
    }
    return e.prototype.execute = function(t) {
        return lD(this, void 0, void 0, function() {
            return rD(this, function(n) {
                return [2, this.recaptcha.enterprise ? this.recaptcha.enterprise.execute(this.recaptchaID, {
                    action: t
                }) : this.recaptcha.execute(this.recaptchaID, {
                    action: t
                })]
            })
        })
    }, e.prototype.getSiteKey = function() {
        return this.siteKey
    }, e.prototype.hideBadge = function() {
        this.styleContainer === null && (this.styleContainer = document.createElement("style"), this.styleContainer.innerHTML = ".grecaptcha-badge{visibility:hidden !important;}", document.head.appendChild(this.styleContainer))
    }, e.prototype.showBadge = function() {
        this.styleContainer !== null && (document.head.removeChild(this.styleContainer), this.styleContainer = null)
    }, e
}();
di.ReCaptchaInstance = oD;
Object.defineProperty(Lr, "__esModule", {
    value: !0
});
Lr.getInstance = Lr.load = void 0;
var iD = di,
    ja;
(function(e) {
    e[e.NOT_LOADED = 0] = "NOT_LOADED", e[e.LOADING = 1] = "LOADING", e[e.LOADED = 2] = "LOADED"
})(ja || (ja = {}));
var R0 = function() {
    function e() {}
    return e.load = function(t, n) {
        if (n === void 0 && (n = {}), typeof document > "u") return Promise.reject(new Error("This is a library for the browser!"));
        if (e.getLoadingState() === ja.LOADED) return e.instance.getSiteKey() === t ? Promise.resolve(e.instance) : Promise.reject(new Error("reCAPTCHA already loaded with different site key!"));
        if (e.getLoadingState() === ja.LOADING) return t !== e.instanceSiteKey ? Promise.reject(new Error("reCAPTCHA already loaded with different site key!")) : new Promise(function(l, r) {
            e.successfulLoadingConsumers.push(function(o) {
                return l(o)
            }), e.errorLoadingRunnable.push(function(o) {
                return r(o)
            })
        });
        e.instanceSiteKey = t, e.setLoadingState(ja.LOADING);
        var a = new e;
        return new Promise(function(l, r) {
            a.loadScript(t, n.useRecaptchaNet || !1, n.useEnterprise || !1, n.renderParameters ? n.renderParameters : {}, n.customUrl).then(function() {
                e.setLoadingState(ja.LOADED);
                var o = a.doExplicitRender(grecaptcha, t, n.explicitRenderParameters ? n.explicitRenderParameters : {}, n.useEnterprise || !1),
                    i = new iD.ReCaptchaInstance(t, o, grecaptcha);
                e.successfulLoadingConsumers.forEach(function(s) {
                    return s(i)
                }), e.successfulLoadingConsumers = [], n.autoHideBadge && i.hideBadge(), e.instance = i, l(i)
            }).catch(function(o) {
                e.errorLoadingRunnable.forEach(function(i) {
                    return i(o)
                }), e.errorLoadingRunnable = [], r(o)
            })
        })
    }, e.getInstance = function() {
        return e.instance
    }, e.setLoadingState = function(t) {
        e.loadingState = t
    }, e.getLoadingState = function() {
        return e.loadingState === null ? ja.NOT_LOADED : e.loadingState
    }, e.prototype.loadScript = function(t, n, a, l, r) {
        var o = this;
        n === void 0 && (n = !1), a === void 0 && (a = !1), l === void 0 && (l = {}), r === void 0 && (r = "");
        var i = document.createElement("script");
        i.setAttribute("recaptcha-v3-script", "");
        var s = "https://www.google.com/recaptcha/api.js";
        n && (a ? s = "https://recaptcha.net/recaptcha/enterprise.js" : s = "https://recaptcha.net/recaptcha/api.js"), a && (s = "https://www.google.com/recaptcha/enterprise.js"), r && (s = r), l.render && (l.render = void 0);
        var u = this.buildQueryString(l);
        return i.src = s + "?render=explicit" + u, new Promise(function(c, d) {
            i.addEventListener("load", o.waitForScriptToLoad(function() {
                c(i)
            }, a), !1), i.onerror = function(f) {
                e.setLoadingState(ja.NOT_LOADED), d(f)
            }, document.head.appendChild(i)
        })
    }, e.prototype.buildQueryString = function(t) {
        var n = Object.keys(t);
        return n.length < 1 ? "" : "&" + Object.keys(t).filter(function(a) {
            return !!t[a]
        }).map(function(a) {
            return a + "=" + t[a]
        }).join("&")
    }, e.prototype.waitForScriptToLoad = function(t, n) {
        var a = this;
        return function() {
            window.grecaptcha === void 0 ? setTimeout(function() {
                a.waitForScriptToLoad(t, n)
            }, e.SCRIPT_LOAD_DELAY) : n ? window.grecaptcha.enterprise.ready(function() {
                t()
            }) : window.grecaptcha.ready(function() {
                t()
            })
        }
    }, e.prototype.doExplicitRender = function(t, n, a, l) {
        var r = {
            sitekey: n,
            badge: a.badge,
            size: a.size,
            tabindex: a.tabindex
        };
        return a.container ? l ? t.enterprise.render(a.container, r) : t.render(a.container, r) : l ? t.enterprise.render(r) : t.render(r)
    }, e.loadingState = null, e.instance = null, e.instanceSiteKey = null, e.successfulLoadingConsumers = [], e.errorLoadingRunnable = [], e.SCRIPT_LOAD_DELAY = 25, e
}();
Lr.load = R0.load;
Lr.getInstance = R0.getInstance;
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.ReCaptchaInstance = e.getInstance = e.load = void 0;
    var t = Lr;
    Object.defineProperty(e, "load", {
        enumerable: !0,
        get: function() {
            return t.load
        }
    }), Object.defineProperty(e, "getInstance", {
        enumerable: !0,
        get: function() {
            return t.getInstance
        }
    });
    var n = di;
    Object.defineProperty(e, "ReCaptchaInstance", {
        enumerable: !0,
        get: function() {
            return n.ReCaptchaInstance
        }
    })
})(O0);
const sD = XA(QP);
var D0 = en && en.__awaiter || function(e, t, n, a) {
        function l(r) {
            return r instanceof n ? r : new n(function(o) {
                o(r)
            })
        }
        return new(n || (n = Promise))(function(r, o) {
            function i(c) {
                try {
                    u(a.next(c))
                } catch (d) {
                    o(d)
                }
            }

            function s(c) {
                try {
                    u(a.throw(c))
                } catch (d) {
                    o(d)
                }
            }

            function u(c) {
                c.done ? r(c.value) : l(c.value).then(i, s)
            }
            u((a = a.apply(e, t || [])).next())
        })
    },
    M0 = en && en.__generator || function(e, t) {
        var n = {
                label: 0,
                sent: function() {
                    if (r[0] & 1) throw r[1];
                    return r[1]
                },
                trys: [],
                ops: []
            },
            a, l, r, o;
        return o = {
            next: i(0),
            throw: i(1),
            return: i(2)
        }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
            return this
        }), o;

        function i(u) {
            return function(c) {
                return s([u, c])
            }
        }

        function s(u) {
            if (a) throw new TypeError("Generator is already executing.");
            for (; n;) try {
                if (a = 1, l && (r = u[0] & 2 ? l.return : u[0] ? l.throw || ((r = l.return) && r.call(l), 0) : l.next) && !(r = r.call(l, u[1])).done) return r;
                switch (l = 0, r && (u = [u[0] & 2, r.value]), u[0]) {
                    case 0:
                    case 1:
                        r = u;
                        break;
                    case 4:
                        return n.label++, {
                            value: u[1],
                            done: !1
                        };
                    case 5:
                        n.label++, l = u[1], u = [0];
                        continue;
                    case 7:
                        u = n.ops.pop(), n.trys.pop();
                        continue;
                    default:
                        if (r = n.trys, !(r = r.length > 0 && r[r.length - 1]) && (u[0] === 6 || u[0] === 2)) {
                            n = 0;
                            continue
                        }
                        if (u[0] === 3 && (!r || u[1] > r[0] && u[1] < r[3])) {
                            n.label = u[1];
                            break
                        }
                        if (u[0] === 6 && n.label < r[1]) {
                            n.label = r[1], r = u;
                            break
                        }
                        if (r && n.label < r[2]) {
                            n.label = r[2], n.ops.push(u);
                            break
                        }
                        r[2] && n.ops.pop(), n.trys.pop();
                        continue
                }
                u = t.call(e, n)
            } catch (c) {
                u = [6, c], l = 0
            } finally {
                a = r = 0
            }
            if (u[0] & 5) throw u[1];
            return {
                value: u[0] ? u[1] : void 0,
                done: !0
            }
        }
    };
Object.defineProperty(Mo, "__esModule", {
    value: !0
});
var uD = Mo.useReCaptcha = $0 = Mo.VueReCaptcha = void 0,
    cD = O0,
    Id = sD,
    N0 = Symbol("VueReCaptchaInjectKey"),
    _r = {
        loadedWaiters: [],
        error: null
    },
    $0 = Mo.VueReCaptcha = {
        install: function(e, t) {
            var n = Id.ref(!1),
                a = Id.ref(void 0);
            e.config.globalProperties.$recaptchaLoaded = Xg(n), fD(t).then(function(l) {
                n.value = !0, a.value = l, e.config.globalProperties.$recaptcha = Jg(a), e.config.globalProperties.$recaptchaInstance = a, _r.loadedWaiters.forEach(function(r) {
                    return r.resolve(!0)
                })
            }).catch(function(l) {
                _r.error = l, _r.loadedWaiters.forEach(function(r) {
                    return r.reject(l)
                })
            }), e.provide(N0, {
                instance: a,
                isLoaded: n,
                executeRecaptcha: Jg(a),
                recaptchaLoaded: Xg(n)
            })
        }
    };

function dD() {
    return Id.inject(N0)
}
uD = Mo.useReCaptcha = dD;

function fD(e) {
    return D0(this, void 0, void 0, function() {
        return M0(this, function(t) {
            switch (t.label) {
                case 0:
                    return [4, cD.load(e.siteKey, e.loaderOptions)];
                case 1:
                    return [2, t.sent()]
            }
        })
    })
}

function Xg(e) {
    return function() {
        return new Promise(function(t, n) {
            if (_r.error !== null) return n(_r.error);
            if (e.value) return t(!0);
            _r.loadedWaiters.push({
                resolve: t,
                reject: n
            })
        })
    }
}

function Jg(e) {
    var t = this;
    return function(n) {
        return D0(t, void 0, void 0, function() {
            var a;
            return M0(this, function(l) {
                switch (l.label) {
                    case 0:
                        return [4, (a = e.value) === null || a === void 0 ? void 0 : a.execute(n)];
                    case 1:
                        return [2, l.sent()]
                }
            })
        })
    }
}
const vD = Wt(e => {
        const {
            public: t
        } = e.$config;
        e.vueApp.use($0, {
            siteKey: t.googleRecaptchaKey,
            loaderOptions: {
                autoHideBadge: !0,
                explicitRenderParameters: {
                    badge: "bottomright"
                }
            }
        })
    }),
    B0 = "%[a-f0-9]{2}",
    Zg = new RegExp("(" + B0 + ")|([^%]+?)", "gi"),
    Qg = new RegExp("(" + B0 + ")+", "gi");

function Td(e, t) {
    try {
        return [decodeURIComponent(e.join(""))]
    } catch {}
    if (e.length === 1) return e;
    t = t || 1;
    const n = e.slice(0, t),
        a = e.slice(t);
    return Array.prototype.concat.call([], Td(n), Td(a))
}

function mD(e) {
    try {
        return decodeURIComponent(e)
    } catch {
        let t = e.match(Zg) || [];
        for (let n = 1; n < t.length; n++) e = Td(t, n).join(""), t = e.match(Zg) || [];
        return e
    }
}

function hD(e) {
    const t = {
        "%FE%FF": "��",
        "%FF%FE": "��"
    };
    let n = Qg.exec(e);
    for (; n;) {
        try {
            t[n[0]] = decodeURIComponent(n[0])
        } catch {
            const l = mD(n[0]);
            l !== n[0] && (t[n[0]] = l)
        }
        n = Qg.exec(e)
    }
    t["%C2"] = "�";
    const a = Object.keys(t);
    for (const l of a) e = e.replace(new RegExp(l, "g"), t[l]);
    return e
}

function gD(e) {
    if (typeof e != "string") throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof e + "`");
    try {
        return decodeURIComponent(e)
    } catch {
        return hD(e)
    }
}

function F0(e, t) {
    if (!(typeof e == "string" && typeof t == "string")) throw new TypeError("Expected the arguments to be of type `string`");
    if (e === "" || t === "") return [];
    const n = e.indexOf(t);
    return n === -1 ? [] : [e.slice(0, n), e.slice(n + t.length)]
}

function yD(e, t) {
    const n = {};
    if (Array.isArray(t))
        for (const a of t) {
            const l = Object.getOwnPropertyDescriptor(e, a);
            l != null && l.enumerable && Object.defineProperty(n, a, l)
        } else
            for (const a of Reflect.ownKeys(e)) {
                const l = Object.getOwnPropertyDescriptor(e, a);
                if (l.enumerable) {
                    const r = e[a];
                    t(a, r, e) && Object.defineProperty(n, a, l)
                }
            }
    return n
}
const bD = e => e == null,
    pD = e => encodeURIComponent(e).replaceAll(/[!'()*]/g, t => `%${t.charCodeAt(0).toString(16).toUpperCase()}`),
    Vd = Symbol("encodeFragmentIdentifier");

function _D(e) {
    switch (e.arrayFormat) {
        case "index":
            return t => (n, a) => {
                const l = n.length;
                return a === void 0 || e.skipNull && a === null || e.skipEmptyString && a === "" ? n : a === null ? [...n, [_t(t, e), "[", l, "]"].join("")] : [...n, [_t(t, e), "[", _t(l, e), "]=", _t(a, e)].join("")]
            };
        case "bracket":
            return t => (n, a) => a === void 0 || e.skipNull && a === null || e.skipEmptyString && a === "" ? n : a === null ? [...n, [_t(t, e), "[]"].join("")] : [...n, [_t(t, e), "[]=", _t(a, e)].join("")];
        case "colon-list-separator":
            return t => (n, a) => a === void 0 || e.skipNull && a === null || e.skipEmptyString && a === "" ? n : a === null ? [...n, [_t(t, e), ":list="].join("")] : [...n, [_t(t, e), ":list=", _t(a, e)].join("")];
        case "comma":
        case "separator":
        case "bracket-separator":
            {
                const t = e.arrayFormat === "bracket-separator" ? "[]=" : "=";
                return n => (a, l) => l === void 0 || e.skipNull && l === null || e.skipEmptyString && l === "" ? a : (l = l === null ? "" : l, a.length === 0 ? [
                    [_t(n, e), t, _t(l, e)].join("")
                ] : [
                    [a, _t(l, e)].join(e.arrayFormatSeparator)
                ])
            }
        default:
            return t => (n, a) => a === void 0 || e.skipNull && a === null || e.skipEmptyString && a === "" ? n : a === null ? [...n, _t(t, e)] : [...n, [_t(t, e), "=", _t(a, e)].join("")]
    }
}

function SD(e) {
    let t;
    switch (e.arrayFormat) {
        case "index":
            return (n, a, l) => {
                if (t = /\[(\d*)]$/.exec(n), n = n.replace(/\[\d*]$/, ""), !t) {
                    l[n] = a;
                    return
                }
                l[n] === void 0 && (l[n] = {}), l[n][t[1]] = a
            };
        case "bracket":
            return (n, a, l) => {
                if (t = /(\[])$/.exec(n), n = n.replace(/\[]$/, ""), !t) {
                    l[n] = a;
                    return
                }
                if (l[n] === void 0) {
                    l[n] = [a];
                    return
                }
                l[n] = [...l[n], a]
            };
        case "colon-list-separator":
            return (n, a, l) => {
                if (t = /(:list)$/.exec(n), n = n.replace(/:list$/, ""), !t) {
                    l[n] = a;
                    return
                }
                if (l[n] === void 0) {
                    l[n] = [a];
                    return
                }
                l[n] = [...l[n], a]
            };
        case "comma":
        case "separator":
            return (n, a, l) => {
                const r = typeof a == "string" && a.includes(e.arrayFormatSeparator),
                    o = typeof a == "string" && !r && ma(a, e).includes(e.arrayFormatSeparator);
                a = o ? ma(a, e) : a;
                const i = r || o ? a.split(e.arrayFormatSeparator).map(s => ma(s, e)) : a === null ? a : ma(a, e);
                l[n] = i
            };
        case "bracket-separator":
            return (n, a, l) => {
                const r = /(\[])$/.test(n);
                if (n = n.replace(/\[]$/, ""), !r) {
                    l[n] = a && ma(a, e);
                    return
                }
                const o = a === null ? [] : a.split(e.arrayFormatSeparator).map(i => ma(i, e));
                if (l[n] === void 0) {
                    l[n] = o;
                    return
                }
                l[n] = [...l[n], ...o]
            };
        default:
            return (n, a, l) => {
                if (l[n] === void 0) {
                    l[n] = a;
                    return
                }
                l[n] = [...[l[n]].flat(), a]
            }
    }
}

function H0(e) {
    if (typeof e != "string" || e.length !== 1) throw new TypeError("arrayFormatSeparator must be single character string")
}

function _t(e, t) {
    return t.encode ? t.strict ? pD(e) : encodeURIComponent(e) : e
}

function ma(e, t) {
    return t.decode ? gD(e) : e
}

function j0(e) {
    return Array.isArray(e) ? e.sort() : typeof e == "object" ? j0(Object.keys(e)).sort((t, n) => Number(t) - Number(n)).map(t => e[t]) : e
}

function U0(e) {
    const t = e.indexOf("#");
    return t !== -1 && (e = e.slice(0, t)), e
}

function wD(e) {
    let t = "";
    const n = e.indexOf("#");
    return n !== -1 && (t = e.slice(n)), t
}

function ey(e, t) {
    return t.parseNumbers && !Number.isNaN(Number(e)) && typeof e == "string" && e.trim() !== "" ? e = Number(e) : t.parseBooleans && e !== null && (e.toLowerCase() === "true" || e.toLowerCase() === "false") && (e = e.toLowerCase() === "true"), e
}

function xv(e) {
    e = U0(e);
    const t = e.indexOf("?");
    return t === -1 ? "" : e.slice(t + 1)
}

function Pv(e, t) {
    t = {
        decode: !0,
        sort: !0,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: !1,
        parseBooleans: !1,
        ...t
    }, H0(t.arrayFormatSeparator);
    const n = SD(t),
        a = Object.create(null);
    if (typeof e != "string" || (e = e.trim().replace(/^[?#&]/, ""), !e)) return a;
    for (const l of e.split("&")) {
        if (l === "") continue;
        const r = t.decode ? l.replaceAll("+", " ") : l;
        let [o, i] = F0(r, "=");
        o === void 0 && (o = r), i = i === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(t.arrayFormat) ? i : ma(i, t), n(ma(o, t), i, a)
    }
    for (const [l, r] of Object.entries(a))
        if (typeof r == "object" && r !== null)
            for (const [o, i] of Object.entries(r)) r[o] = ey(i, t);
        else a[l] = ey(r, t);
    return t.sort === !1 ? a : (t.sort === !0 ? Object.keys(a).sort() : Object.keys(a).sort(t.sort)).reduce((l, r) => {
        const o = a[r];
        return l[r] = o && typeof o == "object" && !Array.isArray(o) ? j0(o) : o, l
    }, Object.create(null))
}

function W0(e, t) {
    if (!e) return "";
    t = {
        encode: !0,
        strict: !0,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        ...t
    }, H0(t.arrayFormatSeparator);
    const n = o => t.skipNull && bD(e[o]) || t.skipEmptyString && e[o] === "",
        a = _D(t),
        l = {};
    for (const [o, i] of Object.entries(e)) n(o) || (l[o] = i);
    const r = Object.keys(l);
    return t.sort !== !1 && r.sort(t.sort), r.map(o => {
        const i = e[o];
        return i === void 0 ? "" : i === null ? _t(o, t) : Array.isArray(i) ? i.length === 0 && t.arrayFormat === "bracket-separator" ? _t(o, t) + "[]" : i.reduce(a(o), []).join("&") : _t(o, t) + "=" + _t(i, t)
    }).filter(o => o.length > 0).join("&")
}

function z0(e, t) {
    var l;
    t = {
        decode: !0,
        ...t
    };
    let [n, a] = F0(e, "#");
    return n === void 0 && (n = e), {
        url: ((l = n == null ? void 0 : n.split("?")) == null ? void 0 : l[0]) ? ? "",
        query: Pv(xv(e), t),
        ...t && t.parseFragmentIdentifier && a ? {
            fragmentIdentifier: ma(a, t)
        } : {}
    }
}

function K0(e, t) {
    t = {
        encode: !0,
        strict: !0,
        [Vd]: !0,
        ...t
    };
    const n = U0(e.url).split("?")[0] || "",
        a = xv(e.url),
        l = { ...Pv(a, {
                sort: !1
            }),
            ...e.query
        };
    let r = W0(l, t);
    r && (r = `?${r}`);
    let o = wD(e.url);
    if (typeof e.fragmentIdentifier == "string") {
        const i = new URL(n);
        i.hash = e.fragmentIdentifier, o = t[Vd] ? i.hash : `#${e.fragmentIdentifier}`
    }
    return `${n}${r}${o}`
}

function G0(e, t, n) {
    n = {
        parseFragmentIdentifier: !0,
        [Vd]: !1,
        ...n
    };
    const {
        url: a,
        query: l,
        fragmentIdentifier: r
    } = z0(e, n);
    return K0({
        url: a,
        query: yD(l, t),
        fragmentIdentifier: r
    }, n)
}

function kD(e, t, n) {
    const a = Array.isArray(t) ? l => !t.includes(l) : (l, r) => !t(l, r);
    return G0(e, a, n)
}
const CD = Object.freeze(Object.defineProperty({
        __proto__: null,
        exclude: kD,
        extract: xv,
        parse: Pv,
        parseUrl: z0,
        pick: G0,
        stringify: W0,
        stringifyUrl: K0
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    xD = Wt(e => {
        const t = l => {
                const r = Ut(),
                    {
                        serverType: o,
                        idsLoginUrl: i,
                        txLoginUrl: s,
                        clientId: u,
                        appOauthReturn: c,
                        uaePassSelfCareScopes: d
                    } = r.public,
                    f = o === "idshub" ? s : i,
                    v = d.split(",").join(" "),
                    g = `${f}${o}/authorize?${CD.stringify({client_id:u,response_type:"code",redirect_uri:c,acr_values:"urn:digitalid:authentication:flow:mobile",scope:v,state:btoa(JSON.stringify({lang:l})),ui_locales:l})}`;
                window.location.href = g
            },
            n = () => {
                const l = Ut(),
                    {
                        appUrl: r
                    } = l.public;
                window.location.href = `${r}/auth/logout`
            },
            a = () => e.store.state.auth.isAuthenticated;
        e.provide("auth", {
            login: t,
            logout: n,
            isAuthenticated: a
        })
    }),
    PD = Wt(e => {
        const t = Q(null);
        return e.hooks.hook("app:mounted", () => {
            document.addEventListener("userway:init_completed", function(n) {
                t.value = n.detail.userWayInstance
            })
        }), {
            provide: {
                userWayInstance: t
            }
        }
    });

function Yt(e, t) {
    let n;

    function a() {
        n = xa(), n.run(() => t.length ? t(() => {
            n == null || n.stop(), a()
        }) : t())
    }
    de(e, l => {
        l && !n ? a() : l || (n == null || n.stop(), n = void 0)
    }, {
        immediate: !0
    }), kt(() => {
        n == null || n.stop()
    })
}
const Ue = typeof window < "u",
    Ev = Ue && "IntersectionObserver" in window,
    ED = Ue && ("ontouchstart" in window || window.navigator.maxTouchPoints > 0),
    ty = Ue && "EyeDropper" in window;

function ny(e, t, n) {
    ID(e, t), t.set(e, n)
}

function ID(e, t) {
    if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object")
}

function TD(e, t, n) {
    return e.set(Y0(e, t), n), n
}

function dl(e, t) {
    return e.get(Y0(e, t))
}

function Y0(e, t, n) {
    if (typeof e == "function" ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
    throw new TypeError("Private element is not present on this object")
}

function q0(e, t, n) {
    const a = t.length - 1;
    if (a < 0) return e === void 0 ? n : e;
    for (let l = 0; l < a; l++) {
        if (e == null) return n;
        e = e[t[l]]
    }
    return e == null || e[t[a]] === void 0 ? n : e[t[a]]
}

function la(e, t) {
    if (e === t) return !0;
    if (e instanceof Date && t instanceof Date && e.getTime() !== t.getTime() || e !== Object(e) || t !== Object(t)) return !1;
    const n = Object.keys(e);
    return n.length !== Object.keys(t).length ? !1 : n.every(a => la(e[a], t[a]))
}

function Ll(e, t, n) {
    return e == null || !t || typeof t != "string" ? n : e[t] !== void 0 ? e[t] : (t = t.replace(/\[(\w+)\]/g, ".$1"), t = t.replace(/^\./, ""), q0(e, t.split("."), n))
}

function vt(e, t, n) {
    if (t === !0) return e === void 0 ? n : e;
    if (t == null || typeof t == "boolean") return n;
    if (e !== Object(e)) {
        if (typeof t != "function") return n;
        const l = t(e, n);
        return typeof l > "u" ? n : l
    }
    if (typeof t == "string") return Ll(e, t, n);
    if (Array.isArray(t)) return q0(e, t, n);
    if (typeof t != "function") return n;
    const a = t(e, n);
    return typeof a > "u" ? n : a
}

function fn(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return Array.from({
        length: e
    }, (n, a) => t + a)
}

function ge(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "px";
    if (!(e == null || e === "")) return isNaN(+e) ? String(e) : isFinite(+e) ? `${Number(e)}${t}` : void 0
}

function Iv(e) {
    return e !== null && typeof e == "object" && !Array.isArray(e)
}

function ay(e) {
    let t;
    return e !== null && typeof e == "object" && ((t = Object.getPrototypeOf(e)) === Object.prototype || t === null)
}

function Tv(e) {
    if (e && "$el" in e) {
        const t = e.$el;
        return (t == null ? void 0 : t.nodeType) === Node.TEXT_NODE ? t.nextElementSibling : t
    }
    return e
}
const ly = Object.freeze({
        enter: 13,
        tab: 9,
        delete: 46,
        esc: 27,
        space: 32,
        up: 38,
        down: 40,
        left: 37,
        right: 39,
        end: 35,
        home: 36,
        del: 46,
        backspace: 8,
        insert: 45,
        pageup: 33,
        pagedown: 34,
        shift: 16
    }),
    Ad = Object.freeze({
        enter: "Enter",
        tab: "Tab",
        delete: "Delete",
        esc: "Escape",
        space: "Space",
        up: "ArrowUp",
        down: "ArrowDown",
        left: "ArrowLeft",
        right: "ArrowRight",
        end: "End",
        home: "Home",
        del: "Delete",
        backspace: "Backspace",
        insert: "Insert",
        pageup: "PageUp",
        pagedown: "PageDown",
        shift: "Shift"
    });

function X0(e) {
    return Object.keys(e)
}

function gl(e, t) {
    return t.every(n => e.hasOwnProperty(n))
}

function Vv(e, t) {
    const n = {},
        a = new Set(Object.keys(e));
    for (const l of t) a.has(l) && (n[l] = e[l]);
    return n
}

function Ld(e, t, n) {
    const a = Object.create(null),
        l = Object.create(null);
    for (const r in e) t.some(o => o instanceof RegExp ? o.test(r) : o === r) && !(n != null && n.some(o => o === r)) ? a[r] = e[r] : l[r] = e[r];
    return [a, l]
}

function We(e, t) {
    const n = { ...e
    };
    return t.forEach(a => delete n[a]), n
}

function wu(e, t) {
    const n = {};
    return t.forEach(a => n[a] = e[a]), n
}
const J0 = /^on[^a-z]/,
    ku = e => J0.test(e),
    VD = ["onAfterscriptexecute", "onAnimationcancel", "onAnimationend", "onAnimationiteration", "onAnimationstart", "onAuxclick", "onBeforeinput", "onBeforescriptexecute", "onChange", "onClick", "onCompositionend", "onCompositionstart", "onCompositionupdate", "onContextmenu", "onCopy", "onCut", "onDblclick", "onFocusin", "onFocusout", "onFullscreenchange", "onFullscreenerror", "onGesturechange", "onGestureend", "onGesturestart", "onGotpointercapture", "onInput", "onKeydown", "onKeypress", "onKeyup", "onLostpointercapture", "onMousedown", "onMousemove", "onMouseout", "onMouseover", "onMouseup", "onMousewheel", "onPaste", "onPointercancel", "onPointerdown", "onPointerenter", "onPointerleave", "onPointermove", "onPointerout", "onPointerover", "onPointerup", "onReset", "onSelect", "onSubmit", "onTouchcancel", "onTouchend", "onTouchmove", "onTouchstart", "onTransitioncancel", "onTransitionend", "onTransitionrun", "onTransitionstart", "onWheel"],
    AD = ["ArrowUp", "ArrowDown", "ArrowRight", "ArrowLeft", "Enter", "Escape", "Tab", " "];

function LD(e) {
    return e.isComposing && AD.includes(e.key)
}

function al(e) {
    const [t, n] = Ld(e, [J0]), a = We(t, VD), [l, r] = Ld(n, ["class", "style", "id", /^data-/]);
    return Object.assign(l, t), Object.assign(r, a), [l, r]
}

function nt(e) {
    return e == null ? [] : Array.isArray(e) ? e : [e]
}

function OD(e, t) {
    let n = 0;
    const a = function() {
        for (var l = arguments.length, r = new Array(l), o = 0; o < l; o++) r[o] = arguments[o];
        clearTimeout(n), n = setTimeout(() => e(...r), Ie(t))
    };
    return a.clear = () => {
        clearTimeout(n)
    }, a.immediate = e, a
}

function ot(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
        n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    return Math.max(t, Math.min(n, e))
}

function Ts(e) {
    const t = e.toString().trim();
    return t.includes(".") ? t.length - t.indexOf(".") - 1 : 0
}

function ry(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
    return e + n.repeat(Math.max(0, t - e.length))
}

function oy(e, t) {
    return (arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0").repeat(Math.max(0, t - e.length)) + e
}

function RD(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    const n = [];
    let a = 0;
    for (; a < e.length;) n.push(e.substr(a, t)), a += t;
    return n
}

function DD(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    return Array.from({
        length: Math.ceil(e.length / t)
    }, (n, a) => e.slice(a * t, a * t + t))
}

function iy(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
    if (e < t) return `${e} B`;
    const n = t === 1024 ? ["Ki", "Mi", "Gi"] : ["k", "M", "G"];
    let a = -1;
    for (; Math.abs(e) >= t && a < n.length - 1;) e /= t, ++a;
    return `${e.toFixed(1)} ${n[a]}B`
}

function Ht() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
        t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        n = arguments.length > 2 ? arguments[2] : void 0;
    const a = {};
    for (const l in e) a[l] = e[l];
    for (const l in t) {
        const r = e[l],
            o = t[l];
        if (ay(r) && ay(o)) {
            a[l] = Ht(r, o, n);
            continue
        }
        if (n && Array.isArray(r) && Array.isArray(o)) {
            a[l] = n(r, o);
            continue
        }
        a[l] = o
    }
    return a
}

function Z0(e) {
    return e.map(t => t.type === ye ? Z0(t.children) : t).flat()
}

function Cl() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    if (Cl.cache.has(e)) return Cl.cache.get(e);
    const t = e.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase();
    return Cl.cache.set(e, t), t
}
Cl.cache = new Map;

function fr(e, t) {
    if (!t || typeof t != "object") return [];
    if (Array.isArray(t)) return t.map(n => fr(e, n)).flat(1);
    if (t.suspense) return fr(e, t.ssContent);
    if (Array.isArray(t.children)) return t.children.map(n => fr(e, n)).flat(1);
    if (t.component) {
        if (Object.getOwnPropertySymbols(t.component.provides).includes(e)) return [t.component];
        if (t.component.subTree) return fr(e, t.component.subTree).flat(1)
    }
    return []
}
var Bi = new WeakMap,
    ar = new WeakMap;
class MD {
    constructor(t) {
        ny(this, Bi, []), ny(this, ar, 0), this.size = t
    }
    push(t) {
        dl(Bi, this)[dl(ar, this)] = t, TD(ar, this, (dl(ar, this) + 1) % this.size)
    }
    values() {
        return dl(Bi, this).slice(dl(ar, this)).concat(dl(Bi, this).slice(0, dl(ar, this)))
    }
}

function ND(e) {
    return "touches" in e ? {
        clientX: e.touches[0].clientX,
        clientY: e.touches[0].clientY
    } : {
        clientX: e.clientX,
        clientY: e.clientY
    }
}

function Av(e) {
    const t = mt({}),
        n = C(e);
    return st(() => {
        for (const a in n.value) t[a] = n.value[a]
    }, {
        flush: "sync"
    }), ta(t)
}

function Vs(e, t) {
    return e.includes(t)
}

function Q0(e) {
    return e[2].toLowerCase() + e.slice(3)
}
const It = () => [Function, Array];

function sy(e, t) {
    return t = "on" + na(t), !!(e[t] || e[`${t}Once`] || e[`${t}Capture`] || e[`${t}OnceCapture`] || e[`${t}CaptureOnce`])
}

function Lv(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), a = 1; a < t; a++) n[a - 1] = arguments[a];
    if (Array.isArray(e))
        for (const l of e) l(...n);
    else typeof e == "function" && e(...n)
}

function No(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    const n = ["button", "[href]", 'input:not([type="hidden"])', "select", "textarea", "[tabindex]"].map(a => `${a}${t?':not([tabindex="-1"])':""}:not([disabled])`).join(", ");
    return [...e.querySelectorAll(n)]
}

function eS(e, t, n) {
    let a, l = e.indexOf(document.activeElement);
    const r = t === "next" ? 1 : -1;
    do l += r, a = e[l]; while ((!a || a.offsetParent == null || !((n == null ? void 0 : n(a)) ? ? !0)) && l < e.length && l >= 0);
    return a
}

function xl(e, t) {
    var a, l, r, o;
    const n = No(e);
    if (!t)(e === document.activeElement || !e.contains(document.activeElement)) && ((a = n[0]) == null || a.focus());
    else if (t === "first")(l = n[0]) == null || l.focus();
    else if (t === "last")(r = n.at(-1)) == null || r.focus();
    else if (typeof t == "number")(o = n[t]) == null || o.focus();
    else {
        const i = eS(n, t);
        i ? i.focus() : xl(e, t === "next" ? "first" : "last")
    }
}

function Fi(e) {
    return e == null || typeof e == "string" && e.trim() === ""
}

function tS() {}

function Or(e, t) {
    if (!(Ue && typeof CSS < "u" && typeof CSS.supports < "u" && CSS.supports(`selector(${t})`))) return null;
    try {
        return !!e && e.matches(t)
    } catch {
        return null
    }
}

function Cu(e) {
    return e.some(t => wa(t) ? t.type === Nt ? !1 : t.type !== ye || Cu(t.children) : !0) ? e : null
}

function $D(e, t) {
    if (!Ue || e === 0) return t(), () => {};
    const n = window.setTimeout(t, e);
    return () => window.clearTimeout(n)
}

function BD(e, t) {
    const n = e.clientX,
        a = e.clientY,
        l = t.getBoundingClientRect(),
        r = l.left,
        o = l.top,
        i = l.right,
        s = l.bottom;
    return n >= r && n <= i && a >= o && a <= s
}

function As() {
    const e = fe(),
        t = n => {
            e.value = n
        };
    return Object.defineProperty(t, "value", {
        enumerable: !0,
        get: () => e.value,
        set: n => e.value = n
    }), Object.defineProperty(t, "el", {
        enumerable: !0,
        get: () => Tv(e.value)
    }), t
}

function Ls(e) {
    const t = e.key.length === 1,
        n = !e.ctrlKey && !e.metaKey && !e.altKey;
    return t && n
}
const nS = ["top", "bottom"],
    FD = ["start", "end", "left", "right"];

function Od(e, t) {
    let [n, a] = e.split(" ");
    return a || (a = Vs(nS, n) ? "start" : Vs(FD, n) ? "top" : "center"), {
        side: Rd(n, t),
        align: Rd(a, t)
    }
}

function Rd(e, t) {
    return e === "start" ? t ? "right" : "left" : e === "end" ? t ? "left" : "right" : e
}

function pc(e) {
    return {
        side: {
            center: "center",
            top: "bottom",
            bottom: "top",
            left: "right",
            right: "left"
        }[e.side],
        align: e.align
    }
}

function _c(e) {
    return {
        side: e.side,
        align: {
            center: "center",
            top: "bottom",
            bottom: "top",
            left: "right",
            right: "left"
        }[e.align]
    }
}

function uy(e) {
    return {
        side: e.align,
        align: e.side
    }
}

function cy(e) {
    return Vs(nS, e.side) ? "y" : "x"
}
class Pl {
    constructor(t) {
        let {
            x: n,
            y: a,
            width: l,
            height: r
        } = t;
        this.x = n, this.y = a, this.width = l, this.height = r
    }
    get top() {
        return this.y
    }
    get bottom() {
        return this.y + this.height
    }
    get left() {
        return this.x
    }
    get right() {
        return this.x + this.width
    }
}

function dy(e, t) {
    return {
        x: {
            before: Math.max(0, t.left - e.left),
            after: Math.max(0, e.right - t.right)
        },
        y: {
            before: Math.max(0, t.top - e.top),
            after: Math.max(0, e.bottom - t.bottom)
        }
    }
}

function aS(e) {
    return Array.isArray(e) ? new Pl({
        x: e[0],
        y: e[1],
        width: 0,
        height: 0
    }) : e.getBoundingClientRect()
}

function Ov(e) {
    const t = e.getBoundingClientRect(),
        n = getComputedStyle(e),
        a = n.transform;
    if (a) {
        let l, r, o, i, s;
        if (a.startsWith("matrix3d(")) l = a.slice(9, -1).split(/, /), r = +l[0], o = +l[5], i = +l[12], s = +l[13];
        else if (a.startsWith("matrix(")) l = a.slice(7, -1).split(/, /), r = +l[0], o = +l[3], i = +l[4], s = +l[5];
        else return new Pl(t);
        const u = n.transformOrigin,
            c = t.x - i - (1 - r) * parseFloat(u),
            d = t.y - s - (1 - o) * parseFloat(u.slice(u.indexOf(" ") + 1)),
            f = r ? t.width / r : e.offsetWidth + 1,
            v = o ? t.height / o : e.offsetHeight + 1;
        return new Pl({
            x: c,
            y: d,
            width: f,
            height: v
        })
    } else return new Pl(t)
}

function yl(e, t, n) {
    if (typeof e.animate > "u") return {
        finished: Promise.resolve()
    };
    let a;
    try {
        a = e.animate(t, n)
    } catch {
        return {
            finished: Promise.resolve()
        }
    }
    return typeof a.finished > "u" && (a.finished = new Promise(l => {
        a.onfinish = () => {
            l(a)
        }
    })), a
}
const Qi = new WeakMap;

function HD(e, t) {
    Object.keys(t).forEach(n => {
        if (ku(n)) {
            const a = Q0(n),
                l = Qi.get(e);
            if (t[n] == null) l == null || l.forEach(r => {
                const [o, i] = r;
                o === a && (e.removeEventListener(a, i), l.delete(r))
            });
            else if (!l || ![...l].some(r => r[0] === a && r[1] === t[n])) {
                e.addEventListener(a, t[n]);
                const r = l || new Set;
                r.add([a, t[n]]), Qi.has(e) || Qi.set(e, r)
            }
        } else t[n] == null ? e.removeAttribute(n) : e.setAttribute(n, t[n])
    })
}

function jD(e, t) {
    Object.keys(t).forEach(n => {
        if (ku(n)) {
            const a = Q0(n),
                l = Qi.get(e);
            l == null || l.forEach(r => {
                const [o, i] = r;
                o === a && (e.removeEventListener(a, i), l.delete(r))
            })
        } else e.removeAttribute(n)
    })
}
const lr = 2.4,
    fy = .2126729,
    vy = .7151522,
    my = .072175,
    UD = .55,
    WD = .58,
    zD = .57,
    KD = .62,
    Hi = .03,
    hy = 1.45,
    GD = 5e-4,
    YD = 1.25,
    qD = 1.25,
    gy = .078,
    yy = 12.82051282051282,
    ji = .06,
    by = .001;

function py(e, t) {
    const n = (e.r / 255) ** lr,
        a = (e.g / 255) ** lr,
        l = (e.b / 255) ** lr,
        r = (t.r / 255) ** lr,
        o = (t.g / 255) ** lr,
        i = (t.b / 255) ** lr;
    let s = n * fy + a * vy + l * my,
        u = r * fy + o * vy + i * my;
    if (s <= Hi && (s += (Hi - s) ** hy), u <= Hi && (u += (Hi - u) ** hy), Math.abs(u - s) < GD) return 0;
    let c;
    if (u > s) {
        const d = (u ** UD - s ** WD) * YD;
        c = d < by ? 0 : d < gy ? d - d * yy * ji : d - ji
    } else {
        const d = (u ** KD - s ** zD) * qD;
        c = d > -by ? 0 : d > -gy ? d - d * yy * ji : d + ji
    }
    return c * 100
}

function XD(e, t) {
    t = Array.isArray(t) ? t.slice(0, -1).map(n => `'${n}'`).join(", ") + ` or '${t.at(-1)}'` : `'${t}'`
}
const Os = .20689655172413793,
    JD = e => e > Os ** 3 ? Math.cbrt(e) : e / (3 * Os ** 2) + 4 / 29,
    ZD = e => e > Os ? e ** 3 : 3 * Os ** 2 * (e - 4 / 29);

function lS(e) {
    const t = JD,
        n = t(e[1]);
    return [116 * n - 16, 500 * (t(e[0] / .95047) - n), 200 * (n - t(e[2] / 1.08883))]
}

function rS(e) {
    const t = ZD,
        n = (e[0] + 16) / 116;
    return [t(n + e[1] / 500) * .95047, t(n), t(n - e[2] / 200) * 1.08883]
}
const QD = [
        [3.2406, -1.5372, -.4986],
        [-.9689, 1.8758, .0415],
        [.0557, -.204, 1.057]
    ],
    eM = e => e <= .0031308 ? e * 12.92 : 1.055 * e ** (1 / 2.4) - .055,
    tM = [
        [.4124, .3576, .1805],
        [.2126, .7152, .0722],
        [.0193, .1192, .9505]
    ],
    nM = e => e <= .04045 ? e / 12.92 : ((e + .055) / 1.055) ** 2.4;

function oS(e) {
    const t = Array(3),
        n = eM,
        a = QD;
    for (let l = 0; l < 3; ++l) t[l] = Math.round(ot(n(a[l][0] * e[0] + a[l][1] * e[1] + a[l][2] * e[2])) * 255);
    return {
        r: t[0],
        g: t[1],
        b: t[2]
    }
}

function Rv(e) {
    let {
        r: t,
        g: n,
        b: a
    } = e;
    const l = [0, 0, 0],
        r = nM,
        o = tM;
    t = r(t / 255), n = r(n / 255), a = r(a / 255);
    for (let i = 0; i < 3; ++i) l[i] = o[i][0] * t + o[i][1] * n + o[i][2] * a;
    return l
}

function Dd(e) {
    return !!e && /^(#|var\(--|(rgb|hsl)a?\()/.test(e)
}

function aM(e) {
    return Dd(e) && !/^((rgb|hsl)a?\()?var\(--/.test(e)
}
const _y = /^(?<fn>(?:rgb|hsl)a?)\((?<values>.+)\)/,
    lM = {
        rgb: (e, t, n, a) => ({
            r: e,
            g: t,
            b: n,
            a
        }),
        rgba: (e, t, n, a) => ({
            r: e,
            g: t,
            b: n,
            a
        }),
        hsl: (e, t, n, a) => Sy({
            h: e,
            s: t,
            l: n,
            a
        }),
        hsla: (e, t, n, a) => Sy({
            h: e,
            s: t,
            l: n,
            a
        }),
        hsv: (e, t, n, a) => ka({
            h: e,
            s: t,
            v: n,
            a
        }),
        hsva: (e, t, n, a) => ka({
            h: e,
            s: t,
            v: n,
            a
        })
    };

function En(e) {
    if (typeof e == "number") return {
        r: (e & 16711680) >> 16,
        g: (e & 65280) >> 8,
        b: e & 255
    };
    if (typeof e == "string" && _y.test(e)) {
        const {
            groups: t
        } = e.match(_y), {
            fn: n,
            values: a
        } = t, l = a.split(/,\s*/).map(r => r.endsWith("%") && ["hsl", "hsla", "hsv", "hsva"].includes(n) ? parseFloat(r) / 100 : parseFloat(r));
        return lM[n](...l)
    } else if (typeof e == "string") {
        let t = e.startsWith("#") ? e.slice(1) : e;
        return [3, 4].includes(t.length) ? t = t.split("").map(n => n + n).join("") : [6, 8].includes(t.length), dS(t)
    } else if (typeof e == "object") {
        if (gl(e, ["r", "g", "b"])) return e;
        if (gl(e, ["h", "s", "l"])) return ka(Dv(e));
        if (gl(e, ["h", "s", "v"])) return ka(e)
    }
    throw new TypeError(`Invalid color: ${e==null?e:String(e)||e.constructor.name}
Expected #hex, #hexa, rgb(), rgba(), hsl(), hsla(), object or number`)
}

function ka(e) {
    const {
        h: t,
        s: n,
        v: a,
        a: l
    } = e, r = i => {
        const s = (i + t / 60) % 6;
        return a - a * n * Math.max(Math.min(s, 4 - s, 1), 0)
    }, o = [r(5), r(3), r(1)].map(i => Math.round(i * 255));
    return {
        r: o[0],
        g: o[1],
        b: o[2],
        a: l
    }
}

function Sy(e) {
    return ka(Dv(e))
}

function xu(e) {
    if (!e) return {
        h: 0,
        s: 1,
        v: 1,
        a: 1
    };
    const t = e.r / 255,
        n = e.g / 255,
        a = e.b / 255,
        l = Math.max(t, n, a),
        r = Math.min(t, n, a);
    let o = 0;
    l !== r && (l === t ? o = 60 * (0 + (n - a) / (l - r)) : l === n ? o = 60 * (2 + (a - t) / (l - r)) : l === a && (o = 60 * (4 + (t - n) / (l - r)))), o < 0 && (o = o + 360);
    const i = l === 0 ? 0 : (l - r) / l,
        s = [o, i, l];
    return {
        h: s[0],
        s: s[1],
        v: s[2],
        a: e.a
    }
}

function iS(e) {
    const {
        h: t,
        s: n,
        v: a,
        a: l
    } = e, r = a - a * n / 2, o = r === 1 || r === 0 ? 0 : (a - r) / Math.min(r, 1 - r);
    return {
        h: t,
        s: o,
        l: r,
        a: l
    }
}

function Dv(e) {
    const {
        h: t,
        s: n,
        l: a,
        a: l
    } = e, r = a + n * Math.min(a, 1 - a), o = r === 0 ? 0 : 2 - 2 * a / r;
    return {
        h: t,
        s: o,
        v: r,
        a: l
    }
}

function sS(e) {
    let {
        r: t,
        g: n,
        b: a,
        a: l
    } = e;
    return l === void 0 ? `rgb(${t}, ${n}, ${a})` : `rgba(${t}, ${n}, ${a}, ${l})`
}

function uS(e) {
    return sS(ka(e))
}

function Ui(e) {
    const t = Math.round(e).toString(16);
    return ("00".substr(0, 2 - t.length) + t).toUpperCase()
}

function cS(e) {
    let {
        r: t,
        g: n,
        b: a,
        a: l
    } = e;
    return `#${[Ui(t),Ui(n),Ui(a),l!==void 0?Ui(Math.round(l*255)):""].join("")}`
}

function dS(e) {
    e = rM(e);
    let [t, n, a, l] = RD(e, 2).map(r => parseInt(r, 16));
    return l = l === void 0 ? l : l / 255, {
        r: t,
        g: n,
        b: a,
        a: l
    }
}

function fS(e) {
    const t = dS(e);
    return xu(t)
}

function vS(e) {
    return cS(ka(e))
}

function rM(e) {
    return e.startsWith("#") && (e = e.slice(1)), e = e.replace(/([^0-9a-f])/gi, "F"), (e.length === 3 || e.length === 4) && (e = e.split("").map(t => t + t).join("")), e.length !== 6 && (e = ry(ry(e, 6), 8, "F")), e
}

function oM(e, t) {
    const n = lS(Rv(e));
    return n[0] = n[0] + t * 10, oS(rS(n))
}

function iM(e, t) {
    const n = lS(Rv(e));
    return n[0] = n[0] - t * 10, oS(rS(n))
}

function Md(e) {
    const t = En(e);
    return Rv(t)[1]
}

function sM(e, t) {
    const n = Md(e),
        a = Md(t),
        l = Math.max(n, a),
        r = Math.min(n, a);
    return (l + .05) / (r + .05)
}

function mS(e) {
    const t = Math.abs(py(En(0), En(e)));
    return Math.abs(py(En(16777215), En(e))) > Math.min(t, 50) ? "#fff" : "#000"
}

function W(e, t) {
    return n => Object.keys(e).reduce((a, l) => {
        const o = typeof e[l] == "object" && e[l] != null && !Array.isArray(e[l]) ? e[l] : {
            type: e[l]
        };
        return n && l in n ? a[l] = { ...o,
            default: n[l]
        } : a[l] = o, t && !a[l].source && (a[l].source = t), a
    }, {})
}
const Se = W({
    class: [String, Array, Object],
    style: {
        type: [String, Array, Object],
        default: null
    }
}, "component");

function ut(e, t) {
    const n = nn();
    if (!n) throw new Error(`[Vuetify] ${e} must be called from inside a setup function`);
    return n
}

function ra() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "composables";
    const t = ut(e).type;
    return Cl((t == null ? void 0 : t.aliasName) || (t == null ? void 0 : t.name))
}
let hS = 0,
    es = new WeakMap;

function Rt() {
    const e = ut("getUid");
    if (es.has(e)) return es.get(e); {
        const t = hS++;
        return es.set(e, t), t
    }
}
Rt.reset = () => {
    hS = 0, es = new WeakMap
};

function uM(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ut("injectSelf");
    const {
        provides: n
    } = t;
    if (n && e in n) return n[e]
}
const Rr = Symbol.for("vuetify:defaults");

function cM(e) {
    return Q(e)
}

function Mv() {
    const e = Te(Rr);
    if (!e) throw new Error("[Vuetify] Could not find defaults instance");
    return e
}

function lt(e, t) {
    const n = Mv(),
        a = Q(e),
        l = C(() => {
            if (Ie(t == null ? void 0 : t.disabled)) return n.value;
            const o = Ie(t == null ? void 0 : t.scoped),
                i = Ie(t == null ? void 0 : t.reset),
                s = Ie(t == null ? void 0 : t.root);
            if (a.value == null && !(o || i || s)) return n.value;
            let u = Ht(a.value, {
                prev: n.value
            });
            if (o) return u;
            if (i || s) {
                const c = Number(i || 1 / 0);
                for (let d = 0; d <= c && !(!u || !("prev" in u)); d++) u = u.prev;
                return u && typeof s == "string" && s in u && (u = Ht(Ht(u, {
                    prev: u
                }), u[s])), u
            }
            return u.prev ? Ht(u.prev, u) : u
        });
    return He(Rr, l), l
}

function dM(e, t) {
    var n, a;
    return typeof((n = e.props) == null ? void 0 : n[t]) < "u" || typeof((a = e.props) == null ? void 0 : a[Cl(t)]) < "u"
}

function fM() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
        t = arguments.length > 1 ? arguments[1] : void 0,
        n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Mv();
    const a = ut("useDefaults");
    if (t = t ? ? a.type.name ? ? a.type.__name, !t) throw new Error("[Vuetify] Could not determine component name");
    const l = C(() => {
            var s;
            return (s = n.value) == null ? void 0 : s[e._as ? ? t]
        }),
        r = new Proxy(e, {
            get(s, u) {
                var d, f, v, g, h, y, S;
                const c = Reflect.get(s, u);
                return u === "class" || u === "style" ? [(d = l.value) == null ? void 0 : d[u], c].filter(b => b != null) : typeof u == "string" && !dM(a.vnode, u) ? ((f = l.value) == null ? void 0 : f[u]) !== void 0 ? (v = l.value) == null ? void 0 : v[u] : ((h = (g = n.value) == null ? void 0 : g.global) == null ? void 0 : h[u]) !== void 0 ? (S = (y = n.value) == null ? void 0 : y.global) == null ? void 0 : S[u] : c : c
            }
        }),
        o = fe();
    st(() => {
        if (l.value) {
            const s = Object.entries(l.value).filter(u => {
                let [c] = u;
                return c.startsWith(c[0].toUpperCase())
            });
            o.value = s.length ? Object.fromEntries(s) : void 0
        } else o.value = void 0
    });

    function i() {
        const s = uM(Rr, a);
        He(Rr, C(() => o.value ? Ht((s == null ? void 0 : s.value) ? ? {}, o.value) : s == null ? void 0 : s.value))
    }
    return {
        props: r,
        provideSubDefaults: i
    }
}

function pn(e) {
    if (e._setup = e._setup ? ? e.setup, !e.name) return e;
    if (e._setup) {
        e.props = W(e.props ? ? {}, e.name)();
        const t = Object.keys(e.props).filter(n => n !== "class" && n !== "style");
        e.filterProps = function(a) {
            return Vv(a, t)
        }, e.props._as = String, e.setup = function(a, l) {
            const r = Mv();
            if (!r.value) return e._setup(a, l);
            const {
                props: o,
                provideSubDefaults: i
            } = fM(a, a._as ? ? e.name, r), s = e._setup(o, l);
            return i(), s
        }
    }
    return e
}

function Z() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    return t => (e ? pn : Ln)(t)
}

function vM(e, t) {
    return t.props = e, t
}

function oa(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "div",
        n = arguments.length > 2 ? arguments[2] : void 0;
    return Z()({
        name: n ? ? na(Qt(e.replace(/__/g, "-"))),
        props: {
            tag: {
                type: String,
                default: t
            },
            ...Se()
        },
        setup(a, l) {
            let {
                slots: r
            } = l;
            return () => {
                var o;
                return ht(a.tag, {
                    class: [e, a.class],
                    style: a.style
                }, (o = r.default) == null ? void 0 : o.call(r))
            }
        }
    })
}

function gS(e) {
    if (typeof e.getRootNode != "function") {
        for (; e.parentNode;) e = e.parentNode;
        return e !== document ? null : document
    }
    const t = e.getRootNode();
    return t !== document && t.getRootNode({
        composed: !0
    }) !== document ? null : t
}
const $o = "cubic-bezier(0.4, 0, 0.2, 1)",
    mM = "cubic-bezier(0.0, 0, 0.2, 1)",
    hM = "cubic-bezier(0.4, 0, 1, 1)";

function wy(e, t, n) {
    return Object.keys(e).filter(a => ku(a) && a.endsWith(t)).reduce((a, l) => (a[l.slice(0, -t.length)] = r => e[l](r, n(r)), a), {})
}

function Nv(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    for (; e;) {
        if (t ? gM(e) : $v(e)) return e;
        e = e.parentElement
    }
    return document.scrollingElement
}

function Bo(e, t) {
    const n = [];
    if (t && e && !t.contains(e)) return n;
    for (; e && ($v(e) && n.push(e), e !== t);) e = e.parentElement;
    return n
}

function $v(e) {
    if (!e || e.nodeType !== Node.ELEMENT_NODE) return !1;
    const t = window.getComputedStyle(e);
    return t.overflowY === "scroll" || t.overflowY === "auto" && e.scrollHeight > e.clientHeight
}

function gM(e) {
    if (!e || e.nodeType !== Node.ELEMENT_NODE) return !1;
    const t = window.getComputedStyle(e);
    return ["scroll", "auto"].includes(t.overflowY)
}

function yM(e) {
    for (; e;) {
        if (window.getComputedStyle(e).position === "fixed") return !0;
        e = e.offsetParent
    }
    return !1
}

function ne(e) {
    const t = ut("useRender");
    t.render = e
}

function Ce(e, t, n) {
    let a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : d => d,
        l = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : d => d;
    const r = ut("useProxiedModel"),
        o = Q(e[t] !== void 0 ? e[t] : n),
        i = Cl(t),
        u = C(i !== t ? () => {
            var d, f, v, g;
            return e[t], !!(((d = r.vnode.props) != null && d.hasOwnProperty(t) || (f = r.vnode.props) != null && f.hasOwnProperty(i)) && ((v = r.vnode.props) != null && v.hasOwnProperty(`onUpdate:${t}`) || (g = r.vnode.props) != null && g.hasOwnProperty(`onUpdate:${i}`)))
        } : () => {
            var d, f;
            return e[t], !!((d = r.vnode.props) != null && d.hasOwnProperty(t) && ((f = r.vnode.props) != null && f.hasOwnProperty(`onUpdate:${t}`)))
        });
    Yt(() => !u.value, () => {
        de(() => e[t], d => {
            o.value = d
        })
    });
    const c = C({
        get() {
            const d = e[t];
            return a(u.value ? d : o.value)
        },
        set(d) {
            const f = l(d),
                v = xe(u.value ? e[t] : o.value);
            v === f || a(v) === d || (o.value = f, r == null || r.emit(`update:${t}`, f))
        }
    });
    return Object.defineProperty(c, "externalValue", {
        get: () => u.value ? e[t] : o.value
    }), c
}
const yS = {
        badge: "Badge",
        open: "Open",
        close: "Close",
        dismiss: "Dismiss",
        confirmEdit: {
            ok: "OK",
            cancel: "Cancel"
        },
        dataIterator: {
            noResultsText: "No matching records found",
            loadingText: "Loading items..."
        },
        dataTable: {
            itemsPerPageText: "Rows per page:",
            ariaLabel: {
                sortDescending: "Sorted descending.",
                sortAscending: "Sorted ascending.",
                sortNone: "Not sorted.",
                activateNone: "Activate to remove sorting.",
                activateDescending: "Activate to sort descending.",
                activateAscending: "Activate to sort ascending."
            },
            sortBy: "Sort by"
        },
        dataFooter: {
            itemsPerPageText: "Items per page:",
            itemsPerPageAll: "All",
            nextPage: "Next page",
            prevPage: "Previous page",
            firstPage: "First page",
            lastPage: "Last page",
            pageText: "{0}-{1} of {2}"
        },
        dateRangeInput: {
            divider: "to"
        },
        datePicker: {
            itemsSelected: "{0} selected",
            range: {
                title: "Select dates",
                header: "Enter dates"
            },
            title: "Select date",
            header: "Enter date",
            input: {
                placeholder: "Enter date"
            }
        },
        noDataText: "No data available",
        carousel: {
            prev: "Previous visual",
            next: "Next visual",
            ariaLabel: {
                delimiter: "Carousel slide {0} of {1}"
            }
        },
        calendar: {
            moreEvents: "{0} more",
            today: "Today"
        },
        input: {
            clear: "Clear {0}",
            prependAction: "{0} prepended action",
            appendAction: "{0} appended action",
            otp: "Please enter OTP character {0}"
        },
        fileInput: {
            counter: "{0} files",
            counterSize: "{0} files ({1} in total)"
        },
        timePicker: {
            am: "AM",
            pm: "PM",
            title: "Select Time"
        },
        pagination: {
            ariaLabel: {
                root: "Pagination Navigation",
                next: "Next page",
                previous: "Previous page",
                page: "Go to page {0}",
                currentPage: "Page {0}, Current page",
                first: "First page",
                last: "Last page"
            }
        },
        stepper: {
            next: "Next",
            prev: "Previous"
        },
        rating: {
            ariaLabel: {
                item: "Rating {0} of {1}"
            }
        },
        loading: "Loading...",
        infiniteScroll: {
            loadMore: "Load more",
            empty: "No more"
        }
    },
    ky = "$vuetify.",
    Cy = (e, t) => e.replace(/\{(\d+)\}/g, (n, a) => String(t[+a])),
    bS = (e, t, n) => function(a) {
        for (var l = arguments.length, r = new Array(l > 1 ? l - 1 : 0), o = 1; o < l; o++) r[o - 1] = arguments[o];
        if (!a.startsWith(ky)) return Cy(a, r);
        const i = a.replace(ky, ""),
            s = e.value && n.value[e.value],
            u = t.value && n.value[t.value];
        let c = Ll(s, i, null);
        return c || (`${a}${e.value}`, c = Ll(u, i, null)), c || (c = a), typeof c != "string" && (c = a), Cy(c, r)
    };

function pS(e, t) {
    return (n, a) => new Intl.NumberFormat([e.value, t.value], a).format(n)
}

function Sc(e, t, n) {
    const a = Ce(e, t, e[t] ? ? n.value);
    return a.value = e[t] ? ? n.value, de(n, l => {
        e[t] == null && (a.value = n.value)
    }), a
}

function _S(e) {
    return t => {
        const n = Sc(t, "locale", e.current),
            a = Sc(t, "fallback", e.fallback),
            l = Sc(t, "messages", e.messages);
        return {
            name: "vuetify",
            current: n,
            fallback: a,
            messages: l,
            t: bS(n, a, l),
            n: pS(n, a),
            provide: _S({
                current: n,
                fallback: a,
                messages: l
            })
        }
    }
}

function bM(e) {
    const t = fe((e == null ? void 0 : e.locale) ? ? "en"),
        n = fe((e == null ? void 0 : e.fallback) ? ? "en"),
        a = Q({
            en: yS,
            ...e == null ? void 0 : e.messages
        });
    return {
        name: "vuetify",
        current: t,
        fallback: n,
        messages: a,
        t: bS(t, n, a),
        n: pS(t, n),
        provide: _S({
            current: t,
            fallback: n,
            messages: a
        })
    }
}
const Dr = Symbol.for("vuetify:locale");

function pM(e) {
    return e.name != null
}

function _M(e) {
    const t = e != null && e.adapter && pM(e == null ? void 0 : e.adapter) ? e == null ? void 0 : e.adapter : bM(e),
        n = kM(t, e);
    return { ...t,
        ...n
    }
}

function Qe() {
    const e = Te(Dr);
    if (!e) throw new Error("[Vuetify] Could not find injected locale instance");
    return e
}

function SM(e) {
    const t = Te(Dr);
    if (!t) throw new Error("[Vuetify] Could not find injected locale instance");
    const n = t.provide(e),
        a = CM(n, t.rtl, e),
        l = { ...n,
            ...a
        };
    return He(Dr, l), l
}

function wM() {
    return {
        af: !1,
        ar: !0,
        bg: !1,
        ca: !1,
        ckb: !1,
        cs: !1,
        de: !1,
        el: !1,
        en: !1,
        es: !1,
        et: !1,
        fa: !0,
        fi: !1,
        fr: !1,
        hr: !1,
        hu: !1,
        he: !0,
        id: !1,
        it: !1,
        ja: !1,
        km: !1,
        ko: !1,
        lv: !1,
        lt: !1,
        nl: !1,
        no: !1,
        pl: !1,
        pt: !1,
        ro: !1,
        ru: !1,
        sk: !1,
        sl: !1,
        srCyrl: !1,
        srLatn: !1,
        sv: !1,
        th: !1,
        tr: !1,
        az: !1,
        uk: !1,
        vi: !1,
        zhHans: !1,
        zhHant: !1
    }
}

function kM(e, t) {
    const n = Q((t == null ? void 0 : t.rtl) ? ? wM()),
        a = C(() => n.value[e.current.value] ? ? !1);
    return {
        isRtl: a,
        rtl: n,
        rtlClasses: C(() => `v-locale--is-${a.value?"rtl":"ltr"}`)
    }
}

function CM(e, t, n) {
    const a = C(() => n.rtl ? ? t.value[e.current.value] ? ? !1);
    return {
        isRtl: a,
        rtl: t,
        rtlClasses: C(() => `v-locale--is-${a.value?"rtl":"ltr"}`)
    }
}

function xt() {
    const e = Te(Dr);
    if (!e) throw new Error("[Vuetify] Could not find injected rtl instance");
    return {
        isRtl: e.isRtl,
        rtlClasses: e.rtlClasses
    }
}
const Pu = {
    "001": 1,
    AD: 1,
    AE: 6,
    AF: 6,
    AG: 0,
    AI: 1,
    AL: 1,
    AM: 1,
    AN: 1,
    AR: 1,
    AS: 0,
    AT: 1,
    AU: 1,
    AX: 1,
    AZ: 1,
    BA: 1,
    BD: 0,
    BE: 1,
    BG: 1,
    BH: 6,
    BM: 1,
    BN: 1,
    BR: 0,
    BS: 0,
    BT: 0,
    BW: 0,
    BY: 1,
    BZ: 0,
    CA: 0,
    CH: 1,
    CL: 1,
    CM: 1,
    CN: 1,
    CO: 0,
    CR: 1,
    CY: 1,
    CZ: 1,
    DE: 1,
    DJ: 6,
    DK: 1,
    DM: 0,
    DO: 0,
    DZ: 6,
    EC: 1,
    EE: 1,
    EG: 6,
    ES: 1,
    ET: 0,
    FI: 1,
    FJ: 1,
    FO: 1,
    FR: 1,
    GB: 1,
    "GB-alt-variant": 0,
    GE: 1,
    GF: 1,
    GP: 1,
    GR: 1,
    GT: 0,
    GU: 0,
    HK: 0,
    HN: 0,
    HR: 1,
    HU: 1,
    ID: 0,
    IE: 1,
    IL: 0,
    IN: 0,
    IQ: 6,
    IR: 6,
    IS: 1,
    IT: 1,
    JM: 0,
    JO: 6,
    JP: 0,
    KE: 0,
    KG: 1,
    KH: 0,
    KR: 0,
    KW: 6,
    KZ: 1,
    LA: 0,
    LB: 1,
    LI: 1,
    LK: 1,
    LT: 1,
    LU: 1,
    LV: 1,
    LY: 6,
    MC: 1,
    MD: 1,
    ME: 1,
    MH: 0,
    MK: 1,
    MM: 0,
    MN: 1,
    MO: 0,
    MQ: 1,
    MT: 0,
    MV: 5,
    MX: 0,
    MY: 1,
    MZ: 0,
    NI: 0,
    NL: 1,
    NO: 1,
    NP: 0,
    NZ: 1,
    OM: 6,
    PA: 0,
    PE: 0,
    PH: 0,
    PK: 0,
    PL: 1,
    PR: 0,
    PT: 0,
    PY: 0,
    QA: 6,
    RE: 1,
    RO: 1,
    RS: 1,
    RU: 1,
    SA: 0,
    SD: 6,
    SE: 1,
    SG: 0,
    SI: 1,
    SK: 1,
    SM: 1,
    SV: 0,
    SY: 6,
    TH: 0,
    TJ: 1,
    TM: 1,
    TR: 1,
    TT: 0,
    TW: 0,
    UA: 1,
    UM: 0,
    US: 0,
    UY: 1,
    UZ: 1,
    VA: 1,
    VE: 0,
    VI: 0,
    VN: 1,
    WS: 0,
    XK: 1,
    YE: 0,
    ZA: 0,
    ZW: 0
};

function xM(e, t, n) {
    const a = [];
    let l = [];
    const r = SS(e),
        o = wS(e),
        i = n ? ? Pu[t.slice(-2).toUpperCase()] ? ? 0,
        s = (r.getDay() - i + 7) % 7,
        u = (o.getDay() - i + 7) % 7;
    for (let c = 0; c < s; c++) {
        const d = new Date(r);
        d.setDate(d.getDate() - (s - c)), l.push(d)
    }
    for (let c = 1; c <= o.getDate(); c++) {
        const d = new Date(e.getFullYear(), e.getMonth(), c);
        l.push(d), l.length === 7 && (a.push(l), l = [])
    }
    for (let c = 1; c < 7 - u; c++) {
        const d = new Date(o);
        d.setDate(d.getDate() + c), l.push(d)
    }
    return l.length > 0 && a.push(l), a
}

function PM(e, t, n) {
    const a = n ? ? Pu[t.slice(-2).toUpperCase()] ? ? 0,
        l = new Date(e);
    for (; l.getDay() !== a;) l.setDate(l.getDate() - 1);
    return l
}

function EM(e, t) {
    const n = new Date(e),
        a = ((Pu[t.slice(-2).toUpperCase()] ? ? 0) + 6) % 7;
    for (; n.getDay() !== a;) n.setDate(n.getDate() + 1);
    return n
}

function SS(e) {
    return new Date(e.getFullYear(), e.getMonth(), 1)
}

function wS(e) {
    return new Date(e.getFullYear(), e.getMonth() + 1, 0)
}

function IM(e) {
    const t = e.split("-").map(Number);
    return new Date(t[0], t[1] - 1, t[2])
}
const TM = /^([12]\d{3}-([1-9]|0[1-9]|1[0-2])-([1-9]|0[1-9]|[12]\d|3[01]))$/;

function kS(e) {
    if (e == null) return new Date;
    if (e instanceof Date) return e;
    if (typeof e == "string") {
        let t;
        if (TM.test(e)) return IM(e);
        if (t = Date.parse(e), !isNaN(t)) return new Date(t)
    }
    return null
}
const xy = new Date(2e3, 0, 2);

function VM(e, t) {
    const n = t ? ? Pu[e.slice(-2).toUpperCase()] ? ? 0;
    return fn(7).map(a => {
        const l = new Date(xy);
        return l.setDate(xy.getDate() + n + a), new Intl.DateTimeFormat(e, {
            weekday: "narrow"
        }).format(l)
    })
}

function AM(e, t, n, a) {
    const l = kS(e) ? ? new Date,
        r = a == null ? void 0 : a[t];
    if (typeof r == "function") return r(l, t, n);
    let o = {};
    switch (t) {
        case "fullDate":
            o = {
                year: "numeric",
                month: "long",
                day: "numeric"
            };
            break;
        case "fullDateWithWeekday":
            o = {
                weekday: "long",
                year: "numeric",
                month: "long",
                day: "numeric"
            };
            break;
        case "normalDate":
            const i = l.getDate(),
                s = new Intl.DateTimeFormat(n, {
                    month: "long"
                }).format(l);
            return `${i} ${s}`;
        case "normalDateWithWeekday":
            o = {
                weekday: "short",
                day: "numeric",
                month: "short"
            };
            break;
        case "shortDate":
            o = {
                month: "short",
                day: "numeric"
            };
            break;
        case "year":
            o = {
                year: "numeric"
            };
            break;
        case "month":
            o = {
                month: "long"
            };
            break;
        case "monthShort":
            o = {
                month: "short"
            };
            break;
        case "monthAndYear":
            o = {
                month: "long",
                year: "numeric"
            };
            break;
        case "monthAndDate":
            o = {
                month: "long",
                day: "numeric"
            };
            break;
        case "weekday":
            o = {
                weekday: "long"
            };
            break;
        case "weekdayShort":
            o = {
                weekday: "short"
            };
            break;
        case "dayOfMonth":
            return new Intl.NumberFormat(n).format(l.getDate());
        case "hours12h":
            o = {
                hour: "numeric",
                hour12: !0
            };
            break;
        case "hours24h":
            o = {
                hour: "numeric",
                hour12: !1
            };
            break;
        case "minutes":
            o = {
                minute: "numeric"
            };
            break;
        case "seconds":
            o = {
                second: "numeric"
            };
            break;
        case "fullTime":
            o = {
                hour: "numeric",
                minute: "numeric",
                second: "numeric",
                hour12: !0
            };
            break;
        case "fullTime12h":
            o = {
                hour: "numeric",
                minute: "numeric",
                second: "numeric",
                hour12: !0
            };
            break;
        case "fullTime24h":
            o = {
                hour: "numeric",
                minute: "numeric",
                second: "numeric",
                hour12: !1
            };
            break;
        case "fullDateTime":
            o = {
                year: "numeric",
                month: "long",
                day: "numeric",
                hour: "numeric",
                minute: "numeric",
                second: "numeric",
                hour12: !0
            };
            break;
        case "fullDateTime12h":
            o = {
                year: "numeric",
                month: "long",
                day: "numeric",
                hour: "numeric",
                minute: "numeric",
                second: "numeric",
                hour12: !0
            };
            break;
        case "fullDateTime24h":
            o = {
                year: "numeric",
                month: "long",
                day: "numeric",
                hour: "numeric",
                minute: "numeric",
                second: "numeric",
                hour12: !1
            };
            break;
        case "keyboardDate":
            o = {
                year: "numeric",
                month: "2-digit",
                day: "2-digit"
            };
            break;
        case "keyboardDateTime":
            o = {
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "numeric",
                minute: "numeric",
                second: "numeric",
                hour12: !1
            };
            break;
        case "keyboardDateTime12h":
            o = {
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "numeric",
                minute: "numeric",
                second: "numeric",
                hour12: !0
            };
            break;
        case "keyboardDateTime24h":
            o = {
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "numeric",
                minute: "numeric",
                second: "numeric",
                hour12: !1
            };
            break;
        default:
            o = r ? ? {
                timeZone: "UTC",
                timeZoneName: "short"
            }
    }
    return new Intl.DateTimeFormat(n, o).format(l)
}

function LM(e, t) {
    const n = e.toJsDate(t),
        a = n.getFullYear(),
        l = oy(String(n.getMonth() + 1), 2, "0"),
        r = oy(String(n.getDate()), 2, "0");
    return `${a}-${l}-${r}`
}

function OM(e) {
    const [t, n, a] = e.split("-").map(Number);
    return new Date(t, n - 1, a)
}

function RM(e, t) {
    const n = new Date(e);
    return n.setMinutes(n.getMinutes() + t), n
}

function DM(e, t) {
    const n = new Date(e);
    return n.setHours(n.getHours() + t), n
}

function MM(e, t) {
    const n = new Date(e);
    return n.setDate(n.getDate() + t), n
}

function NM(e, t) {
    const n = new Date(e);
    return n.setDate(n.getDate() + t * 7), n
}

function $M(e, t) {
    const n = new Date(e);
    return n.setDate(1), n.setMonth(n.getMonth() + t), n
}

function BM(e) {
    return e.getFullYear()
}

function FM(e) {
    return e.getMonth()
}

function HM(e) {
    return e.getDate()
}

function jM(e) {
    return new Date(e.getFullYear(), e.getMonth() + 1, 1)
}

function UM(e) {
    return new Date(e.getFullYear(), e.getMonth() - 1, 1)
}

function WM(e) {
    return e.getHours()
}

function zM(e) {
    return e.getMinutes()
}

function KM(e) {
    return new Date(e.getFullYear(), 0, 1)
}

function GM(e) {
    return new Date(e.getFullYear(), 11, 31)
}

function YM(e, t) {
    return Rs(e, t[0]) && JM(e, t[1])
}

function qM(e) {
    const t = new Date(e);
    return t instanceof Date && !isNaN(t.getTime())
}

function Rs(e, t) {
    return e.getTime() > t.getTime()
}

function XM(e, t) {
    return Rs(Nd(e), Nd(t))
}

function JM(e, t) {
    return e.getTime() < t.getTime()
}

function Py(e, t) {
    return e.getTime() === t.getTime()
}

function ZM(e, t) {
    return e.getDate() === t.getDate() && e.getMonth() === t.getMonth() && e.getFullYear() === t.getFullYear()
}

function QM(e, t) {
    return e.getMonth() === t.getMonth() && e.getFullYear() === t.getFullYear()
}

function eN(e, t) {
    return e.getFullYear() === t.getFullYear()
}

function tN(e, t, n) {
    const a = new Date(e),
        l = new Date(t);
    switch (n) {
        case "years":
            return a.getFullYear() - l.getFullYear();
        case "quarters":
            return Math.floor((a.getMonth() - l.getMonth() + (a.getFullYear() - l.getFullYear()) * 12) / 4);
        case "months":
            return a.getMonth() - l.getMonth() + (a.getFullYear() - l.getFullYear()) * 12;
        case "weeks":
            return Math.floor((a.getTime() - l.getTime()) / (1e3 * 60 * 60 * 24 * 7));
        case "days":
            return Math.floor((a.getTime() - l.getTime()) / (1e3 * 60 * 60 * 24));
        case "hours":
            return Math.floor((a.getTime() - l.getTime()) / (1e3 * 60 * 60));
        case "minutes":
            return Math.floor((a.getTime() - l.getTime()) / (1e3 * 60));
        case "seconds":
            return Math.floor((a.getTime() - l.getTime()) / 1e3);
        default:
            return a.getTime() - l.getTime()
    }
}

function nN(e, t) {
    const n = new Date(e);
    return n.setHours(t), n
}

function aN(e, t) {
    const n = new Date(e);
    return n.setMinutes(t), n
}

function lN(e, t) {
    const n = new Date(e);
    return n.setMonth(t), n
}

function rN(e, t) {
    const n = new Date(e);
    return n.setDate(t), n
}

function oN(e, t) {
    const n = new Date(e);
    return n.setFullYear(t), n
}

function Nd(e) {
    return new Date(e.getFullYear(), e.getMonth(), e.getDate(), 0, 0, 0, 0)
}

function iN(e) {
    return new Date(e.getFullYear(), e.getMonth(), e.getDate(), 23, 59, 59, 999)
}
class sN {
    constructor(t) {
        this.locale = t.locale, this.formats = t.formats
    }
    date(t) {
        return kS(t)
    }
    toJsDate(t) {
        return t
    }
    toISO(t) {
        return LM(this, t)
    }
    parseISO(t) {
        return OM(t)
    }
    addMinutes(t, n) {
        return RM(t, n)
    }
    addHours(t, n) {
        return DM(t, n)
    }
    addDays(t, n) {
        return MM(t, n)
    }
    addWeeks(t, n) {
        return NM(t, n)
    }
    addMonths(t, n) {
        return $M(t, n)
    }
    getWeekArray(t, n) {
        return xM(t, this.locale, n ? Number(n) : void 0)
    }
    startOfWeek(t, n) {
        return PM(t, this.locale, n ? Number(n) : void 0)
    }
    endOfWeek(t) {
        return EM(t, this.locale)
    }
    startOfMonth(t) {
        return SS(t)
    }
    endOfMonth(t) {
        return wS(t)
    }
    format(t, n) {
        return AM(t, n, this.locale, this.formats)
    }
    isEqual(t, n) {
        return Py(t, n)
    }
    isValid(t) {
        return qM(t)
    }
    isWithinRange(t, n) {
        return YM(t, n)
    }
    isAfter(t, n) {
        return Rs(t, n)
    }
    isAfterDay(t, n) {
        return XM(t, n)
    }
    isBefore(t, n) {
        return !Rs(t, n) && !Py(t, n)
    }
    isSameDay(t, n) {
        return ZM(t, n)
    }
    isSameMonth(t, n) {
        return QM(t, n)
    }
    isSameYear(t, n) {
        return eN(t, n)
    }
    setMinutes(t, n) {
        return aN(t, n)
    }
    setHours(t, n) {
        return nN(t, n)
    }
    setMonth(t, n) {
        return lN(t, n)
    }
    setDate(t, n) {
        return rN(t, n)
    }
    setYear(t, n) {
        return oN(t, n)
    }
    getDiff(t, n, a) {
        return tN(t, n, a)
    }
    getWeekdays(t) {
        return VM(this.locale, t ? Number(t) : void 0)
    }
    getYear(t) {
        return BM(t)
    }
    getMonth(t) {
        return FM(t)
    }
    getDate(t) {
        return HM(t)
    }
    getNextMonth(t) {
        return jM(t)
    }
    getPreviousMonth(t) {
        return UM(t)
    }
    getHours(t) {
        return WM(t)
    }
    getMinutes(t) {
        return zM(t)
    }
    startOfDay(t) {
        return Nd(t)
    }
    endOfDay(t) {
        return iN(t)
    }
    startOfYear(t) {
        return KM(t)
    }
    endOfYear(t) {
        return GM(t)
    }
}
const CS = Symbol.for("vuetify:date-options"),
    Ey = Symbol.for("vuetify:date-adapter");

function uN(e, t) {
    const n = Ht({
        adapter: sN,
        locale: {
            af: "af-ZA",
            bg: "bg-BG",
            ca: "ca-ES",
            ckb: "",
            cs: "cs-CZ",
            de: "de-DE",
            el: "el-GR",
            en: "en-US",
            et: "et-EE",
            fa: "fa-IR",
            fi: "fi-FI",
            hr: "hr-HR",
            hu: "hu-HU",
            he: "he-IL",
            id: "id-ID",
            it: "it-IT",
            ja: "ja-JP",
            ko: "ko-KR",
            lv: "lv-LV",
            lt: "lt-LT",
            nl: "nl-NL",
            no: "no-NO",
            pl: "pl-PL",
            pt: "pt-PT",
            ro: "ro-RO",
            ru: "ru-RU",
            sk: "sk-SK",
            sl: "sl-SI",
            srCyrl: "sr-SP",
            srLatn: "sr-SP",
            sv: "sv-SE",
            th: "th-TH",
            tr: "tr-TR",
            az: "az-AZ",
            uk: "uk-UA",
            vi: "vi-VN",
            zhHans: "zh-CN",
            zhHant: "zh-TW"
        }
    }, e);
    return {
        options: n,
        instance: xS(n, t)
    }
}

function xS(e, t) {
    const n = mt(typeof e.adapter == "function" ? new e.adapter({
        locale: e.locale[t.current.value] ? ? t.current.value,
        formats: e.formats
    }) : e.adapter);
    return de(t.current, a => {
        n.locale = e.locale[a] ? ? a ? ? n.locale
    }), n
}

function ia() {
    const e = Te(CS);
    if (!e) throw new Error("[Vuetify] Could not find injected date options");
    const t = Qe();
    return xS(e, t)
}

function cN(e, t) {
    const n = e.toJsDate(t);
    let a = n.getFullYear(),
        l = new Date(a, 0, 1);
    if (n < l) a = a - 1, l = new Date(a, 0, 1);
    else {
        const i = new Date(a + 1, 0, 1);
        n >= i && (a = a + 1, l = i)
    }
    const r = Math.abs(n.getTime() - l.getTime()),
        o = Math.ceil(r / (1e3 * 60 * 60 * 24));
    return Math.floor(o / 7) + 1
}
const Eu = ["sm", "md", "lg", "xl", "xxl"],
    $d = Symbol.for("vuetify:display"),
    Iy = {
        mobileBreakpoint: "lg",
        thresholds: {
            xs: 0,
            sm: 600,
            md: 960,
            lg: 1280,
            xl: 1920,
            xxl: 2560
        }
    },
    dN = function() {
        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Iy;
        return Ht(Iy, e)
    };

function Ty(e) {
    return Ue && !e ? window.innerWidth : typeof e == "object" && e.clientWidth || 0
}

function Vy(e) {
    return Ue && !e ? window.innerHeight : typeof e == "object" && e.clientHeight || 0
}

function Ay(e) {
    const t = Ue && !e ? window.navigator.userAgent : "ssr";

    function n(g) {
        return !!t.match(g)
    }
    const a = n(/android/i),
        l = n(/iphone|ipad|ipod/i),
        r = n(/cordova/i),
        o = n(/electron/i),
        i = n(/chrome/i),
        s = n(/edge/i),
        u = n(/firefox/i),
        c = n(/opera/i),
        d = n(/win/i),
        f = n(/mac/i),
        v = n(/linux/i);
    return {
        android: a,
        ios: l,
        cordova: r,
        electron: o,
        chrome: i,
        edge: s,
        firefox: u,
        opera: c,
        win: d,
        mac: f,
        linux: v,
        touch: ED,
        ssr: t === "ssr"
    }
}

function fN(e, t) {
    const {
        thresholds: n,
        mobileBreakpoint: a
    } = dN(e), l = fe(Vy(t)), r = fe(Ay(t)), o = mt({}), i = fe(Ty(t));

    function s() {
        l.value = Vy(), i.value = Ty()
    }

    function u() {
        s(), r.value = Ay()
    }
    return st(() => {
        const c = i.value < n.sm,
            d = i.value < n.md && !c,
            f = i.value < n.lg && !(d || c),
            v = i.value < n.xl && !(f || d || c),
            g = i.value < n.xxl && !(v || f || d || c),
            h = i.value >= n.xxl,
            y = c ? "xs" : d ? "sm" : f ? "md" : v ? "lg" : g ? "xl" : "xxl",
            S = typeof a == "number" ? a : n[a],
            b = i.value < S;
        o.xs = c, o.sm = d, o.md = f, o.lg = v, o.xl = g, o.xxl = h, o.smAndUp = !c, o.mdAndUp = !(c || d), o.lgAndUp = !(c || d || f), o.xlAndUp = !(c || d || f || v), o.smAndDown = !(f || v || g || h), o.mdAndDown = !(v || g || h), o.lgAndDown = !(g || h), o.xlAndDown = !h, o.name = y, o.height = l.value, o.width = i.value, o.mobile = b, o.mobileBreakpoint = a, o.platform = r.value, o.thresholds = n
    }), Ue && window.addEventListener("resize", s, {
        passive: !0
    }), { ...ta(o),
        update: u,
        ssr: !!t
    }
}
const Ul = W({
    mobile: {
        type: Boolean,
        default: !1
    },
    mobileBreakpoint: [Number, String]
}, "display");

function On() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
        t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ra();
    const n = Te($d);
    if (!n) throw new Error("Could not find Vuetify display injection");
    const a = C(() => {
            if (e.mobile != null) return e.mobile;
            if (!e.mobileBreakpoint) return n.mobile.value;
            const r = typeof e.mobileBreakpoint == "number" ? e.mobileBreakpoint : n.thresholds.value[e.mobileBreakpoint];
            return n.width.value < r
        }),
        l = C(() => t ? {
            [`${t}--mobile`]: a.value
        } : {});
    return { ...n,
        displayClasses: l,
        mobile: a
    }
}
const PS = Symbol.for("vuetify:goto");

function ES() {
    return {
        container: void 0,
        duration: 300,
        layout: !1,
        offset: 0,
        easing: "easeInOutCubic",
        patterns: {
            linear: e => e,
            easeInQuad: e => e ** 2,
            easeOutQuad: e => e * (2 - e),
            easeInOutQuad: e => e < .5 ? 2 * e ** 2 : -1 + (4 - 2 * e) * e,
            easeInCubic: e => e ** 3,
            easeOutCubic: e => --e ** 3 + 1,
            easeInOutCubic: e => e < .5 ? 4 * e ** 3 : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1,
            easeInQuart: e => e ** 4,
            easeOutQuart: e => 1 - --e ** 4,
            easeInOutQuart: e => e < .5 ? 8 * e ** 4 : 1 - 8 * --e ** 4,
            easeInQuint: e => e ** 5,
            easeOutQuint: e => 1 + --e ** 5,
            easeInOutQuint: e => e < .5 ? 16 * e ** 5 : 1 + 16 * --e ** 5
        }
    }
}

function vN(e) {
    return Bv(e) ? ? (document.scrollingElement || document.body)
}

function Bv(e) {
    return typeof e == "string" ? document.querySelector(e) : Tv(e)
}

function wc(e, t, n) {
    if (typeof e == "number") return t && n ? -e : e;
    let a = Bv(e),
        l = 0;
    for (; a;) l += t ? a.offsetLeft : a.offsetTop, a = a.offsetParent;
    return l
}

function mN(e, t) {
    return {
        rtl: t.isRtl,
        options: Ht(ES(), e)
    }
}
async function Ly(e, t, n, a) {
    const l = n ? "scrollLeft" : "scrollTop",
        r = Ht((a == null ? void 0 : a.options) ? ? ES(), t),
        o = a == null ? void 0 : a.rtl.value,
        i = (typeof e == "number" ? e : Bv(e)) ? ? 0,
        s = r.container === "parent" && i instanceof HTMLElement ? i.parentElement : vN(r.container),
        u = typeof r.easing == "function" ? r.easing : r.patterns[r.easing];
    if (!u) throw new TypeError(`Easing function "${r.easing}" not found.`);
    let c;
    if (typeof i == "number") c = wc(i, n, o);
    else if (c = wc(i, n, o) - wc(s, n, o), r.layout) {
        const g = window.getComputedStyle(i).getPropertyValue("--v-layout-top");
        g && (c -= parseInt(g, 10))
    }
    c += r.offset, c = gN(s, c, !!o, !!n);
    const d = s[l] ? ? 0;
    if (c === d) return Promise.resolve(c);
    const f = performance.now();
    return new Promise(v => requestAnimationFrame(function g(h) {
        const S = (h - f) / r.duration,
            b = Math.floor(d + (c - d) * u(ot(S, 0, 1)));
        if (s[l] = b, S >= 1 && Math.abs(b - s[l]) < 10) return v(c);
        if (S > 2) return v(s[l]);
        requestAnimationFrame(g)
    }))
}

function hN() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = Te(PS),
        {
            isRtl: n
        } = xt();
    if (!t) throw new Error("[Vuetify] Could not find injected goto instance");
    const a = { ...t,
        rtl: C(() => t.rtl.value || n.value)
    };
    async function l(r, o) {
        return Ly(r, Ht(e, o), !1, a)
    }
    return l.horizontal = async (r, o) => Ly(r, Ht(e, o), !0, a), l
}

function gN(e, t, n, a) {
    const {
        scrollWidth: l,
        scrollHeight: r
    } = e, [o, i] = e === document.scrollingElement ? [window.innerWidth, window.innerHeight] : [e.offsetWidth, e.offsetHeight];
    let s, u;
    return a ? n ? (s = -(l - o), u = 0) : (s = 0, u = l - o) : (s = 0, u = r + -i), Math.max(Math.min(t, u), s)
}
const yN = {
        collapse: "mdi-chevron-up",
        complete: "mdi-check",
        cancel: "mdi-close-circle",
        close: "mdi-close",
        delete: "mdi-close-circle",
        clear: "mdi-close-circle",
        success: "mdi-check-circle",
        info: "mdi-information",
        warning: "mdi-alert-circle",
        error: "mdi-close-circle",
        prev: "mdi-chevron-left",
        next: "mdi-chevron-right",
        checkboxOn: "mdi-checkbox-marked",
        checkboxOff: "mdi-checkbox-blank-outline",
        checkboxIndeterminate: "mdi-minus-box",
        delimiter: "mdi-circle",
        sortAsc: "mdi-arrow-up",
        sortDesc: "mdi-arrow-down",
        expand: "mdi-chevron-down",
        menu: "mdi-menu",
        subgroup: "mdi-menu-down",
        dropdown: "mdi-menu-down",
        radioOn: "mdi-radiobox-marked",
        radioOff: "mdi-radiobox-blank",
        edit: "mdi-pencil",
        ratingEmpty: "mdi-star-outline",
        ratingFull: "mdi-star",
        ratingHalf: "mdi-star-half-full",
        loading: "mdi-cached",
        first: "mdi-page-first",
        last: "mdi-page-last",
        unfold: "mdi-unfold-more-horizontal",
        file: "mdi-paperclip",
        plus: "mdi-plus",
        minus: "mdi-minus",
        calendar: "mdi-calendar",
        treeviewCollapse: "mdi-menu-down",
        treeviewExpand: "mdi-menu-right",
        eyeDropper: "mdi-eyedropper"
    },
    bN = {
        component: e => ht(Hv, { ...e,
            class: "mdi"
        })
    },
    Pe = [String, Function, Object, Array],
    Bd = Symbol.for("vuetify:icons"),
    Iu = W({
        icon: {
            type: Pe
        },
        tag: {
            type: String,
            required: !0
        }
    }, "icon"),
    Fd = Z()({
        name: "VComponentIcon",
        props: Iu(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            return () => {
                const a = e.icon;
                return m(e.tag, null, {
                    default: () => {
                        var l;
                        return [e.icon ? m(a, null, null) : (l = n.default) == null ? void 0 : l.call(n)]
                    }
                })
            }
        }
    }),
    Fv = pn({
        name: "VSvgIcon",
        inheritAttrs: !1,
        props: Iu(),
        setup(e, t) {
            let {
                attrs: n
            } = t;
            return () => m(e.tag, te(n, {
                style: null
            }), {
                default: () => [m("svg", {
                    class: "v-icon__svg",
                    xmlns: "http://www.w3.org/2000/svg",
                    viewBox: "0 0 24 24",
                    role: "img",
                    "aria-hidden": "true"
                }, [Array.isArray(e.icon) ? e.icon.map(a => Array.isArray(a) ? m("path", {
                    d: a[0],
                    "fill-opacity": a[1]
                }, null) : m("path", {
                    d: a
                }, null)) : m("path", {
                    d: e.icon
                }, null)])]
            })
        }
    }),
    pN = pn({
        name: "VLigatureIcon",
        props: Iu(),
        setup(e) {
            return () => m(e.tag, null, {
                default: () => [e.icon]
            })
        }
    }),
    Hv = pn({
        name: "VClassIcon",
        props: Iu(),
        setup(e) {
            return () => m(e.tag, {
                class: e.icon
            }, null)
        }
    });

function _N() {
    return {
        svg: {
            component: Fv
        },
        class: {
            component: Hv
        }
    }
}

function SN(e) {
    const t = _N(),
        n = (e == null ? void 0 : e.defaultSet) ? ? "mdi";
    return n === "mdi" && !t.mdi && (t.mdi = bN), Ht({
        defaultSet: n,
        sets: t,
        aliases: { ...yN,
            vuetify: ["M8.2241 14.2009L12 21L22 3H14.4459L8.2241 14.2009Z", ["M7.26303 12.4733L7.00113 12L2 3H12.5261C12.5261 3 12.5261 3 12.5261 3L7.26303 12.4733Z", .6]],
            "vuetify-outline": "svg:M7.26 12.47 12.53 3H2L7.26 12.47ZM14.45 3 8.22 14.2 12 21 22 3H14.45ZM18.6 5 12 16.88 10.51 14.2 15.62 5ZM7.26 8.35 5.4 5H9.13L7.26 8.35Z",
            "vuetify-play": ["m6.376 13.184-4.11-7.192C1.505 4.66 2.467 3 4.003 3h8.532l-.953 1.576-.006.01-.396.677c-.429.732-.214 1.507.194 2.015.404.503 1.092.878 1.869.806a3.72 3.72 0 0 1 1.005.022c.276.053.434.143.523.237.138.146.38.635-.25 2.09-.893 1.63-1.553 1.722-1.847 1.677-.213-.033-.468-.158-.756-.406a4.95 4.95 0 0 1-.8-.927c-.39-.564-1.04-.84-1.66-.846-.625-.006-1.316.27-1.693.921l-.478.826-.911 1.506Z", ["M9.093 11.552c.046-.079.144-.15.32-.148a.53.53 0 0 1 .43.207c.285.414.636.847 1.046 1.2.405.35.914.662 1.516.754 1.334.205 2.502-.698 3.48-2.495l.014-.028.013-.03c.687-1.574.774-2.852-.005-3.675-.37-.391-.861-.586-1.333-.676a5.243 5.243 0 0 0-1.447-.044c-.173.016-.393-.073-.54-.257-.145-.18-.127-.316-.082-.392l.393-.672L14.287 3h5.71c1.536 0 2.499 1.659 1.737 2.992l-7.997 13.996c-.768 1.344-2.706 1.344-3.473 0l-3.037-5.314 1.377-2.278.004-.006.004-.007.481-.831Z", .6]]
        }
    }, e)
}
const wN = e => {
        const t = Te(Bd);
        if (!t) throw new Error("Missing Vuetify Icons provide!");
        return {
            iconData: C(() => {
                var s;
                const a = Ie(e);
                if (!a) return {
                    component: Fd
                };
                let l = a;
                if (typeof l == "string" && (l = l.trim(), l.startsWith("$") && (l = (s = t.aliases) == null ? void 0 : s[l.slice(1)])), Array.isArray(l)) return {
                    component: Fv,
                    icon: l
                };
                if (typeof l != "string") return {
                    component: Fd,
                    icon: l
                };
                const r = Object.keys(t.sets).find(u => typeof l == "string" && l.startsWith(`${u}:`)),
                    o = r ? l.slice(r.length + 1) : l;
                return {
                    component: t.sets[r ? ? t.defaultSet].component,
                    icon: o
                }
            })
        }
    },
    Fo = Symbol.for("vuetify:theme"),
    Ne = W({
        theme: String
    }, "theme");

function Oy() {
    return {
        defaultTheme: "light",
        variations: {
            colors: [],
            lighten: 0,
            darken: 0
        },
        themes: {
            light: {
                dark: !1,
                colors: {
                    background: "#FFFFFF",
                    surface: "#FFFFFF",
                    "surface-bright": "#FFFFFF",
                    "surface-light": "#EEEEEE",
                    "surface-variant": "#424242",
                    "on-surface-variant": "#EEEEEE",
                    primary: "#1867C0",
                    "primary-darken-1": "#1F5592",
                    secondary: "#48A9A6",
                    "secondary-darken-1": "#018786",
                    error: "#B00020",
                    info: "#2196F3",
                    success: "#4CAF50",
                    warning: "#FB8C00"
                },
                variables: {
                    "border-color": "#000000",
                    "border-opacity": .12,
                    "high-emphasis-opacity": .87,
                    "medium-emphasis-opacity": .6,
                    "disabled-opacity": .38,
                    "idle-opacity": .04,
                    "hover-opacity": .04,
                    "focus-opacity": .12,
                    "selected-opacity": .08,
                    "activated-opacity": .12,
                    "pressed-opacity": .12,
                    "dragged-opacity": .08,
                    "theme-kbd": "#212529",
                    "theme-on-kbd": "#FFFFFF",
                    "theme-code": "#F5F5F5",
                    "theme-on-code": "#000000"
                }
            },
            dark: {
                dark: !0,
                colors: {
                    background: "#121212",
                    surface: "#212121",
                    "surface-bright": "#ccbfd6",
                    "surface-light": "#424242",
                    "surface-variant": "#a3a3a3",
                    "on-surface-variant": "#424242",
                    primary: "#2196F3",
                    "primary-darken-1": "#277CC1",
                    secondary: "#54B6B2",
                    "secondary-darken-1": "#48A9A6",
                    error: "#CF6679",
                    info: "#2196F3",
                    success: "#4CAF50",
                    warning: "#FB8C00"
                },
                variables: {
                    "border-color": "#FFFFFF",
                    "border-opacity": .12,
                    "high-emphasis-opacity": 1,
                    "medium-emphasis-opacity": .7,
                    "disabled-opacity": .5,
                    "idle-opacity": .1,
                    "hover-opacity": .04,
                    "focus-opacity": .12,
                    "selected-opacity": .08,
                    "activated-opacity": .12,
                    "pressed-opacity": .16,
                    "dragged-opacity": .08,
                    "theme-kbd": "#212529",
                    "theme-on-kbd": "#FFFFFF",
                    "theme-code": "#343434",
                    "theme-on-code": "#CCCCCC"
                }
            }
        }
    }
}

function kN() {
    var a, l;
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Oy();
    const t = Oy();
    if (!e) return { ...t,
        isDisabled: !0
    };
    const n = {};
    for (const [r, o] of Object.entries(e.themes ? ? {})) {
        const i = o.dark || r === "dark" ? (a = t.themes) == null ? void 0 : a.dark : (l = t.themes) == null ? void 0 : l.light;
        n[r] = Ht(i, o)
    }
    return Ht(t, { ...e,
        themes: n
    })
}

function CN(e) {
    const t = kN(e),
        n = Q(t.defaultTheme),
        a = Q(t.themes),
        l = C(() => {
            const c = {};
            for (const [d, f] of Object.entries(a.value)) {
                const v = c[d] = { ...f,
                    colors: { ...f.colors
                    }
                };
                if (t.variations)
                    for (const g of t.variations.colors) {
                        const h = v.colors[g];
                        if (h)
                            for (const y of ["lighten", "darken"]) {
                                const S = y === "lighten" ? oM : iM;
                                for (const b of fn(t.variations[y], 1)) v.colors[`${g}-${y}-${b}`] = cS(S(En(h), b))
                            }
                    }
                for (const g of Object.keys(v.colors)) {
                    if (/^on-[a-z]/.test(g) || v.colors[`on-${g}`]) continue;
                    const h = `on-${g}`,
                        y = En(v.colors[g]);
                    v.colors[h] = mS(y)
                }
            }
            return c
        }),
        r = C(() => l.value[n.value]),
        o = C(() => {
            var g;
            const c = [];
            (g = r.value) != null && g.dark && fl(c, ":root", ["color-scheme: dark"]), fl(c, ":root", Ry(r.value));
            for (const [h, y] of Object.entries(l.value)) fl(c, `.v-theme--${h}`, [`color-scheme: ${y.dark?"dark":"normal"}`, ...Ry(y)]);
            const d = [],
                f = [],
                v = new Set(Object.values(l.value).flatMap(h => Object.keys(h.colors)));
            for (const h of v) /^on-[a-z]/.test(h) ? fl(f, `.${h}`, [`color: rgb(var(--v-theme-${h})) !important`]) : (fl(d, `.bg-${h}`, [`--v-theme-overlay-multiplier: var(--v-theme-${h}-overlay-multiplier)`, `background-color: rgb(var(--v-theme-${h})) !important`, `color: rgb(var(--v-theme-on-${h})) !important`]), fl(f, `.text-${h}`, [`color: rgb(var(--v-theme-${h})) !important`]), fl(f, `.border-${h}`, [`--v-border-color: var(--v-theme-${h})`]));
            return c.push(...d, ...f), c.map((h, y) => y === 0 ? h : `    ${h}`).join("")
        });

    function i() {
        return {
            style: [{
                children: o.value,
                id: "vuetify-theme-stylesheet",
                nonce: t.cspNonce || !1
            }]
        }
    }

    function s(c) {
        if (t.isDisabled) return;
        const d = c._context.provides.usehead;
        if (d)
            if (d.push) {
                const f = d.push(i);
                Ue && de(o, () => {
                    f.patch(i)
                })
            } else Ue ? (d.addHeadObjs(C(i)), st(() => d.updateDOM())) : d.addHeadObjs(i());
        else {
            let v = function() {
                    if (typeof document < "u" && !f) {
                        const g = document.createElement("style");
                        g.type = "text/css", g.id = "vuetify-theme-stylesheet", t.cspNonce && g.setAttribute("nonce", t.cspNonce), f = g, document.head.appendChild(f)
                    }
                    f && (f.innerHTML = o.value)
                },
                f = Ue ? document.getElementById("vuetify-theme-stylesheet") : null;
            Ue ? de(o, v, {
                immediate: !0
            }) : v()
        }
    }
    const u = C(() => t.isDisabled ? void 0 : `v-theme--${n.value}`);
    return {
        install: s,
        isDisabled: t.isDisabled,
        name: n,
        themes: a,
        current: r,
        computedThemes: l,
        themeClasses: u,
        styles: o,
        global: {
            name: n,
            current: r
        }
    }
}

function je(e) {
    ut("provideTheme");
    const t = Te(Fo, null);
    if (!t) throw new Error("Could not find Vuetify theme injection");
    const n = C(() => e.theme ? ? t.name.value),
        a = C(() => t.themes.value[n.value]),
        l = C(() => t.isDisabled ? void 0 : `v-theme--${n.value}`),
        r = { ...t,
            name: n,
            current: a,
            themeClasses: l
        };
    return He(Fo, r), r
}

function IS() {
    ut("useTheme");
    const e = Te(Fo, null);
    if (!e) throw new Error("Could not find Vuetify theme injection");
    return e
}

function fl(e, t, n) {
    e.push(`${t} {
`, ...n.map(a => `  ${a};
`), `}
`)
}

function Ry(e) {
    const t = e.dark ? 2 : 1,
        n = e.dark ? 1 : 2,
        a = [];
    for (const [l, r] of Object.entries(e.colors)) {
        const o = En(r);
        a.push(`--v-theme-${l}: ${o.r},${o.g},${o.b}`), l.startsWith("on-") || a.push(`--v-theme-${l}-overlay-multiplier: ${Md(r)>.18?t:n}`)
    }
    for (const [l, r] of Object.entries(e.variables)) {
        const o = typeof r == "string" && r.startsWith("#") ? En(r) : void 0,
            i = o ? `${o.r}, ${o.g}, ${o.b}` : void 0;
        a.push(`--v-${l}: ${i??r}`)
    }
    return a
}

function Hn(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "content";
    const n = As(),
        a = Q();
    if (Ue) {
        const l = new ResizeObserver(r => {
            e == null || e(r, l), r.length && (t === "content" ? a.value = r[0].contentRect : a.value = r[0].target.getBoundingClientRect())
        });
        Ct(() => {
            l.disconnect()
        }), de(() => n.el, (r, o) => {
            o && (l.unobserve(o), a.value = void 0), r && l.observe(r)
        }, {
            flush: "post"
        })
    }
    return {
        resizeRef: n,
        contentRect: Br(a)
    }
}
const Ho = Symbol.for("vuetify:layout"),
    TS = Symbol.for("vuetify:layout-item"),
    Dy = 1e3,
    VS = W({
        overlaps: {
            type: Array,
            default: () => []
        },
        fullHeight: Boolean
    }, "layout"),
    Wl = W({
        name: {
            type: String
        },
        order: {
            type: [Number, String],
            default: 0
        },
        absolute: Boolean
    }, "layout-item");

function AS() {
    const e = Te(Ho);
    if (!e) throw new Error("[Vuetify] Could not find injected layout");
    return {
        getLayoutItem: e.getLayoutItem,
        mainRect: e.mainRect,
        mainStyles: e.mainStyles
    }
}

function zl(e) {
    const t = Te(Ho);
    if (!t) throw new Error("[Vuetify] Could not find injected layout");
    const n = e.id ? ? `layout-item-${Rt()}`,
        a = ut("useLayoutItem");
    He(TS, {
        id: n
    });
    const l = fe(!1);
    Qs(() => l.value = !0), Kf(() => l.value = !1);
    const {
        layoutItemStyles: r,
        layoutItemScrimStyles: o
    } = t.register(a, { ...e,
        active: C(() => l.value ? !1 : e.active.value),
        id: n
    });
    return Ct(() => t.unregister(n)), {
        layoutItemStyles: r,
        layoutRect: t.layoutRect,
        layoutItemScrimStyles: o
    }
}
const xN = (e, t, n, a) => {
    let l = {
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
    };
    const r = [{
        id: "",
        layer: { ...l
        }
    }];
    for (const o of e) {
        const i = t.get(o),
            s = n.get(o),
            u = a.get(o);
        if (!i || !s || !u) continue;
        const c = { ...l,
            [i.value]: parseInt(l[i.value], 10) + (u.value ? parseInt(s.value, 10) : 0)
        };
        r.push({
            id: o,
            layer: c
        }), l = c
    }
    return r
};

function LS(e) {
    const t = Te(Ho, null),
        n = C(() => t ? t.rootZIndex.value - 100 : Dy),
        a = Q([]),
        l = mt(new Map),
        r = mt(new Map),
        o = mt(new Map),
        i = mt(new Map),
        s = mt(new Map),
        {
            resizeRef: u,
            contentRect: c
        } = Hn(),
        d = C(() => {
            const k = new Map,
                E = e.overlaps ? ? [];
            for (const P of E.filter(x => x.includes(":"))) {
                const [x, T] = P.split(":");
                if (!a.value.includes(x) || !a.value.includes(T)) continue;
                const V = l.get(x),
                    I = l.get(T),
                    R = r.get(x),
                    B = r.get(T);
                !V || !I || !R || !B || (k.set(T, {
                    position: V.value,
                    amount: parseInt(R.value, 10)
                }), k.set(x, {
                    position: I.value,
                    amount: -parseInt(B.value, 10)
                }))
            }
            return k
        }),
        f = C(() => {
            const k = [...new Set([...o.values()].map(P => P.value))].sort((P, x) => P - x),
                E = [];
            for (const P of k) {
                const x = a.value.filter(T => {
                    var V;
                    return ((V = o.get(T)) == null ? void 0 : V.value) === P
                });
                E.push(...x)
            }
            return xN(E, l, r, i)
        }),
        v = C(() => !Array.from(s.values()).some(k => k.value)),
        g = C(() => f.value[f.value.length - 1].layer),
        h = C(() => ({
            "--v-layout-left": ge(g.value.left),
            "--v-layout-right": ge(g.value.right),
            "--v-layout-top": ge(g.value.top),
            "--v-layout-bottom": ge(g.value.bottom),
            ...v.value ? void 0 : {
                transition: "none"
            }
        })),
        y = C(() => f.value.slice(1).map((k, E) => {
            let {
                id: P
            } = k;
            const {
                layer: x
            } = f.value[E], T = r.get(P), V = l.get(P);
            return {
                id: P,
                ...x,
                size: Number(T.value),
                position: V.value
            }
        })),
        S = k => y.value.find(E => E.id === k),
        b = ut("createLayout"),
        p = fe(!1);
    it(() => {
        p.value = !0
    }), He(Ho, {
        register: (k, E) => {
            let {
                id: P,
                order: x,
                position: T,
                layoutSize: V,
                elementSize: I,
                active: R,
                disableTransitions: B,
                absolute: $
            } = E;
            o.set(P, x), l.set(P, T), r.set(P, V), i.set(P, R), B && s.set(P, B);
            const z = fr(TS, b == null ? void 0 : b.vnode).indexOf(k);
            z > -1 ? a.value.splice(z, 0, P) : a.value.push(P);
            const N = C(() => y.value.findIndex(ae => ae.id === P)),
                H = C(() => n.value + f.value.length * 2 - N.value * 2),
                F = C(() => {
                    const ae = T.value === "left" || T.value === "right",
                        he = T.value === "right",
                        ve = T.value === "bottom",
                        we = I.value ? ? V.value,
                        ee = we === 0 ? "%" : "px",
                        G = {
                            [T.value]: 0,
                            zIndex: H.value,
                            transform: `translate${ae?"X":"Y"}(${(R.value?0:-(we===0?100:we))*(he||ve?-1:1)}${ee})`,
                            position: $.value || n.value !== Dy ? "absolute" : "fixed",
                            ...v.value ? void 0 : {
                                transition: "none"
                            }
                        };
                    if (!p.value) return G;
                    const le = y.value[N.value];
                    if (!le) throw new Error(`[Vuetify] Could not find layout item "${P}"`);
                    const se = d.value.get(P);
                    return se && (le[se.position] += se.amount), { ...G,
                        height: ae ? `calc(100% - ${le.top}px - ${le.bottom}px)` : I.value ? `${I.value}px` : void 0,
                        left: he ? void 0 : `${le.left}px`,
                        right: he ? `${le.right}px` : void 0,
                        top: T.value !== "bottom" ? `${le.top}px` : void 0,
                        bottom: T.value !== "top" ? `${le.bottom}px` : void 0,
                        width: ae ? I.value ? `${I.value}px` : void 0 : `calc(100% - ${le.left}px - ${le.right}px)`
                    }
                }),
                j = C(() => ({
                    zIndex: H.value - 1
                }));
            return {
                layoutItemStyles: F,
                layoutItemScrimStyles: j,
                zIndex: H
            }
        },
        unregister: k => {
            o.delete(k), l.delete(k), r.delete(k), i.delete(k), s.delete(k), a.value = a.value.filter(E => E !== k)
        },
        mainRect: g,
        mainStyles: h,
        getLayoutItem: S,
        items: y,
        layoutRect: c,
        rootZIndex: n
    });
    const _ = C(() => ["v-layout", {
            "v-layout--full-height": e.fullHeight
        }]),
        w = C(() => ({
            zIndex: t ? n.value : void 0,
            position: t ? "relative" : void 0,
            overflow: t ? "hidden" : void 0
        }));
    return {
        layoutClasses: _,
        layoutStyles: w,
        getLayoutItem: S,
        items: y,
        layoutRect: c,
        layoutRef: u
    }
}

function OS() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
        blueprint: t,
        ...n
    } = e, a = Ht(t, n), {
        aliases: l = {},
        components: r = {},
        directives: o = {}
    } = a, i = cM(a.defaults), s = fN(a.display, a.ssr), u = CN(a.theme), c = SN(a.icons), d = _M(a.locale), f = uN(a.date, d), v = mN(a.goTo, d);
    return {
        install: h => {
            for (const y in o) h.directive(y, o[y]);
            for (const y in r) h.component(y, r[y]);
            for (const y in l) h.component(y, pn({ ...l[y],
                name: y,
                aliasName: l[y].name
            }));
            if (u.install(h), h.provide(Rr, i), h.provide($d, s), h.provide(Fo, u), h.provide(Bd, c), h.provide(Dr, d), h.provide(CS, f.options), h.provide(Ey, f.instance), h.provide(PS, v), Ue && a.ssr)
                if (h.$nuxt) h.$nuxt.hook("app:suspense:resolve", () => {
                    s.update()
                });
                else {
                    const {
                        mount: y
                    } = h;
                    h.mount = function() {
                        const S = y(...arguments);
                        return Re(() => s.update()), h.mount = y, S
                    }
                }
            Rt.reset(), h.mixin({
                computed: {
                    $vuetify() {
                        return mt({
                            defaults: rr.call(this, Rr),
                            display: rr.call(this, $d),
                            theme: rr.call(this, Fo),
                            icons: rr.call(this, Bd),
                            locale: rr.call(this, Dr),
                            date: rr.call(this, Ey)
                        })
                    }
                }
            })
        },
        defaults: i,
        display: s,
        theme: u,
        icons: c,
        locale: d,
        date: f,
        goTo: v
    }
}
const PN = "3.7.1";
OS.version = PN;

function rr(e) {
    var a, l;
    const t = this.$,
        n = ((a = t.parent) == null ? void 0 : a.provides) ? ? ((l = t.vnode.appContext) == null ? void 0 : l.provides);
    if (n && e in n) return n[e]
}
const EN = W({ ...Se(),
        ...VS({
            fullHeight: !0
        }),
        ...Ne()
    }, "VApp"),
    IN = Z()({
        name: "VApp",
        props: EN(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = je(e),
                {
                    layoutClasses: l,
                    getLayoutItem: r,
                    items: o,
                    layoutRef: i
                } = LS(e),
                {
                    rtlClasses: s
                } = xt();
            return ne(() => {
                var u;
                return m("div", {
                    ref: i,
                    class: ["v-application", a.themeClasses.value, l.value, s.value, e.class],
                    style: [e.style]
                }, [m("div", {
                    class: "v-application__wrap"
                }, [(u = n.default) == null ? void 0 : u.call(n)])])
            }), {
                getLayoutItem: r,
                items: o,
                theme: a
            }
        }
    }),
    Ae = W({
        tag: {
            type: String,
            default: "div"
        }
    }, "tag"),
    RS = W({
        text: String,
        ...Se(),
        ...Ae()
    }, "VToolbarTitle"),
    jv = Z()({
        name: "VToolbarTitle",
        props: RS(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            return ne(() => {
                const a = !!(n.default || n.text || e.text);
                return m(e.tag, {
                    class: ["v-toolbar-title", e.class],
                    style: e.style
                }, {
                    default: () => {
                        var l;
                        return [a && m("div", {
                            class: "v-toolbar-title__placeholder"
                        }, [n.text ? n.text() : e.text, (l = n.default) == null ? void 0 : l.call(n)])]
                    }
                })
            }), {}
        }
    }),
    TN = W({
        disabled: Boolean,
        group: Boolean,
        hideOnLeave: Boolean,
        leaveAbsolute: Boolean,
        mode: String,
        origin: String
    }, "transition");

function _n(e, t, n) {
    return Z()({
        name: e,
        props: TN({
            mode: n,
            origin: t
        }),
        setup(a, l) {
            let {
                slots: r
            } = l;
            const o = {
                onBeforeEnter(i) {
                    a.origin && (i.style.transformOrigin = a.origin)
                },
                onLeave(i) {
                    if (a.leaveAbsolute) {
                        const {
                            offsetTop: s,
                            offsetLeft: u,
                            offsetWidth: c,
                            offsetHeight: d
                        } = i;
                        i._transitionInitialStyles = {
                            position: i.style.position,
                            top: i.style.top,
                            left: i.style.left,
                            width: i.style.width,
                            height: i.style.height
                        }, i.style.position = "absolute", i.style.top = `${s}px`, i.style.left = `${u}px`, i.style.width = `${c}px`, i.style.height = `${d}px`
                    }
                    a.hideOnLeave && i.style.setProperty("display", "none", "important")
                },
                onAfterLeave(i) {
                    if (a.leaveAbsolute && (i != null && i._transitionInitialStyles)) {
                        const {
                            position: s,
                            top: u,
                            left: c,
                            width: d,
                            height: f
                        } = i._transitionInitialStyles;
                        delete i._transitionInitialStyles, i.style.position = s || "", i.style.top = u || "", i.style.left = c || "", i.style.width = d || "", i.style.height = f || ""
                    }
                }
            };
            return () => {
                const i = a.group ? iu : Tn;
                return ht(i, {
                    name: a.disabled ? "" : e,
                    css: !a.disabled,
                    ...a.group ? void 0 : {
                        mode: a.mode
                    },
                    ...a.disabled ? {} : o
                }, r.default)
            }
        }
    })
}

function DS(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "in-out";
    return Z()({
        name: e,
        props: {
            mode: {
                type: String,
                default: n
            },
            disabled: Boolean,
            group: Boolean
        },
        setup(a, l) {
            let {
                slots: r
            } = l;
            const o = a.group ? iu : Tn;
            return () => ht(o, {
                name: a.disabled ? "" : e,
                css: !a.disabled,
                ...a.disabled ? {} : t
            }, r.default)
        }
    })
}

function MS() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    const n = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1) ? "width" : "height",
        a = Qt(`offset-${n}`);
    return {
        onBeforeEnter(o) {
            o._parent = o.parentNode, o._initialStyle = {
                transition: o.style.transition,
                overflow: o.style.overflow,
                [n]: o.style[n]
            }
        },
        onEnter(o) {
            const i = o._initialStyle;
            o.style.setProperty("transition", "none", "important"), o.style.overflow = "hidden";
            const s = `${o[a]}px`;
            o.style[n] = "0", o.offsetHeight, o.style.transition = i.transition, e && o._parent && o._parent.classList.add(e), requestAnimationFrame(() => {
                o.style[n] = s
            })
        },
        onAfterEnter: r,
        onEnterCancelled: r,
        onLeave(o) {
            o._initialStyle = {
                transition: "",
                overflow: o.style.overflow,
                [n]: o.style[n]
            }, o.style.overflow = "hidden", o.style[n] = `${o[a]}px`, o.offsetHeight, requestAnimationFrame(() => o.style[n] = "0")
        },
        onAfterLeave: l,
        onLeaveCancelled: l
    };

    function l(o) {
        e && o._parent && o._parent.classList.remove(e), r(o)
    }

    function r(o) {
        const i = o._initialStyle[n];
        o.style.overflow = o._initialStyle.overflow, i != null && (o.style[n] = i), delete o._initialStyle
    }
}
const VN = W({
        target: [Object, Array]
    }, "v-dialog-transition"),
    Tu = Z()({
        name: "VDialogTransition",
        props: VN(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = {
                onBeforeEnter(l) {
                    l.style.pointerEvents = "none", l.style.visibility = "hidden"
                },
                async onEnter(l, r) {
                    var f;
                    await new Promise(v => requestAnimationFrame(v)), await new Promise(v => requestAnimationFrame(v)), l.style.visibility = "";
                    const {
                        x: o,
                        y: i,
                        sx: s,
                        sy: u,
                        speed: c
                    } = Ny(e.target, l), d = yl(l, [{
                        transform: `translate(${o}px, ${i}px) scale(${s}, ${u})`,
                        opacity: 0
                    }, {}], {
                        duration: 225 * c,
                        easing: mM
                    });
                    (f = My(l)) == null || f.forEach(v => {
                        yl(v, [{
                            opacity: 0
                        }, {
                            opacity: 0,
                            offset: .33
                        }, {}], {
                            duration: 225 * 2 * c,
                            easing: $o
                        })
                    }), d.finished.then(() => r())
                },
                onAfterEnter(l) {
                    l.style.removeProperty("pointer-events")
                },
                onBeforeLeave(l) {
                    l.style.pointerEvents = "none"
                },
                async onLeave(l, r) {
                    var f;
                    await new Promise(v => requestAnimationFrame(v));
                    const {
                        x: o,
                        y: i,
                        sx: s,
                        sy: u,
                        speed: c
                    } = Ny(e.target, l);
                    yl(l, [{}, {
                        transform: `translate(${o}px, ${i}px) scale(${s}, ${u})`,
                        opacity: 0
                    }], {
                        duration: 125 * c,
                        easing: hM
                    }).finished.then(() => r()), (f = My(l)) == null || f.forEach(v => {
                        yl(v, [{}, {
                            opacity: 0,
                            offset: .2
                        }, {
                            opacity: 0
                        }], {
                            duration: 125 * 2 * c,
                            easing: $o
                        })
                    })
                },
                onAfterLeave(l) {
                    l.style.removeProperty("pointer-events")
                }
            };
            return () => e.target ? m(Tn, te({
                name: "dialog-transition"
            }, a, {
                css: !1
            }), n) : m(Tn, {
                name: "dialog-transition"
            }, n)
        }
    });

function My(e) {
    var n;
    const t = (n = e.querySelector(":scope > .v-card, :scope > .v-sheet, :scope > .v-list")) == null ? void 0 : n.children;
    return t && [...t]
}

function Ny(e, t) {
    const n = aS(e),
        a = Ov(t),
        [l, r] = getComputedStyle(t).transformOrigin.split(" ").map(S => parseFloat(S)),
        [o, i] = getComputedStyle(t).getPropertyValue("--v-overlay-anchor-origin").split(" ");
    let s = n.left + n.width / 2;
    o === "left" || i === "left" ? s -= n.width / 2 : (o === "right" || i === "right") && (s += n.width / 2);
    let u = n.top + n.height / 2;
    o === "top" || i === "top" ? u -= n.height / 2 : (o === "bottom" || i === "bottom") && (u += n.height / 2);
    const c = n.width / a.width,
        d = n.height / a.height,
        f = Math.max(1, c, d),
        v = c / f || 0,
        g = d / f || 0,
        h = a.width * a.height / (window.innerWidth * window.innerHeight),
        y = h > .12 ? Math.min(1.5, (h - .12) * 10 + 1) : 1;
    return {
        x: s - (l + a.left),
        y: u - (r + a.top),
        sx: v,
        sy: g,
        speed: y
    }
}
const AN = _n("fab-transition", "center center", "out-in"),
    LN = _n("dialog-bottom-transition"),
    ON = _n("dialog-top-transition"),
    jo = _n("fade-transition"),
    Uv = _n("scale-transition"),
    RN = _n("scroll-x-transition"),
    DN = _n("scroll-x-reverse-transition"),
    MN = _n("scroll-y-transition"),
    NN = _n("scroll-y-reverse-transition"),
    $N = _n("slide-x-transition"),
    BN = _n("slide-x-reverse-transition"),
    Wv = _n("slide-y-transition"),
    FN = _n("slide-y-reverse-transition"),
    Vu = DS("expand-transition", MS()),
    zv = DS("expand-x-transition", MS("", !0)),
    HN = W({
        defaults: Object,
        disabled: Boolean,
        reset: [Number, String],
        root: [Boolean, String],
        scoped: Boolean
    }, "VDefaultsProvider"),
    Ve = Z(!1)({
        name: "VDefaultsProvider",
        props: HN(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                defaults: a,
                disabled: l,
                reset: r,
                root: o,
                scoped: i
            } = ta(e);
            return lt(a, {
                reset: r,
                root: o,
                scoped: i,
                disabled: l
            }), () => {
                var s;
                return (s = n.default) == null ? void 0 : s.call(n)
            }
        }
    }),
    bt = W({
        height: [Number, String],
        maxHeight: [Number, String],
        maxWidth: [Number, String],
        minHeight: [Number, String],
        minWidth: [Number, String],
        width: [Number, String]
    }, "dimension");

function pt(e) {
    return {
        dimensionStyles: C(() => {
            const n = {},
                a = ge(e.height),
                l = ge(e.maxHeight),
                r = ge(e.maxWidth),
                o = ge(e.minHeight),
                i = ge(e.minWidth),
                s = ge(e.width);
            return a != null && (n.height = a), l != null && (n.maxHeight = l), r != null && (n.maxWidth = r), o != null && (n.minHeight = o), i != null && (n.minWidth = i), s != null && (n.width = s), n
        })
    }
}

function jN(e) {
    return {
        aspectStyles: C(() => {
            const t = Number(e.aspectRatio);
            return t ? {
                paddingBottom: String(1 / t * 100) + "%"
            } : void 0
        })
    }
}
const NS = W({
        aspectRatio: [String, Number],
        contentClass: null,
        inline: Boolean,
        ...Se(),
        ...bt()
    }, "VResponsive"),
    Hd = Z()({
        name: "VResponsive",
        props: NS(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                aspectStyles: a
            } = jN(e), {
                dimensionStyles: l
            } = pt(e);
            return ne(() => {
                var r;
                return m("div", {
                    class: ["v-responsive", {
                        "v-responsive--inline": e.inline
                    }, e.class],
                    style: [l.value, e.style]
                }, [m("div", {
                    class: "v-responsive__sizer",
                    style: a.value
                }, null), (r = n.additional) == null ? void 0 : r.call(n), n.default && m("div", {
                    class: ["v-responsive__content", e.contentClass]
                }, [n.default()])])
            }), {}
        }
    });

function Kv(e) {
    return Av(() => {
        const t = [],
            n = {};
        if (e.value.background)
            if (Dd(e.value.background)) {
                if (n.backgroundColor = e.value.background, !e.value.text && aM(e.value.background)) {
                    const a = En(e.value.background);
                    if (a.a == null || a.a === 1) {
                        const l = mS(a);
                        n.color = l, n.caretColor = l
                    }
                }
            } else t.push(`bg-${e.value.background}`);
        return e.value.text && (Dd(e.value.text) ? (n.color = e.value.text, n.caretColor = e.value.text) : t.push(`text-${e.value.text}`)), {
            colorClasses: t,
            colorStyles: n
        }
    })
}

function Ot(e, t) {
    const n = C(() => ({
            text: Ge(e) ? e.value : t ? e[t] : null
        })),
        {
            colorClasses: a,
            colorStyles: l
        } = Kv(n);
    return {
        textColorClasses: a,
        textColorStyles: l
    }
}

function Ke(e, t) {
    const n = C(() => ({
            background: Ge(e) ? e.value : t ? e[t] : null
        })),
        {
            colorClasses: a,
            colorStyles: l
        } = Kv(n);
    return {
        backgroundColorClasses: a,
        backgroundColorStyles: l
    }
}
const rt = W({
    rounded: {
        type: [Boolean, Number, String],
        default: void 0
    },
    tile: Boolean
}, "rounded");

function ct(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ra();
    return {
        roundedClasses: C(() => {
            const a = Ge(e) ? e.value : e.rounded,
                l = Ge(e) ? e.value : e.tile,
                r = [];
            if (a === !0 || a === "") r.push(`${t}--rounded`);
            else if (typeof a == "string" || a === 0)
                for (const o of String(a).split(" ")) r.push(`rounded-${o}`);
            else(l || a === !1) && r.push("rounded-0");
            return r
        })
    }
}
const Wn = W({
        transition: {
            type: [Boolean, String, Object],
            default: "fade-transition",
            validator: e => e !== !0
        }
    }, "transition"),
    jt = (e, t) => {
        let {
            slots: n
        } = t;
        const {
            transition: a,
            disabled: l,
            group: r,
            ...o
        } = e, {
            component: i = r ? iu : Tn,
            ...s
        } = typeof a == "object" ? a : {};
        return ht(i, te(typeof a == "string" ? {
            name: l ? "" : a
        } : s, typeof a == "string" ? {} : Object.fromEntries(Object.entries({
            disabled: l,
            group: r
        }).filter(u => {
            let [c, d] = u;
            return d !== void 0
        })), o), n)
    };

function UN(e, t) {
    if (!Ev) return;
    const n = t.modifiers || {},
        a = t.value,
        {
            handler: l,
            options: r
        } = typeof a == "object" ? a : {
            handler: a,
            options: {}
        },
        o = new IntersectionObserver(function() {
            var d;
            let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
                s = arguments.length > 1 ? arguments[1] : void 0;
            const u = (d = e._observe) == null ? void 0 : d[t.instance.$.uid];
            if (!u) return;
            const c = i.some(f => f.isIntersecting);
            l && (!n.quiet || u.init) && (!n.once || c || u.init) && l(c, i, s), c && n.once ? $S(e, t) : u.init = !0
        }, r);
    e._observe = Object(e._observe), e._observe[t.instance.$.uid] = {
        init: !1,
        observer: o
    }, o.observe(e)
}

function $S(e, t) {
    var a;
    const n = (a = e._observe) == null ? void 0 : a[t.instance.$.uid];
    n && (n.observer.unobserve(e), delete e._observe[t.instance.$.uid])
}
const fi = {
        mounted: UN,
        unmounted: $S
    },
    BS = W({
        absolute: Boolean,
        alt: String,
        cover: Boolean,
        color: String,
        draggable: {
            type: [Boolean, String],
            default: void 0
        },
        eager: Boolean,
        gradient: String,
        lazySrc: String,
        options: {
            type: Object,
            default: () => ({
                root: void 0,
                rootMargin: void 0,
                threshold: void 0
            })
        },
        sizes: String,
        src: {
            type: [String, Object],
            default: ""
        },
        crossorigin: String,
        referrerpolicy: String,
        srcset: String,
        position: String,
        ...NS(),
        ...Se(),
        ...rt(),
        ...Wn()
    }, "VImg"),
    Ca = Z()({
        name: "VImg",
        directives: {
            intersect: fi
        },
        props: BS(),
        emits: {
            loadstart: e => !0,
            load: e => !0,
            error: e => !0
        },
        setup(e, t) {
            let {
                emit: n,
                slots: a
            } = t;
            const {
                backgroundColorClasses: l,
                backgroundColorStyles: r
            } = Ke(Y(e, "color")), {
                roundedClasses: o
            } = ct(e), i = ut("VImg"), s = fe(""), u = Q(), c = fe(e.eager ? "loading" : "idle"), d = fe(), f = fe(), v = C(() => e.src && typeof e.src == "object" ? {
                src: e.src.src,
                srcset: e.srcset || e.src.srcset,
                lazySrc: e.lazySrc || e.src.lazySrc,
                aspect: Number(e.aspectRatio || e.src.aspect || 0)
            } : {
                src: e.src,
                srcset: e.srcset,
                lazySrc: e.lazySrc,
                aspect: Number(e.aspectRatio || 0)
            }), g = C(() => v.value.aspect || d.value / f.value || 0);
            de(() => e.src, () => {
                h(c.value !== "idle")
            }), de(g, (I, R) => {
                !I && R && u.value && _(u.value)
            }), tu(() => h());

            function h(I) {
                if (!(e.eager && I) && !(Ev && !I && !e.eager)) {
                    if (c.value = "loading", v.value.lazySrc) {
                        const R = new Image;
                        R.src = v.value.lazySrc, _(R, null)
                    }
                    v.value.src && Re(() => {
                        var R;
                        n("loadstart", ((R = u.value) == null ? void 0 : R.currentSrc) || v.value.src), setTimeout(() => {
                            var B;
                            if (!i.isUnmounted)
                                if ((B = u.value) != null && B.complete) {
                                    if (u.value.naturalWidth || S(), c.value === "error") return;
                                    g.value || _(u.value, null), c.value === "loading" && y()
                                } else g.value || _(u.value), b()
                        })
                    })
                }
            }

            function y() {
                var I;
                i.isUnmounted || (b(), _(u.value), c.value = "loaded", n("load", ((I = u.value) == null ? void 0 : I.currentSrc) || v.value.src))
            }

            function S() {
                var I;
                i.isUnmounted || (c.value = "error", n("error", ((I = u.value) == null ? void 0 : I.currentSrc) || v.value.src))
            }

            function b() {
                const I = u.value;
                I && (s.value = I.currentSrc || I.src)
            }
            let p = -1;
            Ct(() => {
                clearTimeout(p)
            });

            function _(I) {
                let R = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;
                const B = () => {
                    if (clearTimeout(p), i.isUnmounted) return;
                    const {
                        naturalHeight: $,
                        naturalWidth: D
                    } = I;
                    $ || D ? (d.value = D, f.value = $) : !I.complete && c.value === "loading" && R != null ? p = window.setTimeout(B, R) : (I.currentSrc.endsWith(".svg") || I.currentSrc.startsWith("data:image/svg+xml")) && (d.value = 1, f.value = 1)
                };
                B()
            }
            const w = C(() => ({
                    "v-img__img--cover": e.cover,
                    "v-img__img--contain": !e.cover
                })),
                k = () => {
                    var B;
                    if (!v.value.src || c.value === "idle") return null;
                    const I = m("img", {
                            class: ["v-img__img", w.value],
                            style: {
                                objectPosition: e.position
                            },
                            src: v.value.src,
                            srcset: v.value.srcset,
                            alt: e.alt,
                            crossorigin: e.crossorigin,
                            referrerpolicy: e.referrerpolicy,
                            draggable: e.draggable,
                            sizes: e.sizes,
                            ref: u,
                            onLoad: y,
                            onError: S
                        }, null),
                        R = (B = a.sources) == null ? void 0 : B.call(a);
                    return m(jt, {
                        transition: e.transition,
                        appear: !0
                    }, {
                        default: () => [at(R ? m("picture", {
                            class: "v-img__picture"
                        }, [R, I]) : I, [
                            [bn, c.value === "loaded"]
                        ])]
                    })
                },
                E = () => m(jt, {
                    transition: e.transition
                }, {
                    default: () => [v.value.lazySrc && c.value !== "loaded" && m("img", {
                        class: ["v-img__img", "v-img__img--preload", w.value],
                        style: {
                            objectPosition: e.position
                        },
                        src: v.value.lazySrc,
                        alt: e.alt,
                        crossorigin: e.crossorigin,
                        referrerpolicy: e.referrerpolicy,
                        draggable: e.draggable
                    }, null)]
                }),
                P = () => a.placeholder ? m(jt, {
                    transition: e.transition,
                    appear: !0
                }, {
                    default: () => [(c.value === "loading" || c.value === "error" && !a.error) && m("div", {
                        class: "v-img__placeholder"
                    }, [a.placeholder()])]
                }) : null,
                x = () => a.error ? m(jt, {
                    transition: e.transition,
                    appear: !0
                }, {
                    default: () => [c.value === "error" && m("div", {
                        class: "v-img__error"
                    }, [a.error()])]
                }) : null,
                T = () => e.gradient ? m("div", {
                    class: "v-img__gradient",
                    style: {
                        backgroundImage: `linear-gradient(${e.gradient})`
                    }
                }, null) : null,
                V = fe(!1); {
                const I = de(g, R => {
                    R && (requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            V.value = !0
                        })
                    }), I())
                })
            }
            return ne(() => {
                const I = Hd.filterProps(e);
                return at(m(Hd, te({
                    class: ["v-img", {
                        "v-img--absolute": e.absolute,
                        "v-img--booting": !V.value
                    }, l.value, o.value, e.class],
                    style: [{
                        width: ge(e.width === "auto" ? d.value : e.width)
                    }, r.value, e.style]
                }, I, {
                    aspectRatio: g.value,
                    "aria-label": e.alt,
                    role: e.alt ? "img" : void 0
                }), {
                    additional: () => m(ye, null, [m(k, null, null), m(E, null, null), m(T, null, null), m(P, null, null), m(x, null, null)]),
                    default: a.default
                }), [
                    [tn("intersect"), {
                        handler: h,
                        options: e.options
                    }, null, {
                        once: !0
                    }]
                ])
            }), {
                currentSrc: s,
                image: u,
                state: c,
                naturalWidth: d,
                naturalHeight: f
            }
        }
    }),
    an = W({
        border: [Boolean, Number, String]
    }, "border");

function Sn(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ra();
    return {
        borderClasses: C(() => {
            const a = Ge(e) ? e.value : e.border,
                l = [];
            if (a === !0 || a === "") l.push(`${t}--border`);
            else if (typeof a == "string" || a === 0)
                for (const r of String(a).split(" ")) l.push(`border-${r}`);
            return l
        })
    }
}
const Pt = W({
    elevation: {
        type: [Number, String],
        validator(e) {
            const t = parseInt(e);
            return !isNaN(t) && t >= 0 && t <= 24
        }
    }
}, "elevation");

function Dt(e) {
    return {
        elevationClasses: C(() => {
            const n = Ge(e) ? e.value : e.elevation,
                a = [];
            return n == null || a.push(`elevation-${n}`), a
        })
    }
}
const WN = [null, "prominent", "default", "comfortable", "compact"],
    FS = W({
        absolute: Boolean,
        collapse: Boolean,
        color: String,
        density: {
            type: String,
            default: "default",
            validator: e => WN.includes(e)
        },
        extended: Boolean,
        extensionHeight: {
            type: [Number, String],
            default: 48
        },
        flat: Boolean,
        floating: Boolean,
        height: {
            type: [Number, String],
            default: 64
        },
        image: String,
        title: String,
        ...an(),
        ...Se(),
        ...Pt(),
        ...rt(),
        ...Ae({
            tag: "header"
        }),
        ...Ne()
    }, "VToolbar"),
    jd = Z()({
        name: "VToolbar",
        props: FS(),
        setup(e, t) {
            var v;
            let {
                slots: n
            } = t;
            const {
                backgroundColorClasses: a,
                backgroundColorStyles: l
            } = Ke(Y(e, "color")), {
                borderClasses: r
            } = Sn(e), {
                elevationClasses: o
            } = Dt(e), {
                roundedClasses: i
            } = ct(e), {
                themeClasses: s
            } = je(e), {
                rtlClasses: u
            } = xt(), c = fe(!!(e.extended || (v = n.extension) != null && v.call(n))), d = C(() => parseInt(Number(e.height) + (e.density === "prominent" ? Number(e.height) : 0) - (e.density === "comfortable" ? 8 : 0) - (e.density === "compact" ? 16 : 0), 10)), f = C(() => c.value ? parseInt(Number(e.extensionHeight) + (e.density === "prominent" ? Number(e.extensionHeight) : 0) - (e.density === "comfortable" ? 4 : 0) - (e.density === "compact" ? 8 : 0), 10) : 0);
            return lt({
                VBtn: {
                    variant: "text"
                }
            }), ne(() => {
                var S;
                const g = !!(e.title || n.title),
                    h = !!(n.image || e.image),
                    y = (S = n.extension) == null ? void 0 : S.call(n);
                return c.value = !!(e.extended || y), m(e.tag, {
                    class: ["v-toolbar", {
                        "v-toolbar--absolute": e.absolute,
                        "v-toolbar--collapse": e.collapse,
                        "v-toolbar--flat": e.flat,
                        "v-toolbar--floating": e.floating,
                        [`v-toolbar--density-${e.density}`]: !0
                    }, a.value, r.value, o.value, i.value, s.value, u.value, e.class],
                    style: [l.value, e.style]
                }, {
                    default: () => [h && m("div", {
                        key: "image",
                        class: "v-toolbar__image"
                    }, [n.image ? m(Ve, {
                        key: "image-defaults",
                        disabled: !e.image,
                        defaults: {
                            VImg: {
                                cover: !0,
                                src: e.image
                            }
                        }
                    }, n.image) : m(Ca, {
                        key: "image-img",
                        cover: !0,
                        src: e.image
                    }, null)]), m(Ve, {
                        defaults: {
                            VTabs: {
                                height: ge(d.value)
                            }
                        }
                    }, {
                        default: () => {
                            var b, p, _;
                            return [m("div", {
                                class: "v-toolbar__content",
                                style: {
                                    height: ge(d.value)
                                }
                            }, [n.prepend && m("div", {
                                class: "v-toolbar__prepend"
                            }, [(b = n.prepend) == null ? void 0 : b.call(n)]), g && m(jv, {
                                key: "title",
                                text: e.title
                            }, {
                                text: n.title
                            }), (p = n.default) == null ? void 0 : p.call(n), n.append && m("div", {
                                class: "v-toolbar__append"
                            }, [(_ = n.append) == null ? void 0 : _.call(n)])])]
                        }
                    }), m(Ve, {
                        defaults: {
                            VTabs: {
                                height: ge(f.value)
                            }
                        }
                    }, {
                        default: () => [m(Vu, null, {
                            default: () => [c.value && m("div", {
                                class: "v-toolbar__extension",
                                style: {
                                    height: ge(f.value)
                                }
                            }, [y])]
                        })]
                    })]
                })
            }), {
                contentHeight: d,
                extensionHeight: f
            }
        }
    }),
    zN = W({
        scrollTarget: {
            type: String
        },
        scrollThreshold: {
            type: [String, Number],
            default: 300
        }
    }, "scroll");

function KN(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
        canScroll: n
    } = t;
    let a = 0,
        l = 0;
    const r = Q(null),
        o = fe(0),
        i = fe(0),
        s = fe(0),
        u = fe(!1),
        c = fe(!1),
        d = C(() => Number(e.scrollThreshold)),
        f = C(() => ot((d.value - o.value) / d.value || 0)),
        v = () => {
            const g = r.value;
            if (!g || n && !n.value) return;
            a = o.value, o.value = "window" in g ? g.pageYOffset : g.scrollTop;
            const h = g instanceof Window ? document.documentElement.scrollHeight : g.scrollHeight;
            if (l !== h) {
                l = h;
                return
            }
            c.value = o.value < a, s.value = Math.abs(o.value - d.value)
        };
    return de(c, () => {
        i.value = i.value || o.value
    }), de(u, () => {
        i.value = 0
    }), it(() => {
        de(() => e.scrollTarget, g => {
            var y;
            const h = g ? document.querySelector(g) : window;
            h && h !== r.value && ((y = r.value) == null || y.removeEventListener("scroll", v), r.value = h, r.value.addEventListener("scroll", v, {
                passive: !0
            }))
        }, {
            immediate: !0
        })
    }), Ct(() => {
        var g;
        (g = r.value) == null || g.removeEventListener("scroll", v)
    }), n && de(n, v, {
        immediate: !0
    }), {
        scrollThreshold: d,
        currentScroll: o,
        currentThreshold: s,
        isScrollActive: u,
        scrollRatio: f,
        isScrollingUp: c,
        savedScroll: i
    }
}

function Kl() {
    const e = fe(!1);
    return it(() => {
        window.requestAnimationFrame(() => {
            e.value = !0
        })
    }), {
        ssrBootStyles: C(() => e.value ? void 0 : {
            transition: "none !important"
        }),
        isBooted: Br(e)
    }
}
const GN = W({
        scrollBehavior: String,
        modelValue: {
            type: Boolean,
            default: !0
        },
        location: {
            type: String,
            default: "top",
            validator: e => ["top", "bottom"].includes(e)
        },
        ...FS(),
        ...Wl(),
        ...zN(),
        height: {
            type: [Number, String],
            default: 64
        }
    }, "VAppBar"),
    YN = Z()({
        name: "VAppBar",
        props: GN(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Q(),
                l = Ce(e, "modelValue"),
                r = C(() => {
                    var p;
                    const b = new Set(((p = e.scrollBehavior) == null ? void 0 : p.split(" ")) ? ? []);
                    return {
                        hide: b.has("hide"),
                        fullyHide: b.has("fully-hide"),
                        inverted: b.has("inverted"),
                        collapse: b.has("collapse"),
                        elevate: b.has("elevate"),
                        fadeImage: b.has("fade-image")
                    }
                }),
                o = C(() => {
                    const b = r.value;
                    return b.hide || b.fullyHide || b.inverted || b.collapse || b.elevate || b.fadeImage || !l.value
                }),
                {
                    currentScroll: i,
                    scrollThreshold: s,
                    isScrollingUp: u,
                    scrollRatio: c
                } = KN(e, {
                    canScroll: o
                }),
                d = C(() => r.value.hide || r.value.fullyHide),
                f = C(() => e.collapse || r.value.collapse && (r.value.inverted ? c.value > 0 : c.value === 0)),
                v = C(() => e.flat || r.value.fullyHide && !l.value || r.value.elevate && (r.value.inverted ? i.value > 0 : i.value === 0)),
                g = C(() => r.value.fadeImage ? r.value.inverted ? 1 - c.value : c.value : void 0),
                h = C(() => {
                    var _, w;
                    if (r.value.hide && r.value.inverted) return 0;
                    const b = ((_ = a.value) == null ? void 0 : _.contentHeight) ? ? 0,
                        p = ((w = a.value) == null ? void 0 : w.extensionHeight) ? ? 0;
                    return d.value ? i.value < s.value || r.value.fullyHide ? b + p : b : b + p
                });
            Yt(C(() => !!e.scrollBehavior), () => {
                st(() => {
                    d.value ? r.value.inverted ? l.value = i.value > s.value : l.value = u.value || i.value < s.value : l.value = !0
                })
            });
            const {
                ssrBootStyles: y
            } = Kl(), {
                layoutItemStyles: S
            } = zl({
                id: e.name,
                order: C(() => parseInt(e.order, 10)),
                position: Y(e, "location"),
                layoutSize: h,
                elementSize: fe(void 0),
                active: l,
                absolute: Y(e, "absolute")
            });
            return ne(() => {
                const b = jd.filterProps(e);
                return m(jd, te({
                    ref: a,
                    class: ["v-app-bar", {
                        "v-app-bar--bottom": e.location === "bottom"
                    }, e.class],
                    style: [{ ...S.value,
                        "--v-toolbar-image-opacity": g.value,
                        height: void 0,
                        ...y.value
                    }, e.style]
                }, b, {
                    collapse: f.value,
                    flat: v.value
                }), n)
            }), {}
        }
    }),
    qN = [null, "default", "comfortable", "compact"],
    Vt = W({
        density: {
            type: String,
            default: "default",
            validator: e => qN.includes(e)
        }
    }, "density");

function zt(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ra();
    return {
        densityClasses: C(() => `${t}--density-${e.density}`)
    }
}
const XN = ["elevated", "flat", "tonal", "outlined", "text", "plain"];

function ll(e, t) {
    return m(ye, null, [e && m("span", {
        key: "overlay",
        class: `${t}__overlay`
    }, null), m("span", {
        key: "underlay",
        class: `${t}__underlay`
    }, null)])
}
const Rn = W({
    color: String,
    variant: {
        type: String,
        default: "elevated",
        validator: e => XN.includes(e)
    }
}, "variant");

function Gl(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ra();
    const n = C(() => {
            const {
                variant: r
            } = Ie(e);
            return `${t}--variant-${r}`
        }),
        {
            colorClasses: a,
            colorStyles: l
        } = Kv(C(() => {
            const {
                variant: r,
                color: o
            } = Ie(e);
            return {
                [
                    ["elevated", "flat"].includes(r) ? "background" : "text"
                ]: o
            }
        }));
    return {
        colorClasses: a,
        colorStyles: l,
        variantClasses: n
    }
}
const HS = W({
        baseColor: String,
        divided: Boolean,
        ...an(),
        ...Se(),
        ...Vt(),
        ...Pt(),
        ...rt(),
        ...Ae(),
        ...Ne(),
        ...Rn()
    }, "VBtnGroup"),
    Ud = Z()({
        name: "VBtnGroup",
        props: HS(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                themeClasses: a
            } = je(e), {
                densityClasses: l
            } = zt(e), {
                borderClasses: r
            } = Sn(e), {
                elevationClasses: o
            } = Dt(e), {
                roundedClasses: i
            } = ct(e);
            lt({
                VBtn: {
                    height: "auto",
                    baseColor: Y(e, "baseColor"),
                    color: Y(e, "color"),
                    density: Y(e, "density"),
                    flat: !0,
                    variant: Y(e, "variant")
                }
            }), ne(() => m(e.tag, {
                class: ["v-btn-group", {
                    "v-btn-group--divided": e.divided
                }, a.value, r.value, l.value, o.value, i.value, e.class],
                style: e.style
            }, n))
        }
    }),
    Yl = W({
        modelValue: {
            type: null,
            default: void 0
        },
        multiple: Boolean,
        mandatory: [Boolean, String],
        max: Number,
        selectedClass: String,
        disabled: Boolean
    }, "group"),
    ql = W({
        value: null,
        disabled: Boolean,
        selectedClass: String
    }, "group-item");

function Xl(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
    const a = ut("useGroupItem");
    if (!a) throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");
    const l = Rt();
    He(Symbol.for(`${t.description}:id`), l);
    const r = Te(t, null);
    if (!r) {
        if (!n) return r;
        throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${t.description}`)
    }
    const o = Y(e, "value"),
        i = C(() => !!(r.disabled.value || e.disabled));
    r.register({
        id: l,
        value: o,
        disabled: i
    }, a), Ct(() => {
        r.unregister(l)
    });
    const s = C(() => r.isSelected(l)),
        u = C(() => r.items.value[0].id === l),
        c = C(() => r.items.value[r.items.value.length - 1].id === l),
        d = C(() => s.value && [r.selectedClass.value, e.selectedClass]);
    return de(s, f => {
        a.emit("group:selected", {
            value: f
        })
    }, {
        flush: "sync"
    }), {
        id: l,
        isSelected: s,
        isFirst: u,
        isLast: c,
        toggle: () => r.select(l, !s.value),
        select: f => r.select(l, f),
        selectedClass: d,
        value: o,
        disabled: i,
        group: r
    }
}

function rl(e, t) {
    let n = !1;
    const a = mt([]),
        l = Ce(e, "modelValue", [], f => f == null ? [] : jS(a, nt(f)), f => {
            const v = ZN(a, f);
            return e.multiple ? v : v[0]
        }),
        r = ut("useGroup");

    function o(f, v) {
        const g = f,
            h = Symbol.for(`${t.description}:id`),
            S = fr(h, r == null ? void 0 : r.vnode).indexOf(v);
        Ie(g.value) == null && (g.value = S, g.useIndexAsValue = !0), S > -1 ? a.splice(S, 0, g) : a.push(g)
    }

    function i(f) {
        if (n) return;
        s();
        const v = a.findIndex(g => g.id === f);
        a.splice(v, 1)
    }

    function s() {
        const f = a.find(v => !v.disabled);
        f && e.mandatory === "force" && !l.value.length && (l.value = [f.id])
    }
    it(() => {
        s()
    }), Ct(() => {
        n = !0
    }), ai(() => {
        for (let f = 0; f < a.length; f++) a[f].useIndexAsValue && (a[f].value = f)
    });

    function u(f, v) {
        const g = a.find(h => h.id === f);
        if (!(v && (g != null && g.disabled)))
            if (e.multiple) {
                const h = l.value.slice(),
                    y = h.findIndex(b => b === f),
                    S = ~y;
                if (v = v ? ? !S, S && e.mandatory && h.length <= 1 || !S && e.max != null && h.length + 1 > e.max) return;
                y < 0 && v ? h.push(f) : y >= 0 && !v && h.splice(y, 1), l.value = h
            } else {
                const h = l.value.includes(f);
                if (e.mandatory && h) return;
                l.value = v ? ? !h ? [f] : []
            }
    }

    function c(f) {
        if (e.multiple, l.value.length) {
            const v = l.value[0],
                g = a.findIndex(S => S.id === v);
            let h = (g + f) % a.length,
                y = a[h];
            for (; y.disabled && h !== g;) h = (h + f) % a.length, y = a[h];
            if (y.disabled) return;
            l.value = [a[h].id]
        } else {
            const v = a.find(g => !g.disabled);
            v && (l.value = [v.id])
        }
    }
    const d = {
        register: o,
        unregister: i,
        selected: l,
        select: u,
        disabled: Y(e, "disabled"),
        prev: () => c(a.length - 1),
        next: () => c(1),
        isSelected: f => l.value.includes(f),
        selectedClass: C(() => e.selectedClass),
        items: C(() => a),
        getItemIndex: f => JN(a, f)
    };
    return He(t, d), d
}

function JN(e, t) {
    const n = jS(e, [t]);
    return n.length ? e.findIndex(a => a.id === n[0]) : -1
}

function jS(e, t) {
    const n = [];
    return t.forEach(a => {
        const l = e.find(o => la(a, o.value)),
            r = e[a];
        (l == null ? void 0 : l.value) != null ? n.push(l.id) : r != null && n.push(r.id)
    }), n
}

function ZN(e, t) {
    const n = [];
    return t.forEach(a => {
        const l = e.findIndex(r => r.id === a);
        if (~l) {
            const r = e[l];
            n.push(r.value != null ? r.value : l)
        }
    }), n
}
const Gv = Symbol.for("vuetify:v-btn-toggle"),
    QN = W({ ...HS(),
        ...Yl()
    }, "VBtnToggle"),
    e$ = Z()({
        name: "VBtnToggle",
        props: QN(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                isSelected: a,
                next: l,
                prev: r,
                select: o,
                selected: i
            } = rl(e, Gv);
            return ne(() => {
                const s = Ud.filterProps(e);
                return m(Ud, te({
                    class: ["v-btn-toggle", e.class]
                }, s, {
                    style: e.style
                }), {
                    default: () => {
                        var u;
                        return [(u = n.default) == null ? void 0 : u.call(n, {
                            isSelected: a,
                            next: l,
                            prev: r,
                            select: o,
                            selected: i
                        })]
                    }
                })
            }), {
                next: l,
                prev: r,
                select: o
            }
        }
    }),
    t$ = ["x-small", "small", "default", "large", "x-large"],
    sa = W({
        size: {
            type: [String, Number],
            default: "default"
        }
    }, "size");

function Wr(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ra();
    return Av(() => {
        let n, a;
        return Vs(t$, e.size) ? n = `${t}--size-${e.size}` : e.size && (a = {
            width: ge(e.size),
            height: ge(e.size)
        }), {
            sizeClasses: n,
            sizeStyles: a
        }
    })
}
const n$ = W({
        color: String,
        disabled: Boolean,
        start: Boolean,
        end: Boolean,
        icon: Pe,
        ...Se(),
        ...sa(),
        ...Ae({
            tag: "i"
        }),
        ...Ne()
    }, "VIcon"),
    Be = Z()({
        name: "VIcon",
        props: n$(),
        setup(e, t) {
            let {
                attrs: n,
                slots: a
            } = t;
            const l = Q(),
                {
                    themeClasses: r
                } = je(e),
                {
                    iconData: o
                } = wN(C(() => l.value || e.icon)),
                {
                    sizeClasses: i
                } = Wr(e),
                {
                    textColorClasses: s,
                    textColorStyles: u
                } = Ot(Y(e, "color"));
            return ne(() => {
                var f, v;
                const c = (f = a.default) == null ? void 0 : f.call(a);
                c && (l.value = (v = Z0(c).filter(g => g.type === Sa && g.children && typeof g.children == "string")[0]) == null ? void 0 : v.children);
                const d = !!(n.onClick || n.onClickOnce);
                return m(o.value.component, {
                    tag: e.tag,
                    icon: o.value.icon,
                    class: ["v-icon", "notranslate", r.value, i.value, s.value, {
                        "v-icon--clickable": d,
                        "v-icon--disabled": e.disabled,
                        "v-icon--start": e.start,
                        "v-icon--end": e.end
                    }, e.class],
                    style: [i.value ? void 0 : {
                        fontSize: ge(e.size),
                        height: ge(e.size),
                        width: ge(e.size)
                    }, u.value, e.style],
                    role: d ? "button" : void 0,
                    "aria-hidden": !d,
                    tabindex: d ? e.disabled ? -1 : 0 : void 0
                }, {
                    default: () => [c]
                })
            }), {}
        }
    });

function Au(e, t) {
    const n = Q(),
        a = fe(!1);
    if (Ev) {
        const l = new IntersectionObserver(r => {
            a.value = !!r.find(o => o.isIntersecting)
        }, t);
        Ct(() => {
            l.disconnect()
        }), de(n, (r, o) => {
            o && (l.unobserve(o), a.value = !1), r && l.observe(r)
        }, {
            flush: "post"
        })
    }
    return {
        intersectionRef: n,
        isIntersecting: a
    }
}
const a$ = W({
        bgColor: String,
        color: String,
        indeterminate: [Boolean, String],
        modelValue: {
            type: [Number, String],
            default: 0
        },
        rotate: {
            type: [Number, String],
            default: 0
        },
        width: {
            type: [Number, String],
            default: 4
        },
        ...Se(),
        ...sa(),
        ...Ae({
            tag: "div"
        }),
        ...Ne()
    }, "VProgressCircular"),
    Ja = Z()({
        name: "VProgressCircular",
        props: a$(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = 20,
                l = 2 * Math.PI * a,
                r = Q(),
                {
                    themeClasses: o
                } = je(e),
                {
                    sizeClasses: i,
                    sizeStyles: s
                } = Wr(e),
                {
                    textColorClasses: u,
                    textColorStyles: c
                } = Ot(Y(e, "color")),
                {
                    textColorClasses: d,
                    textColorStyles: f
                } = Ot(Y(e, "bgColor")),
                {
                    intersectionRef: v,
                    isIntersecting: g
                } = Au(),
                {
                    resizeRef: h,
                    contentRect: y
                } = Hn(),
                S = C(() => Math.max(0, Math.min(100, parseFloat(e.modelValue)))),
                b = C(() => Number(e.width)),
                p = C(() => s.value ? Number(e.size) : y.value ? y.value.width : Math.max(b.value, 32)),
                _ = C(() => a / (1 - b.value / p.value) * 2),
                w = C(() => b.value / p.value * _.value),
                k = C(() => ge((100 - S.value) / 100 * l));
            return st(() => {
                v.value = r.value, h.value = r.value
            }), ne(() => m(e.tag, {
                ref: r,
                class: ["v-progress-circular", {
                    "v-progress-circular--indeterminate": !!e.indeterminate,
                    "v-progress-circular--visible": g.value,
                    "v-progress-circular--disable-shrink": e.indeterminate === "disable-shrink"
                }, o.value, i.value, u.value, e.class],
                style: [s.value, c.value, e.style],
                role: "progressbar",
                "aria-valuemin": "0",
                "aria-valuemax": "100",
                "aria-valuenow": e.indeterminate ? void 0 : S.value
            }, {
                default: () => [m("svg", {
                    style: {
                        transform: `rotate(calc(-90deg + ${Number(e.rotate)}deg))`
                    },
                    xmlns: "http://www.w3.org/2000/svg",
                    viewBox: `0 0 ${_.value} ${_.value}`
                }, [m("circle", {
                    class: ["v-progress-circular__underlay", d.value],
                    style: f.value,
                    fill: "transparent",
                    cx: "50%",
                    cy: "50%",
                    r: a,
                    "stroke-width": w.value,
                    "stroke-dasharray": l,
                    "stroke-dashoffset": 0
                }, null), m("circle", {
                    class: "v-progress-circular__overlay",
                    fill: "transparent",
                    cx: "50%",
                    cy: "50%",
                    r: a,
                    "stroke-width": w.value,
                    "stroke-dasharray": l,
                    "stroke-dashoffset": k.value
                }, null)]), n.default && m("div", {
                    class: "v-progress-circular__content"
                }, [n.default({
                    value: S.value
                })])]
            })), {}
        }
    }),
    $y = {
        center: "center",
        top: "bottom",
        bottom: "top",
        left: "right",
        right: "left"
    },
    Ea = W({
        location: String
    }, "location");

function Jl(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
        n = arguments.length > 2 ? arguments[2] : void 0;
    const {
        isRtl: a
    } = xt();
    return {
        locationStyles: C(() => {
            if (!e.location) return {};
            const {
                side: r,
                align: o
            } = Od(e.location.split(" ").length > 1 ? e.location : `${e.location} center`, a.value);

            function i(u) {
                return n ? n(u) : 0
            }
            const s = {};
            return r !== "center" && (t ? s[$y[r]] = `calc(100% - ${i(r)}px)` : s[r] = 0), o !== "center" ? t ? s[$y[o]] = `calc(100% - ${i(o)}px)` : s[o] = 0 : (r === "center" ? s.top = s.left = "50%" : s[{
                top: "left",
                bottom: "left",
                left: "top",
                right: "top"
            }[r]] = "50%", s.transform = {
                top: "translateX(-50%)",
                bottom: "translateX(-50%)",
                left: "translateY(-50%)",
                right: "translateY(-50%)",
                center: "translate(-50%, -50%)"
            }[r]), s
        })
    }
}
const l$ = W({
        absolute: Boolean,
        active: {
            type: Boolean,
            default: !0
        },
        bgColor: String,
        bgOpacity: [Number, String],
        bufferValue: {
            type: [Number, String],
            default: 0
        },
        bufferColor: String,
        bufferOpacity: [Number, String],
        clickable: Boolean,
        color: String,
        height: {
            type: [Number, String],
            default: 4
        },
        indeterminate: Boolean,
        max: {
            type: [Number, String],
            default: 100
        },
        modelValue: {
            type: [Number, String],
            default: 0
        },
        opacity: [Number, String],
        reverse: Boolean,
        stream: Boolean,
        striped: Boolean,
        roundedBar: Boolean,
        ...Se(),
        ...Ea({
            location: "top"
        }),
        ...rt(),
        ...Ae(),
        ...Ne()
    }, "VProgressLinear"),
    Lu = Z()({
        name: "VProgressLinear",
        props: l$(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            var V;
            let {
                slots: n
            } = t;
            const a = Ce(e, "modelValue"),
                {
                    isRtl: l,
                    rtlClasses: r
                } = xt(),
                {
                    themeClasses: o
                } = je(e),
                {
                    locationStyles: i
                } = Jl(e),
                {
                    textColorClasses: s,
                    textColorStyles: u
                } = Ot(e, "color"),
                {
                    backgroundColorClasses: c,
                    backgroundColorStyles: d
                } = Ke(C(() => e.bgColor || e.color)),
                {
                    backgroundColorClasses: f,
                    backgroundColorStyles: v
                } = Ke(C(() => e.bufferColor || e.bgColor || e.color)),
                {
                    backgroundColorClasses: g,
                    backgroundColorStyles: h
                } = Ke(e, "color"),
                {
                    roundedClasses: y
                } = ct(e),
                {
                    intersectionRef: S,
                    isIntersecting: b
                } = Au(),
                p = C(() => parseFloat(e.max)),
                _ = C(() => parseFloat(e.height)),
                w = C(() => ot(parseFloat(e.bufferValue) / p.value * 100, 0, 100)),
                k = C(() => ot(parseFloat(a.value) / p.value * 100, 0, 100)),
                E = C(() => l.value !== e.reverse),
                P = C(() => e.indeterminate ? "fade-transition" : "slide-x-transition"),
                x = Ue && ((V = window.matchMedia) == null ? void 0 : V.call(window, "(forced-colors: active)").matches);

            function T(I) {
                if (!S.value) return;
                const {
                    left: R,
                    right: B,
                    width: $
                } = S.value.getBoundingClientRect(), D = E.value ? $ - I.clientX + (B - $) : I.clientX - R;
                a.value = Math.round(D / $ * p.value)
            }
            return ne(() => m(e.tag, {
                ref: S,
                class: ["v-progress-linear", {
                    "v-progress-linear--absolute": e.absolute,
                    "v-progress-linear--active": e.active && b.value,
                    "v-progress-linear--reverse": E.value,
                    "v-progress-linear--rounded": e.rounded,
                    "v-progress-linear--rounded-bar": e.roundedBar,
                    "v-progress-linear--striped": e.striped
                }, y.value, o.value, r.value, e.class],
                style: [{
                    bottom: e.location === "bottom" ? 0 : void 0,
                    top: e.location === "top" ? 0 : void 0,
                    height: e.active ? ge(_.value) : 0,
                    "--v-progress-linear-height": ge(_.value),
                    ...e.absolute ? i.value : {}
                }, e.style],
                role: "progressbar",
                "aria-hidden": e.active ? "false" : "true",
                "aria-valuemin": "0",
                "aria-valuemax": e.max,
                "aria-valuenow": e.indeterminate ? void 0 : k.value,
                onClick: e.clickable && T
            }, {
                default: () => [e.stream && m("div", {
                    key: "stream",
                    class: ["v-progress-linear__stream", s.value],
                    style: { ...u.value,
                        [E.value ? "left" : "right"]: ge(-_.value),
                        borderTop: `${ge(_.value/2)} dotted`,
                        opacity: parseFloat(e.bufferOpacity),
                        top: `calc(50% - ${ge(_.value/4)})`,
                        width: ge(100 - w.value, "%"),
                        "--v-progress-linear-stream-to": ge(_.value * (E.value ? 1 : -1))
                    }
                }, null), m("div", {
                    class: ["v-progress-linear__background", x ? void 0 : c.value],
                    style: [d.value, {
                        opacity: parseFloat(e.bgOpacity),
                        width: e.stream ? 0 : void 0
                    }]
                }, null), m("div", {
                    class: ["v-progress-linear__buffer", x ? void 0 : f.value],
                    style: [v.value, {
                        opacity: parseFloat(e.bufferOpacity),
                        width: ge(w.value, "%")
                    }]
                }, null), m(Tn, {
                    name: P.value
                }, {
                    default: () => [e.indeterminate ? m("div", {
                        class: "v-progress-linear__indeterminate"
                    }, [
                        ["long", "short"].map(I => m("div", {
                            key: I,
                            class: ["v-progress-linear__indeterminate", I, x ? void 0 : g.value],
                            style: h.value
                        }, null))
                    ]) : m("div", {
                        class: ["v-progress-linear__determinate", x ? void 0 : g.value],
                        style: [h.value, {
                            width: ge(k.value, "%")
                        }]
                    }, null)]
                }), n.default && m("div", {
                    class: "v-progress-linear__content"
                }, [n.default({
                    value: k.value,
                    buffer: w.value
                })])]
            })), {}
        }
    }),
    Ou = W({
        loading: [Boolean, String]
    }, "loader");

function vi(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ra();
    return {
        loaderClasses: C(() => ({
            [`${t}--loading`]: e.loading
        }))
    }
}

function mi(e, t) {
    var a;
    let {
        slots: n
    } = t;
    return m("div", {
        class: `${e.name}__loader`
    }, [((a = n.default) == null ? void 0 : a.call(n, {
        color: e.color,
        isActive: e.active
    })) || m(Lu, {
        absolute: e.absolute,
        active: e.active,
        color: e.color,
        height: "2",
        indeterminate: !0
    }, null)])
}
const r$ = ["static", "relative", "fixed", "absolute", "sticky"],
    zr = W({
        position: {
            type: String,
            validator: e => r$.includes(e)
        }
    }, "position");

function Kr(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ra();
    return {
        positionClasses: C(() => e.position ? `${t}--${e.position}` : void 0)
    }
}

function o$() {
    const e = ut("useRoute");
    return C(() => {
        var t;
        return (t = e == null ? void 0 : e.proxy) == null ? void 0 : t.$route
    })
}

function US() {
    var e, t;
    return (t = (e = ut("useRouter")) == null ? void 0 : e.proxy) == null ? void 0 : t.$router
}

function Gr(e, t) {
    var u, c;
    const n = Ff("RouterLink"),
        a = C(() => !!(e.href || e.to)),
        l = C(() => (a == null ? void 0 : a.value) || sy(t, "click") || sy(e, "click"));
    if (typeof n == "string" || !("useLink" in n)) return {
        isLink: a,
        isClickable: l,
        href: Y(e, "href")
    };
    const r = C(() => ({ ...e,
            to: Y(() => e.to || "")
        })),
        o = n.useLink(r.value),
        i = C(() => e.to ? o : void 0),
        s = o$();
    return {
        isLink: a,
        isClickable: l,
        route: (u = i.value) == null ? void 0 : u.route,
        navigate: (c = i.value) == null ? void 0 : c.navigate,
        isActive: C(() => {
            var d, f, v;
            return i.value ? e.exact ? s.value ? ((v = i.value.isExactActive) == null ? void 0 : v.value) && la(i.value.route.value.query, s.value.query) : ((f = i.value.isExactActive) == null ? void 0 : f.value) ? ? !1 : ((d = i.value.isActive) == null ? void 0 : d.value) ? ? !1 : !1
        }),
        href: C(() => {
            var d;
            return e.to ? (d = i.value) == null ? void 0 : d.route.value.href : e.href
        })
    }
}
const hi = W({
    href: String,
    replace: Boolean,
    to: [String, Object],
    exact: Boolean
}, "router");
let kc = !1;

function i$(e, t) {
    let n = !1,
        a, l;
    Ue && (Re(() => {
        window.addEventListener("popstate", r), a = e == null ? void 0 : e.beforeEach((o, i, s) => {
            kc ? n ? t(s) : s() : setTimeout(() => n ? t(s) : s()), kc = !0
        }), l = e == null ? void 0 : e.afterEach(() => {
            kc = !1
        })
    }), kt(() => {
        window.removeEventListener("popstate", r), a == null || a(), l == null || l()
    }));

    function r(o) {
        var i;
        (i = o.state) != null && i.replaced || (n = !0, setTimeout(() => n = !1))
    }
}

function s$(e, t) {
    de(() => {
        var n;
        return (n = e.isActive) == null ? void 0 : n.value
    }, n => {
        e.isLink.value && n && t && Re(() => {
            t(!0)
        })
    }, {
        immediate: !0
    })
}
const Wd = Symbol("rippleStop"),
    u$ = 80;

function By(e, t) {
    e.style.transform = t, e.style.webkitTransform = t
}

function zd(e) {
    return e.constructor.name === "TouchEvent"
}

function WS(e) {
    return e.constructor.name === "KeyboardEvent"
}
const c$ = function(e, t) {
        var d;
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
            a = 0,
            l = 0;
        if (!WS(e)) {
            const f = t.getBoundingClientRect(),
                v = zd(e) ? e.touches[e.touches.length - 1] : e;
            a = v.clientX - f.left, l = v.clientY - f.top
        }
        let r = 0,
            o = .3;
        (d = t._ripple) != null && d.circle ? (o = .15, r = t.clientWidth / 2, r = n.center ? r : r + Math.sqrt((a - r) ** 2 + (l - r) ** 2) / 4) : r = Math.sqrt(t.clientWidth ** 2 + t.clientHeight ** 2) / 2;
        const i = `${(t.clientWidth-r*2)/2}px`,
            s = `${(t.clientHeight-r*2)/2}px`,
            u = n.center ? i : `${a-r}px`,
            c = n.center ? s : `${l-r}px`;
        return {
            radius: r,
            scale: o,
            x: u,
            y: c,
            centerX: i,
            centerY: s
        }
    },
    Ds = {
        show(e, t) {
            var v;
            let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            if (!((v = t == null ? void 0 : t._ripple) != null && v.enabled)) return;
            const a = document.createElement("span"),
                l = document.createElement("span");
            a.appendChild(l), a.className = "v-ripple__container", n.class && (a.className += ` ${n.class}`);
            const {
                radius: r,
                scale: o,
                x: i,
                y: s,
                centerX: u,
                centerY: c
            } = c$(e, t, n), d = `${r*2}px`;
            l.className = "v-ripple__animation", l.style.width = d, l.style.height = d, t.appendChild(a);
            const f = window.getComputedStyle(t);
            f && f.position === "static" && (t.style.position = "relative", t.dataset.previousPosition = "static"), l.classList.add("v-ripple__animation--enter"), l.classList.add("v-ripple__animation--visible"), By(l, `translate(${i}, ${s}) scale3d(${o},${o},${o})`), l.dataset.activated = String(performance.now()), setTimeout(() => {
                l.classList.remove("v-ripple__animation--enter"), l.classList.add("v-ripple__animation--in"), By(l, `translate(${u}, ${c}) scale3d(1,1,1)`)
            }, 0)
        },
        hide(e) {
            var r;
            if (!((r = e == null ? void 0 : e._ripple) != null && r.enabled)) return;
            const t = e.getElementsByClassName("v-ripple__animation");
            if (t.length === 0) return;
            const n = t[t.length - 1];
            if (n.dataset.isHiding) return;
            n.dataset.isHiding = "true";
            const a = performance.now() - Number(n.dataset.activated),
                l = Math.max(250 - a, 0);
            setTimeout(() => {
                n.classList.remove("v-ripple__animation--in"), n.classList.add("v-ripple__animation--out"), setTimeout(() => {
                    var i;
                    e.getElementsByClassName("v-ripple__animation").length === 1 && e.dataset.previousPosition && (e.style.position = e.dataset.previousPosition, delete e.dataset.previousPosition), ((i = n.parentNode) == null ? void 0 : i.parentNode) === e && e.removeChild(n.parentNode)
                }, 300)
            }, l)
        }
    };

function zS(e) {
    return typeof e > "u" || !!e
}

function Uo(e) {
    const t = {},
        n = e.currentTarget;
    if (!(!(n != null && n._ripple) || n._ripple.touched || e[Wd])) {
        if (e[Wd] = !0, zd(e)) n._ripple.touched = !0, n._ripple.isTouch = !0;
        else if (n._ripple.isTouch) return;
        if (t.center = n._ripple.centered || WS(e), n._ripple.class && (t.class = n._ripple.class), zd(e)) {
            if (n._ripple.showTimerCommit) return;
            n._ripple.showTimerCommit = () => {
                Ds.show(e, n, t)
            }, n._ripple.showTimer = window.setTimeout(() => {
                var a;
                (a = n == null ? void 0 : n._ripple) != null && a.showTimerCommit && (n._ripple.showTimerCommit(), n._ripple.showTimerCommit = null)
            }, u$)
        } else Ds.show(e, n, t)
    }
}

function Fy(e) {
    e[Wd] = !0
}

function dn(e) {
    const t = e.currentTarget;
    if (t != null && t._ripple) {
        if (window.clearTimeout(t._ripple.showTimer), e.type === "touchend" && t._ripple.showTimerCommit) {
            t._ripple.showTimerCommit(), t._ripple.showTimerCommit = null, t._ripple.showTimer = window.setTimeout(() => {
                dn(e)
            });
            return
        }
        window.setTimeout(() => {
            t._ripple && (t._ripple.touched = !1)
        }), Ds.hide(t)
    }
}

function KS(e) {
    const t = e.currentTarget;
    t != null && t._ripple && (t._ripple.showTimerCommit && (t._ripple.showTimerCommit = null), window.clearTimeout(t._ripple.showTimer))
}
let Wo = !1;

function GS(e) {
    !Wo && (e.keyCode === ly.enter || e.keyCode === ly.space) && (Wo = !0, Uo(e))
}

function YS(e) {
    Wo = !1, dn(e)
}

function qS(e) {
    Wo && (Wo = !1, dn(e))
}

function XS(e, t, n) {
    const {
        value: a,
        modifiers: l
    } = t, r = zS(a);
    if (r || Ds.hide(e), e._ripple = e._ripple ? ? {}, e._ripple.enabled = r, e._ripple.centered = l.center, e._ripple.circle = l.circle, Iv(a) && a.class && (e._ripple.class = a.class), r && !n) {
        if (l.stop) {
            e.addEventListener("touchstart", Fy, {
                passive: !0
            }), e.addEventListener("mousedown", Fy);
            return
        }
        e.addEventListener("touchstart", Uo, {
            passive: !0
        }), e.addEventListener("touchend", dn, {
            passive: !0
        }), e.addEventListener("touchmove", KS, {
            passive: !0
        }), e.addEventListener("touchcancel", dn), e.addEventListener("mousedown", Uo), e.addEventListener("mouseup", dn), e.addEventListener("mouseleave", dn), e.addEventListener("keydown", GS), e.addEventListener("keyup", YS), e.addEventListener("blur", qS), e.addEventListener("dragstart", dn, {
            passive: !0
        })
    } else !r && n && JS(e)
}

function JS(e) {
    e.removeEventListener("mousedown", Uo), e.removeEventListener("touchstart", Uo), e.removeEventListener("touchend", dn), e.removeEventListener("touchmove", KS), e.removeEventListener("touchcancel", dn), e.removeEventListener("mouseup", dn), e.removeEventListener("mouseleave", dn), e.removeEventListener("keydown", GS), e.removeEventListener("keyup", YS), e.removeEventListener("dragstart", dn), e.removeEventListener("blur", qS)
}

function d$(e, t) {
    XS(e, t, !1)
}

function f$(e) {
    delete e._ripple, JS(e)
}

function v$(e, t) {
    if (t.value === t.oldValue) return;
    const n = zS(t.oldValue);
    XS(e, t, n)
}
const Ia = {
        mounted: d$,
        unmounted: f$,
        updated: v$
    },
    Ru = W({
        active: {
            type: Boolean,
            default: void 0
        },
        activeColor: String,
        baseColor: String,
        symbol: {
            type: null,
            default: Gv
        },
        flat: Boolean,
        icon: [Boolean, String, Function, Object],
        prependIcon: Pe,
        appendIcon: Pe,
        block: Boolean,
        readonly: Boolean,
        slim: Boolean,
        stacked: Boolean,
        ripple: {
            type: [Boolean, Object],
            default: !0
        },
        text: String,
        ...an(),
        ...Se(),
        ...Vt(),
        ...bt(),
        ...Pt(),
        ...ql(),
        ...Ou(),
        ...Ea(),
        ...zr(),
        ...rt(),
        ...hi(),
        ...sa(),
        ...Ae({
            tag: "button"
        }),
        ...Ne(),
        ...Rn({
            variant: "elevated"
        })
    }, "VBtn"),
    Le = Z()({
        name: "VBtn",
        props: Ru(),
        emits: {
            "group:selected": e => !0
        },
        setup(e, t) {
            let {
                attrs: n,
                slots: a
            } = t;
            const {
                themeClasses: l
            } = je(e), {
                borderClasses: r
            } = Sn(e), {
                densityClasses: o
            } = zt(e), {
                dimensionStyles: i
            } = pt(e), {
                elevationClasses: s
            } = Dt(e), {
                loaderClasses: u
            } = vi(e), {
                locationStyles: c
            } = Jl(e), {
                positionClasses: d
            } = Kr(e), {
                roundedClasses: f
            } = ct(e), {
                sizeClasses: v,
                sizeStyles: g
            } = Wr(e), h = Xl(e, e.symbol, !1), y = Gr(e, n), S = C(() => {
                var V;
                return e.active !== void 0 ? e.active : y.isLink.value ? (V = y.isActive) == null ? void 0 : V.value : h == null ? void 0 : h.isSelected.value
            }), b = C(() => S.value ? e.activeColor ? ? e.color : e.color), p = C(() => {
                var I, R;
                return {
                    color: (h == null ? void 0 : h.isSelected.value) && (!y.isLink.value || ((I = y.isActive) == null ? void 0 : I.value)) || !h || ((R = y.isActive) == null ? void 0 : R.value) ? b.value ? ? e.baseColor : e.baseColor,
                    variant: e.variant
                }
            }), {
                colorClasses: _,
                colorStyles: w,
                variantClasses: k
            } = Gl(p), E = C(() => (h == null ? void 0 : h.disabled.value) || e.disabled), P = C(() => e.variant === "elevated" && !(e.disabled || e.flat || e.border)), x = C(() => {
                if (!(e.value === void 0 || typeof e.value == "symbol")) return Object(e.value) === e.value ? JSON.stringify(e.value, null, 0) : e.value
            });

            function T(V) {
                var I;
                E.value || y.isLink.value && (V.metaKey || V.ctrlKey || V.shiftKey || V.button !== 0 || n.target === "_blank") || ((I = y.navigate) == null || I.call(y, V), h == null || h.toggle())
            }
            return s$(y, h == null ? void 0 : h.select), ne(() => {
                const V = y.isLink.value ? "a" : e.tag,
                    I = !!(e.prependIcon || a.prepend),
                    R = !!(e.appendIcon || a.append),
                    B = !!(e.icon && e.icon !== !0);
                return at(m(V, {
                    type: V === "a" ? void 0 : "button",
                    class: ["v-btn", h == null ? void 0 : h.selectedClass.value, {
                        "v-btn--active": S.value,
                        "v-btn--block": e.block,
                        "v-btn--disabled": E.value,
                        "v-btn--elevated": P.value,
                        "v-btn--flat": e.flat,
                        "v-btn--icon": !!e.icon,
                        "v-btn--loading": e.loading,
                        "v-btn--readonly": e.readonly,
                        "v-btn--slim": e.slim,
                        "v-btn--stacked": e.stacked
                    }, l.value, r.value, _.value, o.value, s.value, u.value, d.value, f.value, v.value, k.value, e.class],
                    style: [w.value, i.value, c.value, g.value, e.style],
                    "aria-busy": e.loading ? !0 : void 0,
                    disabled: E.value || void 0,
                    href: y.href.value,
                    tabindex: e.loading || e.readonly ? -1 : void 0,
                    onClick: T,
                    value: x.value
                }, {
                    default: () => {
                        var $;
                        return [ll(!0, "v-btn"), !e.icon && I && m("span", {
                            key: "prepend",
                            class: "v-btn__prepend"
                        }, [a.prepend ? m(Ve, {
                            key: "prepend-defaults",
                            disabled: !e.prependIcon,
                            defaults: {
                                VIcon: {
                                    icon: e.prependIcon
                                }
                            }
                        }, a.prepend) : m(Be, {
                            key: "prepend-icon",
                            icon: e.prependIcon
                        }, null)]), m("span", {
                            class: "v-btn__content",
                            "data-no-activator": ""
                        }, [!a.default && B ? m(Be, {
                            key: "content-icon",
                            icon: e.icon
                        }, null) : m(Ve, {
                            key: "content-defaults",
                            disabled: !B,
                            defaults: {
                                VIcon: {
                                    icon: e.icon
                                }
                            }
                        }, {
                            default: () => {
                                var D;
                                return [((D = a.default) == null ? void 0 : D.call(a)) ? ? e.text]
                            }
                        })]), !e.icon && R && m("span", {
                            key: "append",
                            class: "v-btn__append"
                        }, [a.append ? m(Ve, {
                            key: "append-defaults",
                            disabled: !e.appendIcon,
                            defaults: {
                                VIcon: {
                                    icon: e.appendIcon
                                }
                            }
                        }, a.append) : m(Be, {
                            key: "append-icon",
                            icon: e.appendIcon
                        }, null)]), !!e.loading && m("span", {
                            key: "loader",
                            class: "v-btn__loader"
                        }, [(($ = a.loader) == null ? void 0 : $.call(a)) ? ? m(Ja, {
                            color: typeof e.loading == "boolean" ? void 0 : e.loading,
                            indeterminate: !0,
                            width: "2"
                        }, null)])]
                    }
                }), [
                    [Ia, !E.value && e.ripple, "", {
                        center: !!e.icon
                    }]
                ])
            }), {
                group: h
            }
        }
    }),
    m$ = W({ ...Ru({
            icon: "$menu",
            variant: "text"
        })
    }, "VAppBarNavIcon"),
    h$ = Z()({
        name: "VAppBarNavIcon",
        props: m$(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            return ne(() => m(Le, te(e, {
                class: ["v-app-bar-nav-icon"]
            }), n)), {}
        }
    }),
    g$ = Z()({
        name: "VAppBarTitle",
        props: RS(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            return ne(() => m(jv, te(e, {
                class: "v-app-bar-title"
            }), n)), {}
        }
    }),
    ZS = oa("v-alert-title"),
    y$ = ["success", "info", "warning", "error"],
    b$ = W({
        border: {
            type: [Boolean, String],
            validator: e => typeof e == "boolean" || ["top", "end", "bottom", "start"].includes(e)
        },
        borderColor: String,
        closable: Boolean,
        closeIcon: {
            type: Pe,
            default: "$close"
        },
        closeLabel: {
            type: String,
            default: "$vuetify.close"
        },
        icon: {
            type: [Boolean, String, Function, Object],
            default: null
        },
        modelValue: {
            type: Boolean,
            default: !0
        },
        prominent: Boolean,
        title: String,
        text: String,
        type: {
            type: String,
            validator: e => y$.includes(e)
        },
        ...Se(),
        ...Vt(),
        ...bt(),
        ...Pt(),
        ...Ea(),
        ...zr(),
        ...rt(),
        ...Ae(),
        ...Ne(),
        ...Rn({
            variant: "flat"
        })
    }, "VAlert"),
    p$ = Z()({
        name: "VAlert",
        props: b$(),
        emits: {
            "click:close": e => !0,
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                emit: n,
                slots: a
            } = t;
            const l = Ce(e, "modelValue"),
                r = C(() => {
                    if (e.icon !== !1) return e.type ? e.icon ? ? `$${e.type}` : e.icon
                }),
                o = C(() => ({
                    color: e.color ? ? e.type,
                    variant: e.variant
                })),
                {
                    themeClasses: i
                } = je(e),
                {
                    colorClasses: s,
                    colorStyles: u,
                    variantClasses: c
                } = Gl(o),
                {
                    densityClasses: d
                } = zt(e),
                {
                    dimensionStyles: f
                } = pt(e),
                {
                    elevationClasses: v
                } = Dt(e),
                {
                    locationStyles: g
                } = Jl(e),
                {
                    positionClasses: h
                } = Kr(e),
                {
                    roundedClasses: y
                } = ct(e),
                {
                    textColorClasses: S,
                    textColorStyles: b
                } = Ot(Y(e, "borderColor")),
                {
                    t: p
                } = Qe(),
                _ = C(() => ({
                    "aria-label": p(e.closeLabel),
                    onClick(w) {
                        l.value = !1, n("click:close", w)
                    }
                }));
            return () => {
                const w = !!(a.prepend || r.value),
                    k = !!(a.title || e.title),
                    E = !!(a.close || e.closable);
                return l.value && m(e.tag, {
                    class: ["v-alert", e.border && {
                        "v-alert--border": !!e.border,
                        [`v-alert--border-${e.border===!0?"start":e.border}`]: !0
                    }, {
                        "v-alert--prominent": e.prominent
                    }, i.value, s.value, d.value, v.value, h.value, y.value, c.value, e.class],
                    style: [u.value, f.value, g.value, e.style],
                    role: "alert"
                }, {
                    default: () => {
                        var P, x;
                        return [ll(!1, "v-alert"), e.border && m("div", {
                            key: "border",
                            class: ["v-alert__border", S.value],
                            style: b.value
                        }, null), w && m("div", {
                            key: "prepend",
                            class: "v-alert__prepend"
                        }, [a.prepend ? m(Ve, {
                            key: "prepend-defaults",
                            disabled: !r.value,
                            defaults: {
                                VIcon: {
                                    density: e.density,
                                    icon: r.value,
                                    size: e.prominent ? 44 : 28
                                }
                            }
                        }, a.prepend) : m(Be, {
                            key: "prepend-icon",
                            density: e.density,
                            icon: r.value,
                            size: e.prominent ? 44 : 28
                        }, null)]), m("div", {
                            class: "v-alert__content"
                        }, [k && m(ZS, {
                            key: "title"
                        }, {
                            default: () => {
                                var T;
                                return [((T = a.title) == null ? void 0 : T.call(a)) ? ? e.title]
                            }
                        }), ((P = a.text) == null ? void 0 : P.call(a)) ? ? e.text, (x = a.default) == null ? void 0 : x.call(a)]), a.append && m("div", {
                            key: "append",
                            class: "v-alert__append"
                        }, [a.append()]), E && m("div", {
                            key: "close",
                            class: "v-alert__close"
                        }, [a.close ? m(Ve, {
                            key: "close-defaults",
                            defaults: {
                                VBtn: {
                                    icon: e.closeIcon,
                                    size: "x-small",
                                    variant: "text"
                                }
                            }
                        }, {
                            default: () => {
                                var T;
                                return [(T = a.close) == null ? void 0 : T.call(a, {
                                    props: _.value
                                })]
                            }
                        }) : m(Le, te({
                            key: "close-btn",
                            icon: e.closeIcon,
                            size: "x-small",
                            variant: "text"
                        }, _.value), null)])]
                    }
                })
            }
        }
    }),
    _$ = W({
        start: Boolean,
        end: Boolean,
        icon: Pe,
        image: String,
        text: String,
        ...an(),
        ...Se(),
        ...Vt(),
        ...rt(),
        ...sa(),
        ...Ae(),
        ...Ne(),
        ...Rn({
            variant: "flat"
        })
    }, "VAvatar"),
    yn = Z()({
        name: "VAvatar",
        props: _$(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                themeClasses: a
            } = je(e), {
                borderClasses: l
            } = Sn(e), {
                colorClasses: r,
                colorStyles: o,
                variantClasses: i
            } = Gl(e), {
                densityClasses: s
            } = zt(e), {
                roundedClasses: u
            } = ct(e), {
                sizeClasses: c,
                sizeStyles: d
            } = Wr(e);
            return ne(() => m(e.tag, {
                class: ["v-avatar", {
                    "v-avatar--start": e.start,
                    "v-avatar--end": e.end
                }, a.value, l.value, r.value, s.value, u.value, c.value, i.value, e.class],
                style: [o.value, d.value, e.style]
            }, {
                default: () => [n.default ? m(Ve, {
                    key: "content-defaults",
                    defaults: {
                        VImg: {
                            cover: !0,
                            src: e.image
                        },
                        VIcon: {
                            icon: e.icon
                        }
                    }
                }, {
                    default: () => [n.default()]
                }) : e.image ? m(Ca, {
                    key: "image",
                    src: e.image,
                    alt: "",
                    cover: !0
                }, null) : e.icon ? m(Be, {
                    key: "icon",
                    icon: e.icon
                }, null) : e.text, ll(!1, "v-avatar")]
            })), {}
        }
    }),
    S$ = W({
        text: String,
        onClick: It(),
        ...Se(),
        ...Ne()
    }, "VLabel"),
    Yr = Z()({
        name: "VLabel",
        props: S$(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            return ne(() => {
                var a;
                return m("label", {
                    class: ["v-label", {
                        "v-label--clickable": !!e.onClick
                    }, e.class],
                    style: e.style,
                    onClick: e.onClick
                }, [e.text, (a = n.default) == null ? void 0 : a.call(n)])
            }), {}
        }
    }),
    QS = Symbol.for("vuetify:selection-control-group"),
    Yv = W({
        color: String,
        disabled: {
            type: Boolean,
            default: null
        },
        defaultsTarget: String,
        error: Boolean,
        id: String,
        inline: Boolean,
        falseIcon: Pe,
        trueIcon: Pe,
        ripple: {
            type: [Boolean, Object],
            default: !0
        },
        multiple: {
            type: Boolean,
            default: null
        },
        name: String,
        readonly: {
            type: Boolean,
            default: null
        },
        modelValue: null,
        type: String,
        valueComparator: {
            type: Function,
            default: la
        },
        ...Se(),
        ...Vt(),
        ...Ne()
    }, "SelectionControlGroup"),
    w$ = W({ ...Yv({
            defaultsTarget: "VSelectionControl"
        })
    }, "VSelectionControlGroup"),
    ew = Z()({
        name: "VSelectionControlGroup",
        props: w$(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Ce(e, "modelValue"),
                l = Rt(),
                r = C(() => e.id || `v-selection-control-group-${l}`),
                o = C(() => e.name || r.value),
                i = new Set;
            return He(QS, {
                modelValue: a,
                forceUpdate: () => {
                    i.forEach(s => s())
                },
                onForceUpdate: s => {
                    i.add(s), kt(() => {
                        i.delete(s)
                    })
                }
            }), lt({
                [e.defaultsTarget]: {
                    color: Y(e, "color"),
                    disabled: Y(e, "disabled"),
                    density: Y(e, "density"),
                    error: Y(e, "error"),
                    inline: Y(e, "inline"),
                    modelValue: a,
                    multiple: C(() => !!e.multiple || e.multiple == null && Array.isArray(a.value)),
                    name: o,
                    falseIcon: Y(e, "falseIcon"),
                    trueIcon: Y(e, "trueIcon"),
                    readonly: Y(e, "readonly"),
                    ripple: Y(e, "ripple"),
                    type: Y(e, "type"),
                    valueComparator: Y(e, "valueComparator")
                }
            }), ne(() => {
                var s;
                return m("div", {
                    class: ["v-selection-control-group", {
                        "v-selection-control-group--inline": e.inline
                    }, e.class],
                    style: e.style,
                    role: e.type === "radio" ? "radiogroup" : void 0
                }, [(s = n.default) == null ? void 0 : s.call(n)])
            }), {}
        }
    }),
    Du = W({
        label: String,
        baseColor: String,
        trueValue: null,
        falseValue: null,
        value: null,
        ...Se(),
        ...Yv()
    }, "VSelectionControl");

function k$(e) {
    const t = Te(QS, void 0),
        {
            densityClasses: n
        } = zt(e),
        a = Ce(e, "modelValue"),
        l = C(() => e.trueValue !== void 0 ? e.trueValue : e.value !== void 0 ? e.value : !0),
        r = C(() => e.falseValue !== void 0 ? e.falseValue : !1),
        o = C(() => !!e.multiple || e.multiple == null && Array.isArray(a.value)),
        i = C({
            get() {
                const v = t ? t.modelValue.value : a.value;
                return o.value ? nt(v).some(g => e.valueComparator(g, l.value)) : e.valueComparator(v, l.value)
            },
            set(v) {
                if (e.readonly) return;
                const g = v ? l.value : r.value;
                let h = g;
                o.value && (h = v ? [...nt(a.value), g] : nt(a.value).filter(y => !e.valueComparator(y, l.value))), t ? t.modelValue.value = h : a.value = h
            }
        }),
        {
            textColorClasses: s,
            textColorStyles: u
        } = Ot(C(() => {
            if (!(e.error || e.disabled)) return i.value ? e.color : e.baseColor
        })),
        {
            backgroundColorClasses: c,
            backgroundColorStyles: d
        } = Ke(C(() => i.value && !e.error && !e.disabled ? e.color : e.baseColor)),
        f = C(() => i.value ? e.trueIcon : e.falseIcon);
    return {
        group: t,
        densityClasses: n,
        trueValue: l,
        falseValue: r,
        model: i,
        textColorClasses: s,
        textColorStyles: u,
        backgroundColorClasses: c,
        backgroundColorStyles: d,
        icon: f
    }
}
const Za = Z()({
        name: "VSelectionControl",
        directives: {
            Ripple: Ia
        },
        inheritAttrs: !1,
        props: Du(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                attrs: n,
                slots: a
            } = t;
            const {
                group: l,
                densityClasses: r,
                icon: o,
                model: i,
                textColorClasses: s,
                textColorStyles: u,
                backgroundColorClasses: c,
                backgroundColorStyles: d,
                trueValue: f
            } = k$(e), v = Rt(), g = fe(!1), h = fe(!1), y = Q(), S = C(() => e.id || `input-${v}`), b = C(() => !e.disabled && !e.readonly);
            l == null || l.onForceUpdate(() => {
                y.value && (y.value.checked = i.value)
            });

            function p(E) {
                b.value && (g.value = !0, Or(E.target, ":focus-visible") !== !1 && (h.value = !0))
            }

            function _() {
                g.value = !1, h.value = !1
            }

            function w(E) {
                E.stopPropagation()
            }

            function k(E) {
                if (!b.value) {
                    y.value && (y.value.checked = i.value);
                    return
                }
                e.readonly && l && Re(() => l.forceUpdate()), i.value = E.target.checked
            }
            return ne(() => {
                var V, I;
                const E = a.label ? a.label({
                        label: e.label,
                        props: {
                            for: S.value
                        }
                    }) : e.label,
                    [P, x] = al(n),
                    T = m("input", te({
                        ref: y,
                        checked: i.value,
                        disabled: !!e.disabled,
                        id: S.value,
                        onBlur: _,
                        onFocus: p,
                        onInput: k,
                        "aria-disabled": !!e.disabled,
                        "aria-label": e.label,
                        type: e.type,
                        value: f.value,
                        name: e.name,
                        "aria-checked": e.type === "checkbox" ? i.value : void 0
                    }, x), null);
                return m("div", te({
                    class: ["v-selection-control", {
                        "v-selection-control--dirty": i.value,
                        "v-selection-control--disabled": e.disabled,
                        "v-selection-control--error": e.error,
                        "v-selection-control--focused": g.value,
                        "v-selection-control--focus-visible": h.value,
                        "v-selection-control--inline": e.inline
                    }, r.value, e.class]
                }, P, {
                    style: e.style
                }), [m("div", {
                    class: ["v-selection-control__wrapper", s.value],
                    style: u.value
                }, [(V = a.default) == null ? void 0 : V.call(a, {
                    backgroundColorClasses: c,
                    backgroundColorStyles: d
                }), at(m("div", {
                    class: ["v-selection-control__input"]
                }, [((I = a.input) == null ? void 0 : I.call(a, {
                    model: i,
                    textColorClasses: s,
                    textColorStyles: u,
                    backgroundColorClasses: c,
                    backgroundColorStyles: d,
                    inputNode: T,
                    icon: o.value,
                    props: {
                        onFocus: p,
                        onBlur: _,
                        id: S.value
                    }
                })) ? ? m(ye, null, [o.value && m(Be, {
                    key: "icon",
                    icon: o.value
                }, null), T])]), [
                    [tn("ripple"), e.ripple && [!e.disabled && !e.readonly, null, ["center", "circle"]]]
                ])]), E && m(Yr, {
                    for: S.value,
                    onClick: w
                }, {
                    default: () => [E]
                })])
            }), {
                isFocused: g,
                input: y
            }
        }
    }),
    tw = W({
        indeterminate: Boolean,
        indeterminateIcon: {
            type: Pe,
            default: "$checkboxIndeterminate"
        },
        ...Du({
            falseIcon: "$checkboxOff",
            trueIcon: "$checkboxOn"
        })
    }, "VCheckboxBtn"),
    Qn = Z()({
        name: "VCheckboxBtn",
        props: tw(),
        emits: {
            "update:modelValue": e => !0,
            "update:indeterminate": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Ce(e, "indeterminate"),
                l = Ce(e, "modelValue");

            function r(s) {
                a.value && (a.value = !1)
            }
            const o = C(() => a.value ? e.indeterminateIcon : e.falseIcon),
                i = C(() => a.value ? e.indeterminateIcon : e.trueIcon);
            return ne(() => {
                const s = We(Za.filterProps(e), ["modelValue"]);
                return m(Za, te(s, {
                    modelValue: l.value,
                    "onUpdate:modelValue": [u => l.value = u, r],
                    class: ["v-checkbox-btn", e.class],
                    style: e.style,
                    type: "checkbox",
                    falseIcon: o.value,
                    trueIcon: i.value,
                    "aria-checked": a.value ? "mixed" : void 0
                }), n)
            }), {}
        }
    });

function nw(e) {
    const {
        t
    } = Qe();

    function n(a) {
        let {
            name: l
        } = a;
        const r = {
                prepend: "prependAction",
                prependInner: "prependAction",
                append: "appendAction",
                appendInner: "appendAction",
                clear: "clear"
            }[l],
            o = e[`onClick:${l}`],
            i = o && r ? t(`$vuetify.input.${r}`, e.label ? ? "") : void 0;
        return m(Be, {
            icon: e[`${l}Icon`],
            "aria-label": i,
            onClick: o
        }, null)
    }
    return {
        InputIcon: n
    }
}
const C$ = W({
        active: Boolean,
        color: String,
        messages: {
            type: [Array, String],
            default: () => []
        },
        ...Se(),
        ...Wn({
            transition: {
                component: Wv,
                leaveAbsolute: !0,
                group: !0
            }
        })
    }, "VMessages"),
    aw = Z()({
        name: "VMessages",
        props: C$(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = C(() => nt(e.messages)),
                {
                    textColorClasses: l,
                    textColorStyles: r
                } = Ot(C(() => e.color));
            return ne(() => m(jt, {
                transition: e.transition,
                tag: "div",
                class: ["v-messages", l.value, e.class],
                style: [r.value, e.style],
                role: "alert",
                "aria-live": "polite"
            }, {
                default: () => [e.active && a.value.map((o, i) => m("div", {
                    class: "v-messages__message",
                    key: `${i}-${a.value}`
                }, [n.message ? n.message({
                    message: o
                }) : o]))]
            })), {}
        }
    }),
    qr = W({
        focused: Boolean,
        "onUpdate:focused": It()
    }, "focus");

function ua(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ra();
    const n = Ce(e, "focused"),
        a = C(() => ({
            [`${t}--focused`]: n.value
        }));

    function l() {
        n.value = !0
    }

    function r() {
        n.value = !1
    }
    return {
        focusClasses: a,
        isFocused: n,
        focus: l,
        blur: r
    }
}
const lw = Symbol.for("vuetify:form"),
    x$ = W({
        disabled: Boolean,
        fastFail: Boolean,
        readonly: Boolean,
        modelValue: {
            type: Boolean,
            default: null
        },
        validateOn: {
            type: String,
            default: "input"
        }
    }, "form");

function P$(e) {
    const t = Ce(e, "modelValue"),
        n = C(() => e.disabled),
        a = C(() => e.readonly),
        l = fe(!1),
        r = Q([]),
        o = Q([]);
    async function i() {
        const c = [];
        let d = !0;
        o.value = [], l.value = !0;
        for (const f of r.value) {
            const v = await f.validate();
            if (v.length > 0 && (d = !1, c.push({
                    id: f.id,
                    errorMessages: v
                })), !d && e.fastFail) break
        }
        return o.value = c, l.value = !1, {
            valid: d,
            errors: o.value
        }
    }

    function s() {
        r.value.forEach(c => c.reset())
    }

    function u() {
        r.value.forEach(c => c.resetValidation())
    }
    return de(r, () => {
        let c = 0,
            d = 0;
        const f = [];
        for (const v of r.value) v.isValid === !1 ? (d++, f.push({
            id: v.id,
            errorMessages: v.errorMessages
        })) : v.isValid === !0 && c++;
        o.value = f, t.value = d > 0 ? !1 : c === r.value.length ? !0 : null
    }, {
        deep: !0,
        flush: "post"
    }), He(lw, {
        register: c => {
            let {
                id: d,
                vm: f,
                validate: v,
                reset: g,
                resetValidation: h
            } = c;
            r.value.some(y => y.id === d), r.value.push({
                id: d,
                validate: v,
                reset: g,
                resetValidation: h,
                vm: Fr(f),
                isValid: null,
                errorMessages: []
            })
        },
        unregister: c => {
            r.value = r.value.filter(d => d.id !== c)
        },
        update: (c, d, f) => {
            const v = r.value.find(g => g.id === c);
            v && (v.isValid = d, v.errorMessages = f)
        },
        isDisabled: n,
        isReadonly: a,
        isValidating: l,
        isValid: t,
        items: r,
        validateOn: Y(e, "validateOn")
    }), {
        errors: o,
        isDisabled: n,
        isReadonly: a,
        isValidating: l,
        isValid: t,
        items: r,
        validate: i,
        reset: s,
        resetValidation: u
    }
}

function gi() {
    return Te(lw, null)
}
const rw = W({
    disabled: {
        type: Boolean,
        default: null
    },
    error: Boolean,
    errorMessages: {
        type: [Array, String],
        default: () => []
    },
    maxErrors: {
        type: [Number, String],
        default: 1
    },
    name: String,
    label: String,
    readonly: {
        type: Boolean,
        default: null
    },
    rules: {
        type: Array,
        default: () => []
    },
    modelValue: null,
    validateOn: String,
    validationValue: null,
    ...qr()
}, "validation");

function ow(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ra(),
        n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Rt();
    const a = Ce(e, "modelValue"),
        l = C(() => e.validationValue === void 0 ? a.value : e.validationValue),
        r = gi(),
        o = Q([]),
        i = fe(!0),
        s = C(() => !!(nt(a.value === "" ? null : a.value).length || nt(l.value === "" ? null : l.value).length)),
        u = C(() => !!(e.disabled ? ? (r == null ? void 0 : r.isDisabled.value))),
        c = C(() => !!(e.readonly ? ? (r == null ? void 0 : r.isReadonly.value))),
        d = C(() => {
            var w;
            return (w = e.errorMessages) != null && w.length ? nt(e.errorMessages).concat(o.value).slice(0, Math.max(0, +e.maxErrors)) : o.value
        }),
        f = C(() => {
            let w = (e.validateOn ? ? (r == null ? void 0 : r.validateOn.value)) || "input";
            w === "lazy" && (w = "input lazy"), w === "eager" && (w = "input eager");
            const k = new Set((w == null ? void 0 : w.split(" ")) ? ? []);
            return {
                input: k.has("input"),
                blur: k.has("blur") || k.has("input") || k.has("invalid-input"),
                invalidInput: k.has("invalid-input"),
                lazy: k.has("lazy"),
                eager: k.has("eager")
            }
        }),
        v = C(() => {
            var w;
            return e.error || (w = e.errorMessages) != null && w.length ? !1 : e.rules.length ? i.value ? o.value.length || f.value.lazy ? null : !0 : !o.value.length : !0
        }),
        g = fe(!1),
        h = C(() => ({
            [`${t}--error`]: v.value === !1,
            [`${t}--dirty`]: s.value,
            [`${t}--disabled`]: u.value,
            [`${t}--readonly`]: c.value
        })),
        y = ut("validation"),
        S = C(() => e.name ? ? Ie(n));
    tu(() => {
        r == null || r.register({
            id: S.value,
            vm: y,
            validate: _,
            reset: b,
            resetValidation: p
        })
    }), Ct(() => {
        r == null || r.unregister(S.value)
    }), it(async () => {
        f.value.lazy || await _(!f.value.eager), r == null || r.update(S.value, v.value, d.value)
    }), Yt(() => f.value.input || f.value.invalidInput && v.value === !1, () => {
        de(l, () => {
            if (l.value != null) _();
            else if (e.focused) {
                const w = de(() => e.focused, k => {
                    k || _(), w()
                })
            }
        })
    }), Yt(() => f.value.blur, () => {
        de(() => e.focused, w => {
            w || _()
        })
    }), de([v, d], () => {
        r == null || r.update(S.value, v.value, d.value)
    });
    async function b() {
        a.value = null, await Re(), await p()
    }
    async function p() {
        i.value = !0, f.value.lazy ? o.value = [] : await _(!f.value.eager)
    }
    async function _() {
        let w = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
        const k = [];
        g.value = !0;
        for (const E of e.rules) {
            if (k.length >= +(e.maxErrors ? ? 1)) break;
            const x = await (typeof E == "function" ? E : () => E)(l.value);
            if (x !== !0) {
                if (x !== !1 && typeof x != "string") {
                    console.warn(`${x} is not a valid value. Rule functions must return boolean true or a string.`);
                    continue
                }
                k.push(x || "")
            }
        }
        return o.value = k, g.value = !1, i.value = w, o.value
    }
    return {
        errorMessages: d,
        isDirty: s,
        isDisabled: u,
        isReadonly: c,
        isPristine: i,
        isValid: v,
        isValidating: g,
        reset: b,
        resetValidation: p,
        validate: _,
        validationClasses: h
    }
}
const Ta = W({
        id: String,
        appendIcon: Pe,
        centerAffix: {
            type: Boolean,
            default: !0
        },
        prependIcon: Pe,
        hideDetails: [Boolean, String],
        hideSpinButtons: Boolean,
        hint: String,
        persistentHint: Boolean,
        messages: {
            type: [Array, String],
            default: () => []
        },
        direction: {
            type: String,
            default: "horizontal",
            validator: e => ["horizontal", "vertical"].includes(e)
        },
        "onClick:prepend": It(),
        "onClick:append": It(),
        ...Se(),
        ...Vt(),
        ...wu(bt(), ["maxWidth", "minWidth", "width"]),
        ...Ne(),
        ...rw()
    }, "VInput"),
    $t = Z()({
        name: "VInput",
        props: { ...Ta()
        },
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                attrs: n,
                slots: a,
                emit: l
            } = t;
            const {
                densityClasses: r
            } = zt(e), {
                dimensionStyles: o
            } = pt(e), {
                themeClasses: i
            } = je(e), {
                rtlClasses: s
            } = xt(), {
                InputIcon: u
            } = nw(e), c = Rt(), d = C(() => e.id || `input-${c}`), f = C(() => `${d.value}-messages`), {
                errorMessages: v,
                isDirty: g,
                isDisabled: h,
                isReadonly: y,
                isPristine: S,
                isValid: b,
                isValidating: p,
                reset: _,
                resetValidation: w,
                validate: k,
                validationClasses: E
            } = ow(e, "v-input", d), P = C(() => ({
                id: d,
                messagesId: f,
                isDirty: g,
                isDisabled: h,
                isReadonly: y,
                isPristine: S,
                isValid: b,
                isValidating: p,
                reset: _,
                resetValidation: w,
                validate: k
            })), x = C(() => {
                var T;
                return (T = e.errorMessages) != null && T.length || !S.value && v.value.length ? v.value : e.hint && (e.persistentHint || e.focused) ? e.hint : e.messages
            });
            return ne(() => {
                var B, $, D, z;
                const T = !!(a.prepend || e.prependIcon),
                    V = !!(a.append || e.appendIcon),
                    I = x.value.length > 0,
                    R = !e.hideDetails || e.hideDetails === "auto" && (I || !!a.details);
                return m("div", {
                    class: ["v-input", `v-input--${e.direction}`, {
                        "v-input--center-affix": e.centerAffix,
                        "v-input--hide-spin-buttons": e.hideSpinButtons
                    }, r.value, i.value, s.value, E.value, e.class],
                    style: [o.value, e.style]
                }, [T && m("div", {
                    key: "prepend",
                    class: "v-input__prepend"
                }, [(B = a.prepend) == null ? void 0 : B.call(a, P.value), e.prependIcon && m(u, {
                    key: "prepend-icon",
                    name: "prepend"
                }, null)]), a.default && m("div", {
                    class: "v-input__control"
                }, [($ = a.default) == null ? void 0 : $.call(a, P.value)]), V && m("div", {
                    key: "append",
                    class: "v-input__append"
                }, [e.appendIcon && m(u, {
                    key: "append-icon",
                    name: "append"
                }, null), (D = a.append) == null ? void 0 : D.call(a, P.value)]), R && m("div", {
                    class: "v-input__details"
                }, [m(aw, {
                    id: f.value,
                    active: I,
                    messages: x.value
                }, {
                    message: a.message
                }), (z = a.details) == null ? void 0 : z.call(a, P.value)])])
            }), {
                reset: _,
                resetValidation: w,
                validate: k,
                isValid: b,
                errorMessages: v
            }
        }
    }),
    E$ = W({ ...Ta(),
        ...We(tw(), ["inline"])
    }, "VCheckbox"),
    I$ = Z()({
        name: "VCheckbox",
        inheritAttrs: !1,
        props: E$(),
        emits: {
            "update:modelValue": e => !0,
            "update:focused": e => !0
        },
        setup(e, t) {
            let {
                attrs: n,
                slots: a
            } = t;
            const l = Ce(e, "modelValue"),
                {
                    isFocused: r,
                    focus: o,
                    blur: i
                } = ua(e),
                s = Rt(),
                u = C(() => e.id || `checkbox-${s}`);
            return ne(() => {
                const [c, d] = al(n), f = $t.filterProps(e), v = Qn.filterProps(e);
                return m($t, te({
                    class: ["v-checkbox", e.class]
                }, c, f, {
                    modelValue: l.value,
                    "onUpdate:modelValue": g => l.value = g,
                    id: u.value,
                    focused: r.value,
                    style: e.style
                }), { ...a,
                    default: g => {
                        let {
                            id: h,
                            messagesId: y,
                            isDisabled: S,
                            isReadonly: b,
                            isValid: p
                        } = g;
                        return m(Qn, te(v, {
                            id: h.value,
                            "aria-describedby": y.value,
                            disabled: S.value,
                            readonly: b.value
                        }, d, {
                            error: p.value === !1,
                            modelValue: l.value,
                            "onUpdate:modelValue": _ => l.value = _,
                            onFocus: o,
                            onBlur: i
                        }), a)
                    }
                })
            }), {}
        }
    });

function T$(e) {
    let {
        selectedElement: t,
        containerElement: n,
        isRtl: a,
        isHorizontal: l
    } = e;
    const r = zo(l, n),
        o = iw(l, a, n),
        i = zo(l, t),
        s = sw(l, t),
        u = i * .4;
    return o > s ? s - u : o + r < s + i ? s - r + i + u : o
}

function V$(e) {
    let {
        selectedElement: t,
        containerElement: n,
        isHorizontal: a
    } = e;
    const l = zo(a, n),
        r = sw(a, t),
        o = zo(a, t);
    return r - l / 2 + o / 2
}

function Hy(e, t) {
    const n = e ? "scrollWidth" : "scrollHeight";
    return (t == null ? void 0 : t[n]) || 0
}

function A$(e, t) {
    const n = e ? "clientWidth" : "clientHeight";
    return (t == null ? void 0 : t[n]) || 0
}

function iw(e, t, n) {
    if (!n) return 0;
    const {
        scrollLeft: a,
        offsetWidth: l,
        scrollWidth: r
    } = n;
    return e ? t ? r - l + a : a : n.scrollTop
}

function zo(e, t) {
    const n = e ? "offsetWidth" : "offsetHeight";
    return (t == null ? void 0 : t[n]) || 0
}

function sw(e, t) {
    const n = e ? "offsetLeft" : "offsetTop";
    return (t == null ? void 0 : t[n]) || 0
}
const uw = Symbol.for("vuetify:v-slide-group"),
    qv = W({
        centerActive: Boolean,
        direction: {
            type: String,
            default: "horizontal"
        },
        symbol: {
            type: null,
            default: uw
        },
        nextIcon: {
            type: Pe,
            default: "$next"
        },
        prevIcon: {
            type: Pe,
            default: "$prev"
        },
        showArrows: {
            type: [Boolean, String],
            validator: e => typeof e == "boolean" || ["always", "desktop", "mobile"].includes(e)
        },
        ...Se(),
        ...Ul({
            mobile: null
        }),
        ...Ae(),
        ...Yl({
            selectedClass: "v-slide-group-item--active"
        })
    }, "VSlideGroup"),
    Ko = Z()({
        name: "VSlideGroup",
        props: qv(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                isRtl: a
            } = xt(), {
                displayClasses: l,
                mobile: r
            } = On(e), o = rl(e, e.symbol), i = fe(!1), s = fe(0), u = fe(0), c = fe(0), d = C(() => e.direction === "horizontal"), {
                resizeRef: f,
                contentRect: v
            } = Hn(), {
                resizeRef: g,
                contentRect: h
            } = Hn(), y = hN(), S = C(() => ({
                container: f.el,
                duration: 200,
                easing: "easeOutQuart"
            })), b = C(() => o.selected.value.length ? o.items.value.findIndex(F => F.id === o.selected.value[0]) : -1), p = C(() => o.selected.value.length ? o.items.value.findIndex(F => F.id === o.selected.value[o.selected.value.length - 1]) : -1);
            if (Ue) {
                let F = -1;
                de(() => [o.selected.value, v.value, h.value, d.value], () => {
                    cancelAnimationFrame(F), F = requestAnimationFrame(() => {
                        if (v.value && h.value) {
                            const j = d.value ? "width" : "height";
                            u.value = v.value[j], c.value = h.value[j], i.value = u.value + 1 < c.value
                        }
                        if (b.value >= 0 && g.el) {
                            const j = g.el.children[p.value];
                            w(j, e.centerActive)
                        }
                    })
                })
            }
            const _ = fe(!1);

            function w(F, j) {
                let ae = 0;
                j ? ae = V$({
                    containerElement: f.el,
                    isHorizontal: d.value,
                    selectedElement: F
                }) : ae = T$({
                    containerElement: f.el,
                    isHorizontal: d.value,
                    isRtl: a.value,
                    selectedElement: F
                }), k(ae)
            }

            function k(F) {
                if (!Ue || !f.el) return;
                const j = zo(d.value, f.el),
                    ae = iw(d.value, a.value, f.el);
                if (!(Hy(d.value, f.el) <= j || Math.abs(F - ae) < 16)) {
                    if (d.value && a.value && f.el) {
                        const {
                            scrollWidth: ve,
                            offsetWidth: we
                        } = f.el;
                        F = ve - we - F
                    }
                    d.value ? y.horizontal(F, S.value) : y(F, S.value)
                }
            }

            function E(F) {
                const {
                    scrollTop: j,
                    scrollLeft: ae
                } = F.target;
                s.value = d.value ? ae : j
            }

            function P(F) {
                if (_.value = !0, !(!i.value || !g.el)) {
                    for (const j of F.composedPath())
                        for (const ae of g.el.children)
                            if (ae === j) {
                                w(ae);
                                return
                            }
                }
            }

            function x(F) {
                _.value = !1
            }
            let T = !1;

            function V(F) {
                var j;
                !T && !_.value && !(F.relatedTarget && ((j = g.el) != null && j.contains(F.relatedTarget))) && B(), T = !1
            }

            function I() {
                T = !0
            }

            function R(F) {
                if (!g.el) return;

                function j(ae) {
                    F.preventDefault(), B(ae)
                }
                d.value ? F.key === "ArrowRight" ? j(a.value ? "prev" : "next") : F.key === "ArrowLeft" && j(a.value ? "next" : "prev") : F.key === "ArrowDown" ? j("next") : F.key === "ArrowUp" && j("prev"), F.key === "Home" ? j("first") : F.key === "End" && j("last")
            }

            function B(F) {
                var ae, he;
                if (!g.el) return;
                let j;
                if (!F) j = No(g.el)[0];
                else if (F === "next") {
                    if (j = (ae = g.el.querySelector(":focus")) == null ? void 0 : ae.nextElementSibling, !j) return B("first")
                } else if (F === "prev") {
                    if (j = (he = g.el.querySelector(":focus")) == null ? void 0 : he.previousElementSibling, !j) return B("last")
                } else F === "first" ? j = g.el.firstElementChild : F === "last" && (j = g.el.lastElementChild);
                j && j.focus({
                    preventScroll: !0
                })
            }

            function $(F) {
                const j = d.value && a.value ? -1 : 1,
                    ae = (F === "prev" ? -j : j) * u.value;
                let he = s.value + ae;
                if (d.value && a.value && f.el) {
                    const {
                        scrollWidth: ve,
                        offsetWidth: we
                    } = f.el;
                    he += ve - we
                }
                k(he)
            }
            const D = C(() => ({
                    next: o.next,
                    prev: o.prev,
                    select: o.select,
                    isSelected: o.isSelected
                })),
                z = C(() => {
                    switch (e.showArrows) {
                        case "always":
                            return !0;
                        case "desktop":
                            return !r.value;
                        case !0:
                            return i.value || Math.abs(s.value) > 0;
                        case "mobile":
                            return r.value || i.value || Math.abs(s.value) > 0;
                        default:
                            return !r.value && (i.value || Math.abs(s.value) > 0)
                    }
                }),
                N = C(() => Math.abs(s.value) > 1),
                H = C(() => {
                    if (!f.value) return !1;
                    const F = Hy(d.value, f.el),
                        j = A$(d.value, f.el);
                    return F - j - Math.abs(s.value) > 1
                });
            return ne(() => m(e.tag, {
                class: ["v-slide-group", {
                    "v-slide-group--vertical": !d.value,
                    "v-slide-group--has-affixes": z.value,
                    "v-slide-group--is-overflowing": i.value
                }, l.value, e.class],
                style: e.style,
                tabindex: _.value || o.selected.value.length ? -1 : 0,
                onFocus: V
            }, {
                default: () => {
                    var F, j, ae;
                    return [z.value && m("div", {
                        key: "prev",
                        class: ["v-slide-group__prev", {
                            "v-slide-group__prev--disabled": !N.value
                        }],
                        onMousedown: I,
                        onClick: () => N.value && $("prev")
                    }, [((F = n.prev) == null ? void 0 : F.call(n, D.value)) ? ? m(jo, null, {
                        default: () => [m(Be, {
                            icon: a.value ? e.nextIcon : e.prevIcon
                        }, null)]
                    })]), m("div", {
                        key: "container",
                        ref: f,
                        class: "v-slide-group__container",
                        onScroll: E
                    }, [m("div", {
                        ref: g,
                        class: "v-slide-group__content",
                        onFocusin: P,
                        onFocusout: x,
                        onKeydown: R
                    }, [(j = n.default) == null ? void 0 : j.call(n, D.value)])]), z.value && m("div", {
                        key: "next",
                        class: ["v-slide-group__next", {
                            "v-slide-group__next--disabled": !H.value
                        }],
                        onMousedown: I,
                        onClick: () => H.value && $("next")
                    }, [((ae = n.next) == null ? void 0 : ae.call(n, D.value)) ? ? m(jo, null, {
                        default: () => [m(Be, {
                            icon: a.value ? e.prevIcon : e.nextIcon
                        }, null)]
                    })])]
                }
            })), {
                selected: o.selected,
                scrollTo: $,
                scrollOffset: s,
                focus: B,
                hasPrev: N,
                hasNext: H
            }
        }
    }),
    cw = Symbol.for("vuetify:v-chip-group"),
    L$ = W({
        column: Boolean,
        filter: Boolean,
        valueComparator: {
            type: Function,
            default: la
        },
        ...qv(),
        ...Se(),
        ...Yl({
            selectedClass: "v-chip--selected"
        }),
        ...Ae(),
        ...Ne(),
        ...Rn({
            variant: "tonal"
        })
    }, "VChipGroup"),
    O$ = Z()({
        name: "VChipGroup",
        props: L$(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                themeClasses: a
            } = je(e), {
                isSelected: l,
                select: r,
                next: o,
                prev: i,
                selected: s
            } = rl(e, cw);
            return lt({
                VChip: {
                    color: Y(e, "color"),
                    disabled: Y(e, "disabled"),
                    filter: Y(e, "filter"),
                    variant: Y(e, "variant")
                }
            }), ne(() => {
                const u = Ko.filterProps(e);
                return m(Ko, te(u, {
                    class: ["v-chip-group", {
                        "v-chip-group--column": e.column
                    }, a.value, e.class],
                    style: e.style
                }), {
                    default: () => {
                        var c;
                        return [(c = n.default) == null ? void 0 : c.call(n, {
                            isSelected: l,
                            select: r,
                            next: o,
                            prev: i,
                            selected: s.value
                        })]
                    }
                })
            }), {}
        }
    }),
    R$ = W({
        activeClass: String,
        appendAvatar: String,
        appendIcon: Pe,
        closable: Boolean,
        closeIcon: {
            type: Pe,
            default: "$delete"
        },
        closeLabel: {
            type: String,
            default: "$vuetify.close"
        },
        draggable: Boolean,
        filter: Boolean,
        filterIcon: {
            type: String,
            default: "$complete"
        },
        label: Boolean,
        link: {
            type: Boolean,
            default: void 0
        },
        pill: Boolean,
        prependAvatar: String,
        prependIcon: Pe,
        ripple: {
            type: [Boolean, Object],
            default: !0
        },
        text: String,
        modelValue: {
            type: Boolean,
            default: !0
        },
        onClick: It(),
        onClickOnce: It(),
        ...an(),
        ...Se(),
        ...Vt(),
        ...Pt(),
        ...ql(),
        ...rt(),
        ...hi(),
        ...sa(),
        ...Ae({
            tag: "span"
        }),
        ...Ne(),
        ...Rn({
            variant: "tonal"
        })
    }, "VChip"),
    Zl = Z()({
        name: "VChip",
        directives: {
            Ripple: Ia
        },
        props: R$(),
        emits: {
            "click:close": e => !0,
            "update:modelValue": e => !0,
            "group:selected": e => !0,
            click: e => !0
        },
        setup(e, t) {
            let {
                attrs: n,
                emit: a,
                slots: l
            } = t;
            const {
                t: r
            } = Qe(), {
                borderClasses: o
            } = Sn(e), {
                colorClasses: i,
                colorStyles: s,
                variantClasses: u
            } = Gl(e), {
                densityClasses: c
            } = zt(e), {
                elevationClasses: d
            } = Dt(e), {
                roundedClasses: f
            } = ct(e), {
                sizeClasses: v
            } = Wr(e), {
                themeClasses: g
            } = je(e), h = Ce(e, "modelValue"), y = Xl(e, cw, !1), S = Gr(e, n), b = C(() => e.link !== !1 && S.isLink.value), p = C(() => !e.disabled && e.link !== !1 && (!!y || e.link || S.isClickable.value)), _ = C(() => ({
                "aria-label": r(e.closeLabel),
                onClick(E) {
                    E.preventDefault(), E.stopPropagation(), h.value = !1, a("click:close", E)
                }
            }));

            function w(E) {
                var P;
                a("click", E), p.value && ((P = S.navigate) == null || P.call(S, E), y == null || y.toggle())
            }

            function k(E) {
                (E.key === "Enter" || E.key === " ") && (E.preventDefault(), w(E))
            }
            return () => {
                const E = S.isLink.value ? "a" : e.tag,
                    P = !!(e.appendIcon || e.appendAvatar),
                    x = !!(P || l.append),
                    T = !!(l.close || e.closable),
                    V = !!(l.filter || e.filter) && y,
                    I = !!(e.prependIcon || e.prependAvatar),
                    R = !!(I || l.prepend),
                    B = !y || y.isSelected.value;
                return h.value && at(m(E, {
                    class: ["v-chip", {
                        "v-chip--disabled": e.disabled,
                        "v-chip--label": e.label,
                        "v-chip--link": p.value,
                        "v-chip--filter": V,
                        "v-chip--pill": e.pill
                    }, g.value, o.value, B ? i.value : void 0, c.value, d.value, f.value, v.value, u.value, y == null ? void 0 : y.selectedClass.value, e.class],
                    style: [B ? s.value : void 0, e.style],
                    disabled: e.disabled || void 0,
                    draggable: e.draggable,
                    href: S.href.value,
                    tabindex: p.value ? 0 : void 0,
                    onClick: w,
                    onKeydown: p.value && !b.value && k
                }, {
                    default: () => {
                        var $;
                        return [ll(p.value, "v-chip"), V && m(zv, {
                            key: "filter"
                        }, {
                            default: () => [at(m("div", {
                                class: "v-chip__filter"
                            }, [l.filter ? m(Ve, {
                                key: "filter-defaults",
                                disabled: !e.filterIcon,
                                defaults: {
                                    VIcon: {
                                        icon: e.filterIcon
                                    }
                                }
                            }, l.filter) : m(Be, {
                                key: "filter-icon",
                                icon: e.filterIcon
                            }, null)]), [
                                [bn, y.isSelected.value]
                            ])]
                        }), R && m("div", {
                            key: "prepend",
                            class: "v-chip__prepend"
                        }, [l.prepend ? m(Ve, {
                            key: "prepend-defaults",
                            disabled: !I,
                            defaults: {
                                VAvatar: {
                                    image: e.prependAvatar,
                                    start: !0
                                },
                                VIcon: {
                                    icon: e.prependIcon,
                                    start: !0
                                }
                            }
                        }, l.prepend) : m(ye, null, [e.prependIcon && m(Be, {
                            key: "prepend-icon",
                            icon: e.prependIcon,
                            start: !0
                        }, null), e.prependAvatar && m(yn, {
                            key: "prepend-avatar",
                            image: e.prependAvatar,
                            start: !0
                        }, null)])]), m("div", {
                            class: "v-chip__content",
                            "data-no-activator": ""
                        }, [(($ = l.default) == null ? void 0 : $.call(l, {
                            isSelected: y == null ? void 0 : y.isSelected.value,
                            selectedClass: y == null ? void 0 : y.selectedClass.value,
                            select: y == null ? void 0 : y.select,
                            toggle: y == null ? void 0 : y.toggle,
                            value: y == null ? void 0 : y.value.value,
                            disabled: e.disabled
                        })) ? ? e.text]), x && m("div", {
                            key: "append",
                            class: "v-chip__append"
                        }, [l.append ? m(Ve, {
                            key: "append-defaults",
                            disabled: !P,
                            defaults: {
                                VAvatar: {
                                    end: !0,
                                    image: e.appendAvatar
                                },
                                VIcon: {
                                    end: !0,
                                    icon: e.appendIcon
                                }
                            }
                        }, l.append) : m(ye, null, [e.appendIcon && m(Be, {
                            key: "append-icon",
                            end: !0,
                            icon: e.appendIcon
                        }, null), e.appendAvatar && m(yn, {
                            key: "append-avatar",
                            end: !0,
                            image: e.appendAvatar
                        }, null)])]), T && m("button", te({
                            key: "close",
                            class: "v-chip__close",
                            type: "button"
                        }, _.value), [l.close ? m(Ve, {
                            key: "close-defaults",
                            defaults: {
                                VIcon: {
                                    icon: e.closeIcon,
                                    size: "x-small"
                                }
                            }
                        }, l.close) : m(Be, {
                            key: "close-icon",
                            icon: e.closeIcon,
                            size: "x-small"
                        }, null)])]
                    }
                }), [
                    [tn("ripple"), p.value && e.ripple, null]
                ])
            }
        }
    }),
    Kd = Symbol.for("vuetify:list");

function dw() {
    const e = Te(Kd, {
            hasPrepend: fe(!1),
            updateHasPrepend: () => null
        }),
        t = {
            hasPrepend: fe(!1),
            updateHasPrepend: n => {
                n && (t.hasPrepend.value = n)
            }
        };
    return He(Kd, t), e
}

function fw() {
    return Te(Kd, null)
}
const Xv = e => {
        const t = {
            activate: n => {
                let {
                    id: a,
                    value: l,
                    activated: r
                } = n;
                return a = xe(a), e && !l && r.size === 1 && r.has(a) || (l ? r.add(a) : r.delete(a)), r
            },
            in: (n, a, l) => {
                let r = new Set;
                if (n != null)
                    for (const o of nt(n)) r = t.activate({
                        id: o,
                        value: !0,
                        activated: new Set(r),
                        children: a,
                        parents: l
                    });
                return r
            },
            out: n => Array.from(n)
        };
        return t
    },
    vw = e => {
        const t = Xv(e);
        return {
            activate: a => {
                let {
                    activated: l,
                    id: r,
                    ...o
                } = a;
                r = xe(r);
                const i = l.has(r) ? new Set([r]) : new Set;
                return t.activate({ ...o,
                    id: r,
                    activated: i
                })
            },
            in: (a, l, r) => {
                let o = new Set;
                if (a != null) {
                    const i = nt(a);
                    i.length && (o = t.in(i.slice(0, 1), l, r))
                }
                return o
            },
            out: (a, l, r) => t.out(a, l, r)
        }
    },
    D$ = e => {
        const t = Xv(e);
        return {
            activate: a => {
                let {
                    id: l,
                    activated: r,
                    children: o,
                    ...i
                } = a;
                return l = xe(l), o.has(l) ? r : t.activate({
                    id: l,
                    activated: r,
                    children: o,
                    ...i
                })
            },
            in: t.in,
            out: t.out
        }
    },
    M$ = e => {
        const t = vw(e);
        return {
            activate: a => {
                let {
                    id: l,
                    activated: r,
                    children: o,
                    ...i
                } = a;
                return l = xe(l), o.has(l) ? r : t.activate({
                    id: l,
                    activated: r,
                    children: o,
                    ...i
                })
            },
            in: t.in,
            out: t.out
        }
    },
    N$ = {
        open: e => {
            let {
                id: t,
                value: n,
                opened: a,
                parents: l
            } = e;
            if (n) {
                const r = new Set;
                r.add(t);
                let o = l.get(t);
                for (; o != null;) r.add(o), o = l.get(o);
                return r
            } else return a.delete(t), a
        },
        select: () => null
    },
    mw = {
        open: e => {
            let {
                id: t,
                value: n,
                opened: a,
                parents: l
            } = e;
            if (n) {
                let r = xe(l.get(t));
                for (a.add(t); r != null && r !== t;) a.add(r), r = xe(l.get(r));
                return a
            } else a.delete(t);
            return a
        },
        select: () => null
    },
    $$ = {
        open: mw.open,
        select: e => {
            let {
                id: t,
                value: n,
                opened: a,
                parents: l
            } = e;
            if (!n) return a;
            const r = [];
            let o = l.get(t);
            for (; o != null;) r.push(o), o = l.get(o);
            return new Set(r)
        }
    },
    Jv = e => {
        const t = {
            select: n => {
                let {
                    id: a,
                    value: l,
                    selected: r
                } = n;
                if (a = xe(a), e && !l) {
                    const o = Array.from(r.entries()).reduce((i, s) => {
                        let [u, c] = s;
                        return c === "on" && i.push(u), i
                    }, []);
                    if (o.length === 1 && o[0] === a) return r
                }
                return r.set(a, l ? "on" : "off"), r
            },
            in: (n, a, l) => {
                let r = new Map;
                for (const o of n || []) r = t.select({
                    id: o,
                    value: !0,
                    selected: new Map(r),
                    children: a,
                    parents: l
                });
                return r
            },
            out: n => {
                const a = [];
                for (const [l, r] of n.entries()) r === "on" && a.push(l);
                return a
            }
        };
        return t
    },
    hw = e => {
        const t = Jv(e);
        return {
            select: a => {
                let {
                    selected: l,
                    id: r,
                    ...o
                } = a;
                r = xe(r);
                const i = l.has(r) ? new Map([
                    [r, l.get(r)]
                ]) : new Map;
                return t.select({ ...o,
                    id: r,
                    selected: i
                })
            },
            in: (a, l, r) => {
                let o = new Map;
                return a != null && a.length && (o = t.in(a.slice(0, 1), l, r)), o
            },
            out: (a, l, r) => t.out(a, l, r)
        }
    },
    B$ = e => {
        const t = Jv(e);
        return {
            select: a => {
                let {
                    id: l,
                    selected: r,
                    children: o,
                    ...i
                } = a;
                return l = xe(l), o.has(l) ? r : t.select({
                    id: l,
                    selected: r,
                    children: o,
                    ...i
                })
            },
            in: t.in,
            out: t.out
        }
    },
    F$ = e => {
        const t = hw(e);
        return {
            select: a => {
                let {
                    id: l,
                    selected: r,
                    children: o,
                    ...i
                } = a;
                return l = xe(l), o.has(l) ? r : t.select({
                    id: l,
                    selected: r,
                    children: o,
                    ...i
                })
            },
            in: t.in,
            out: t.out
        }
    },
    H$ = e => {
        const t = {
            select: n => {
                let {
                    id: a,
                    value: l,
                    selected: r,
                    children: o,
                    parents: i
                } = n;
                a = xe(a);
                const s = new Map(r),
                    u = [a];
                for (; u.length;) {
                    const d = u.shift();
                    r.set(xe(d), l ? "on" : "off"), o.has(d) && u.push(...o.get(d))
                }
                let c = xe(i.get(a));
                for (; c;) {
                    const d = o.get(c),
                        f = d.every(g => r.get(xe(g)) === "on"),
                        v = d.every(g => !r.has(xe(g)) || r.get(xe(g)) === "off");
                    r.set(c, f ? "on" : v ? "off" : "indeterminate"), c = xe(i.get(c))
                }
                return e && !l && Array.from(r.entries()).reduce((f, v) => {
                    let [g, h] = v;
                    return h === "on" && f.push(g), f
                }, []).length === 0 ? s : r
            },
            in: (n, a, l) => {
                let r = new Map;
                for (const o of n || []) r = t.select({
                    id: o,
                    value: !0,
                    selected: new Map(r),
                    children: a,
                    parents: l
                });
                return r
            },
            out: (n, a) => {
                const l = [];
                for (const [r, o] of n.entries()) o === "on" && !a.has(r) && l.push(r);
                return l
            }
        };
        return t
    },
    Go = Symbol.for("vuetify:nested"),
    gw = {
        id: fe(),
        root: {
            register: () => null,
            unregister: () => null,
            parents: Q(new Map),
            children: Q(new Map),
            open: () => null,
            openOnSelect: () => null,
            activate: () => null,
            select: () => null,
            activatable: Q(!1),
            selectable: Q(!1),
            opened: Q(new Set),
            activated: Q(new Set),
            selected: Q(new Map),
            selectedValues: Q([])
        }
    },
    j$ = W({
        activatable: Boolean,
        selectable: Boolean,
        activeStrategy: [String, Function, Object],
        selectStrategy: [String, Function, Object],
        openStrategy: [String, Object],
        opened: null,
        activated: null,
        selected: null,
        mandatory: Boolean
    }, "nested"),
    U$ = e => {
        let t = !1;
        const n = Q(new Map),
            a = Q(new Map),
            l = Ce(e, "opened", e.opened, v => new Set(xe(v)), v => [...v.values()]),
            r = C(() => {
                if (typeof e.activeStrategy == "object") return e.activeStrategy;
                if (typeof e.activeStrategy == "function") return e.activeStrategy(e.mandatory);
                switch (e.activeStrategy) {
                    case "leaf":
                        return D$(e.mandatory);
                    case "single-leaf":
                        return M$(e.mandatory);
                    case "independent":
                        return Xv(e.mandatory);
                    case "single-independent":
                    default:
                        return vw(e.mandatory)
                }
            }),
            o = C(() => {
                if (typeof e.selectStrategy == "object") return e.selectStrategy;
                if (typeof e.selectStrategy == "function") return e.selectStrategy(e.mandatory);
                switch (e.selectStrategy) {
                    case "single-leaf":
                        return F$(e.mandatory);
                    case "leaf":
                        return B$(e.mandatory);
                    case "independent":
                        return Jv(e.mandatory);
                    case "single-independent":
                        return hw(e.mandatory);
                    case "classic":
                    default:
                        return H$(e.mandatory)
                }
            }),
            i = C(() => {
                if (typeof e.openStrategy == "object") return e.openStrategy;
                switch (e.openStrategy) {
                    case "list":
                        return $$;
                    case "single":
                        return N$;
                    case "multiple":
                    default:
                        return mw
                }
            }),
            s = Ce(e, "activated", e.activated, v => r.value.in(v, n.value, a.value), v => r.value.out(v, n.value, a.value)),
            u = Ce(e, "selected", e.selected, v => o.value.in(v, n.value, a.value), v => o.value.out(v, n.value, a.value));
        Ct(() => {
            t = !0
        });

        function c(v) {
            const g = [];
            let h = v;
            for (; h != null;) g.unshift(h), h = a.value.get(h);
            return g
        }
        const d = ut("nested"),
            f = {
                id: fe(),
                root: {
                    opened: l,
                    activatable: Y(e, "activatable"),
                    selectable: Y(e, "selectable"),
                    activated: s,
                    selected: u,
                    selectedValues: C(() => {
                        const v = [];
                        for (const [g, h] of u.value.entries()) h === "on" && v.push(g);
                        return v
                    }),
                    register: (v, g, h) => {
                        g && v !== g && a.value.set(v, g), h && n.value.set(v, []), g != null && n.value.set(g, [...n.value.get(g) || [], v])
                    },
                    unregister: v => {
                        if (t) return;
                        n.value.delete(v);
                        const g = a.value.get(v);
                        if (g) {
                            const h = n.value.get(g) ? ? [];
                            n.value.set(g, h.filter(y => y !== v))
                        }
                        a.value.delete(v)
                    },
                    open: (v, g, h) => {
                        d.emit("click:open", {
                            id: v,
                            value: g,
                            path: c(v),
                            event: h
                        });
                        const y = i.value.open({
                            id: v,
                            value: g,
                            opened: new Set(l.value),
                            children: n.value,
                            parents: a.value,
                            event: h
                        });
                        y && (l.value = y)
                    },
                    openOnSelect: (v, g, h) => {
                        const y = i.value.select({
                            id: v,
                            value: g,
                            selected: new Map(u.value),
                            opened: new Set(l.value),
                            children: n.value,
                            parents: a.value,
                            event: h
                        });
                        y && (l.value = y)
                    },
                    select: (v, g, h) => {
                        d.emit("click:select", {
                            id: v,
                            value: g,
                            path: c(v),
                            event: h
                        });
                        const y = o.value.select({
                            id: v,
                            value: g,
                            selected: new Map(u.value),
                            children: n.value,
                            parents: a.value,
                            event: h
                        });
                        y && (u.value = y), f.root.openOnSelect(v, g, h)
                    },
                    activate: (v, g, h) => {
                        if (!e.activatable) return f.root.select(v, !0, h);
                        d.emit("click:activate", {
                            id: v,
                            value: g,
                            path: c(v),
                            event: h
                        });
                        const y = r.value.activate({
                            id: v,
                            value: g,
                            activated: new Set(s.value),
                            children: n.value,
                            parents: a.value,
                            event: h
                        });
                        y && (s.value = y)
                    },
                    children: n,
                    parents: a
                }
            };
        return He(Go, f), f.root
    },
    Zv = (e, t) => {
        const n = Te(Go, gw),
            a = Symbol(Rt()),
            l = C(() => e.value !== void 0 ? e.value : a),
            r = { ...n,
                id: l,
                open: (o, i) => n.root.open(xe(l.value), o, i),
                openOnSelect: (o, i) => n.root.openOnSelect(l.value, o, i),
                isOpen: C(() => n.root.opened.value.has(xe(l.value))),
                parent: C(() => n.root.parents.value.get(l.value)),
                activate: (o, i) => n.root.activate(l.value, o, i),
                isActivated: C(() => n.root.activated.value.has(xe(l.value))),
                select: (o, i) => n.root.select(l.value, o, i),
                isSelected: C(() => n.root.selected.value.get(xe(l.value)) === "on"),
                isIndeterminate: C(() => n.root.selected.value.get(l.value) === "indeterminate"),
                isLeaf: C(() => !n.root.children.value.get(l.value)),
                isGroupActivator: n.isGroupActivator
            };
        return !n.isGroupActivator && n.root.register(l.value, n.id.value, t), Ct(() => {
            !n.isGroupActivator && n.root.unregister(l.value)
        }), t && He(Go, r), r
    },
    W$ = () => {
        const e = Te(Go, gw);
        He(Go, { ...e,
            isGroupActivator: !0
        })
    },
    z$ = pn({
        name: "VListGroupActivator",
        setup(e, t) {
            let {
                slots: n
            } = t;
            return W$(), () => {
                var a;
                return (a = n.default) == null ? void 0 : a.call(n)
            }
        }
    }),
    yw = W({
        activeColor: String,
        baseColor: String,
        color: String,
        collapseIcon: {
            type: Pe,
            default: "$collapse"
        },
        expandIcon: {
            type: Pe,
            default: "$expand"
        },
        prependIcon: Pe,
        appendIcon: Pe,
        fluid: Boolean,
        subgroup: Boolean,
        title: String,
        value: null,
        ...Se(),
        ...Ae()
    }, "VListGroup"),
    Yo = Z()({
        name: "VListGroup",
        props: yw(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                isOpen: a,
                open: l,
                id: r
            } = Zv(Y(e, "value"), !0), o = C(() => `v-list-group--id-${String(r.value)}`), i = fw(), {
                isBooted: s
            } = Kl();

            function u(v) {
                v.stopPropagation(), l(!a.value, v)
            }
            const c = C(() => ({
                    onClick: u,
                    class: "v-list-group__header",
                    id: o.value
                })),
                d = C(() => a.value ? e.collapseIcon : e.expandIcon),
                f = C(() => ({
                    VListItem: {
                        active: a.value,
                        activeColor: e.activeColor,
                        baseColor: e.baseColor,
                        color: e.color,
                        prependIcon: e.prependIcon || e.subgroup && d.value,
                        appendIcon: e.appendIcon || !e.subgroup && d.value,
                        title: e.title,
                        value: e.value
                    }
                }));
            return ne(() => m(e.tag, {
                class: ["v-list-group", {
                    "v-list-group--prepend": i == null ? void 0 : i.hasPrepend.value,
                    "v-list-group--fluid": e.fluid,
                    "v-list-group--subgroup": e.subgroup,
                    "v-list-group--open": a.value
                }, e.class],
                style: e.style
            }, {
                default: () => [n.activator && m(Ve, {
                    defaults: f.value
                }, {
                    default: () => [m(z$, null, {
                        default: () => [n.activator({
                            props: c.value,
                            isOpen: a.value
                        })]
                    })]
                }), m(jt, {
                    transition: {
                        component: Vu
                    },
                    disabled: !s.value
                }, {
                    default: () => {
                        var v;
                        return [at(m("div", {
                            class: "v-list-group__items",
                            role: "group",
                            "aria-labelledby": o.value
                        }, [(v = n.default) == null ? void 0 : v.call(n)]), [
                            [bn, a.value]
                        ])]
                    }
                })]
            })), {
                isOpen: a
            }
        }
    }),
    K$ = W({
        opacity: [Number, String],
        ...Se(),
        ...Ae()
    }, "VListItemSubtitle"),
    bw = Z()({
        name: "VListItemSubtitle",
        props: K$(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            return ne(() => m(e.tag, {
                class: ["v-list-item-subtitle", e.class],
                style: [{
                    "--v-list-item-subtitle-opacity": e.opacity
                }, e.style]
            }, n)), {}
        }
    }),
    pw = oa("v-list-item-title"),
    _w = W({
        active: {
            type: Boolean,
            default: void 0
        },
        activeClass: String,
        activeColor: String,
        appendAvatar: String,
        appendIcon: Pe,
        baseColor: String,
        disabled: Boolean,
        lines: [Boolean, String],
        link: {
            type: Boolean,
            default: void 0
        },
        nav: Boolean,
        prependAvatar: String,
        prependIcon: Pe,
        ripple: {
            type: [Boolean, Object],
            default: !0
        },
        slim: Boolean,
        subtitle: [String, Number],
        title: [String, Number],
        value: null,
        onClick: It(),
        onClickOnce: It(),
        ...an(),
        ...Se(),
        ...Vt(),
        ...bt(),
        ...Pt(),
        ...rt(),
        ...hi(),
        ...Ae(),
        ...Ne(),
        ...Rn({
            variant: "text"
        })
    }, "VListItem"),
    jn = Z()({
        name: "VListItem",
        directives: {
            Ripple: Ia
        },
        props: _w(),
        emits: {
            click: e => !0
        },
        setup(e, t) {
            let {
                attrs: n,
                slots: a,
                emit: l
            } = t;
            const r = Gr(e, n),
                o = C(() => e.value === void 0 ? r.href.value : e.value),
                {
                    activate: i,
                    isActivated: s,
                    select: u,
                    isOpen: c,
                    isSelected: d,
                    isIndeterminate: f,
                    isGroupActivator: v,
                    root: g,
                    parent: h,
                    openOnSelect: y
                } = Zv(o, !1),
                S = fw(),
                b = C(() => {
                    var j;
                    return e.active !== !1 && (e.active || ((j = r.isActive) == null ? void 0 : j.value) || (g.activatable.value ? s.value : d.value))
                }),
                p = C(() => e.link !== !1 && r.isLink.value),
                _ = C(() => !e.disabled && e.link !== !1 && (e.link || r.isClickable.value || !!S && (g.selectable.value || g.activatable.value || e.value != null))),
                w = C(() => e.rounded || e.nav),
                k = C(() => e.color ? ? e.activeColor),
                E = C(() => ({
                    color: b.value ? k.value ? ? e.baseColor : e.baseColor,
                    variant: e.variant
                }));
            de(() => {
                var j;
                return (j = r.isActive) == null ? void 0 : j.value
            }, j => {
                j && h.value != null && g.open(h.value, !0), j && y(j)
            }, {
                immediate: !0
            });
            const {
                themeClasses: P
            } = je(e), {
                borderClasses: x
            } = Sn(e), {
                colorClasses: T,
                colorStyles: V,
                variantClasses: I
            } = Gl(E), {
                densityClasses: R
            } = zt(e), {
                dimensionStyles: B
            } = pt(e), {
                elevationClasses: $
            } = Dt(e), {
                roundedClasses: D
            } = ct(w), z = C(() => e.lines ? `v-list-item--${e.lines}-line` : void 0), N = C(() => ({
                isActive: b.value,
                select: u,
                isOpen: c.value,
                isSelected: d.value,
                isIndeterminate: f.value
            }));

            function H(j) {
                var ae;
                l("click", j), _.value && ((ae = r.navigate) == null || ae.call(r, j), !v && (g.activatable.value ? i(!s.value, j) : (g.selectable.value || e.value != null) && u(!d.value, j)))
            }

            function F(j) {
                (j.key === "Enter" || j.key === " ") && (j.preventDefault(), j.target.dispatchEvent(new MouseEvent("click", j)))
            }
            return ne(() => {
                const j = p.value ? "a" : e.tag,
                    ae = a.title || e.title != null,
                    he = a.subtitle || e.subtitle != null,
                    ve = !!(e.appendAvatar || e.appendIcon),
                    we = !!(ve || a.append),
                    ee = !!(e.prependAvatar || e.prependIcon),
                    G = !!(ee || a.prepend);
                return S == null || S.updateHasPrepend(G), e.activeColor && XD("active-color", ["color", "base-color"]), at(m(j, {
                    class: ["v-list-item", {
                        "v-list-item--active": b.value,
                        "v-list-item--disabled": e.disabled,
                        "v-list-item--link": _.value,
                        "v-list-item--nav": e.nav,
                        "v-list-item--prepend": !G && (S == null ? void 0 : S.hasPrepend.value),
                        "v-list-item--slim": e.slim,
                        [`${e.activeClass}`]: e.activeClass && b.value
                    }, P.value, x.value, T.value, R.value, $.value, z.value, D.value, I.value, e.class],
                    style: [V.value, B.value, e.style],
                    href: r.href.value,
                    tabindex: _.value ? S ? -2 : 0 : void 0,
                    onClick: H,
                    onKeydown: _.value && !p.value && F
                }, {
                    default: () => {
                        var le;
                        return [ll(_.value || b.value, "v-list-item"), G && m("div", {
                            key: "prepend",
                            class: "v-list-item__prepend"
                        }, [a.prepend ? m(Ve, {
                            key: "prepend-defaults",
                            disabled: !ee,
                            defaults: {
                                VAvatar: {
                                    density: e.density,
                                    image: e.prependAvatar
                                },
                                VIcon: {
                                    density: e.density,
                                    icon: e.prependIcon
                                },
                                VListItemAction: {
                                    start: !0
                                }
                            }
                        }, {
                            default: () => {
                                var se;
                                return [(se = a.prepend) == null ? void 0 : se.call(a, N.value)]
                            }
                        }) : m(ye, null, [e.prependAvatar && m(yn, {
                            key: "prepend-avatar",
                            density: e.density,
                            image: e.prependAvatar
                        }, null), e.prependIcon && m(Be, {
                            key: "prepend-icon",
                            density: e.density,
                            icon: e.prependIcon
                        }, null)]), m("div", {
                            class: "v-list-item__spacer"
                        }, null)]), m("div", {
                            class: "v-list-item__content",
                            "data-no-activator": ""
                        }, [ae && m(pw, {
                            key: "title"
                        }, {
                            default: () => {
                                var se;
                                return [((se = a.title) == null ? void 0 : se.call(a, {
                                    title: e.title
                                })) ? ? e.title]
                            }
                        }), he && m(bw, {
                            key: "subtitle"
                        }, {
                            default: () => {
                                var se;
                                return [((se = a.subtitle) == null ? void 0 : se.call(a, {
                                    subtitle: e.subtitle
                                })) ? ? e.subtitle]
                            }
                        }), (le = a.default) == null ? void 0 : le.call(a, N.value)]), we && m("div", {
                            key: "append",
                            class: "v-list-item__append"
                        }, [a.append ? m(Ve, {
                            key: "append-defaults",
                            disabled: !ve,
                            defaults: {
                                VAvatar: {
                                    density: e.density,
                                    image: e.appendAvatar
                                },
                                VIcon: {
                                    density: e.density,
                                    icon: e.appendIcon
                                },
                                VListItemAction: {
                                    end: !0
                                }
                            }
                        }, {
                            default: () => {
                                var se;
                                return [(se = a.append) == null ? void 0 : se.call(a, N.value)]
                            }
                        }) : m(ye, null, [e.appendIcon && m(Be, {
                            key: "append-icon",
                            density: e.density,
                            icon: e.appendIcon
                        }, null), e.appendAvatar && m(yn, {
                            key: "append-avatar",
                            density: e.density,
                            image: e.appendAvatar
                        }, null)]), m("div", {
                            class: "v-list-item__spacer"
                        }, null)])]
                    }
                }), [
                    [tn("ripple"), _.value && e.ripple]
                ])
            }), {
                activate: i,
                isActivated: s,
                isGroupActivator: v,
                isSelected: d,
                list: S,
                select: u
            }
        }
    }),
    G$ = W({
        color: String,
        inset: Boolean,
        sticky: Boolean,
        title: String,
        ...Se(),
        ...Ae()
    }, "VListSubheader"),
    Sw = Z()({
        name: "VListSubheader",
        props: G$(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                textColorClasses: a,
                textColorStyles: l
            } = Ot(Y(e, "color"));
            return ne(() => {
                const r = !!(n.default || e.title);
                return m(e.tag, {
                    class: ["v-list-subheader", {
                        "v-list-subheader--inset": e.inset,
                        "v-list-subheader--sticky": e.sticky
                    }, a.value, e.class],
                    style: [{
                        textColorStyles: l
                    }, e.style]
                }, {
                    default: () => {
                        var o;
                        return [r && m("div", {
                            class: "v-list-subheader__text"
                        }, [((o = n.default) == null ? void 0 : o.call(n)) ? ? e.title])]
                    }
                })
            }), {}
        }
    }),
    Y$ = W({
        color: String,
        inset: Boolean,
        length: [Number, String],
        opacity: [Number, String],
        thickness: [Number, String],
        vertical: Boolean,
        ...Se(),
        ...Ne()
    }, "VDivider"),
    ya = Z()({
        name: "VDivider",
        props: Y$(),
        setup(e, t) {
            let {
                attrs: n,
                slots: a
            } = t;
            const {
                themeClasses: l
            } = je(e), {
                textColorClasses: r,
                textColorStyles: o
            } = Ot(Y(e, "color")), i = C(() => {
                const s = {};
                return e.length && (s[e.vertical ? "height" : "width"] = ge(e.length)), e.thickness && (s[e.vertical ? "borderRightWidth" : "borderTopWidth"] = ge(e.thickness)), s
            });
            return ne(() => {
                const s = m("hr", {
                    class: [{
                        "v-divider": !0,
                        "v-divider--inset": e.inset,
                        "v-divider--vertical": e.vertical
                    }, l.value, r.value, e.class],
                    style: [i.value, o.value, {
                        "--v-border-opacity": e.opacity
                    }, e.style],
                    "aria-orientation": !n.role || n.role === "separator" ? e.vertical ? "vertical" : "horizontal" : void 0,
                    role: `${n.role||"separator"}`
                }, null);
                return a.default ? m("div", {
                    class: ["v-divider__wrapper", {
                        "v-divider__wrapper--vertical": e.vertical,
                        "v-divider__wrapper--inset": e.inset
                    }]
                }, [s, m("div", {
                    class: "v-divider__content"
                }, [a.default()]), s]) : s
            }), {}
        }
    }),
    q$ = W({
        items: Array,
        returnObject: Boolean
    }, "VListChildren"),
    ww = Z()({
        name: "VListChildren",
        props: q$(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            return dw(), () => {
                var a, l;
                return ((a = n.default) == null ? void 0 : a.call(n)) ? ? ((l = e.items) == null ? void 0 : l.map(r => {
                    var f, v;
                    let {
                        children: o,
                        props: i,
                        type: s,
                        raw: u
                    } = r;
                    if (s === "divider") return ((f = n.divider) == null ? void 0 : f.call(n, {
                        props: i
                    })) ? ? m(ya, i, null);
                    if (s === "subheader") return ((v = n.subheader) == null ? void 0 : v.call(n, {
                        props: i
                    })) ? ? m(Sw, i, null);
                    const c = {
                            subtitle: n.subtitle ? g => {
                                var h;
                                return (h = n.subtitle) == null ? void 0 : h.call(n, { ...g,
                                    item: u
                                })
                            } : void 0,
                            prepend: n.prepend ? g => {
                                var h;
                                return (h = n.prepend) == null ? void 0 : h.call(n, { ...g,
                                    item: u
                                })
                            } : void 0,
                            append: n.append ? g => {
                                var h;
                                return (h = n.append) == null ? void 0 : h.call(n, { ...g,
                                    item: u
                                })
                            } : void 0,
                            title: n.title ? g => {
                                var h;
                                return (h = n.title) == null ? void 0 : h.call(n, { ...g,
                                    item: u
                                })
                            } : void 0
                        },
                        d = Yo.filterProps(i);
                    return o ? m(Yo, te({
                        value: i == null ? void 0 : i.value
                    }, d), {
                        activator: g => {
                            let {
                                props: h
                            } = g;
                            const y = { ...i,
                                ...h,
                                value: e.returnObject ? u : i.value
                            };
                            return n.header ? n.header({
                                props: y
                            }) : m(jn, y, c)
                        },
                        default: () => m(ww, {
                            items: o,
                            returnObject: e.returnObject
                        }, n)
                    }) : n.item ? n.item({
                        props: i
                    }) : m(jn, te(i, {
                        value: e.returnObject ? u : i.value
                    }), c)
                }))
            }
        }
    }),
    kw = W({
        items: {
            type: Array,
            default: () => []
        },
        itemTitle: {
            type: [String, Array, Function],
            default: "title"
        },
        itemValue: {
            type: [String, Array, Function],
            default: "value"
        },
        itemChildren: {
            type: [Boolean, String, Array, Function],
            default: "children"
        },
        itemProps: {
            type: [Boolean, String, Array, Function],
            default: "props"
        },
        returnObject: Boolean,
        valueComparator: {
            type: Function,
            default: la
        }
    }, "list-items");

function Wa(e, t) {
    const n = vt(t, e.itemTitle, t),
        a = vt(t, e.itemValue, n),
        l = vt(t, e.itemChildren),
        r = e.itemProps === !0 ? typeof t == "object" && t != null && !Array.isArray(t) ? "children" in t ? We(t, ["children"]) : t : void 0 : vt(t, e.itemProps),
        o = {
            title: n,
            value: a,
            ...r
        };
    return {
        title: String(o.title ? ? ""),
        value: o.value,
        props: o,
        children: Array.isArray(l) ? Cw(e, l) : void 0,
        raw: t
    }
}

function Cw(e, t) {
    const n = [];
    for (const a of t) n.push(Wa(e, a));
    return n
}

function Qv(e) {
    const t = C(() => Cw(e, e.items)),
        n = C(() => t.value.some(r => r.value === null));

    function a(r) {
        return n.value || (r = r.filter(o => o !== null)), r.map(o => e.returnObject && typeof o == "string" ? Wa(e, o) : t.value.find(i => e.valueComparator(o, i.value)) || Wa(e, o))
    }

    function l(r) {
        return e.returnObject ? r.map(o => {
            let {
                raw: i
            } = o;
            return i
        }) : r.map(o => {
            let {
                value: i
            } = o;
            return i
        })
    }
    return {
        items: t,
        transformIn: a,
        transformOut: l
    }
}

function X$(e) {
    return typeof e == "string" || typeof e == "number" || typeof e == "boolean"
}

function J$(e, t) {
    const n = vt(t, e.itemType, "item"),
        a = X$(t) ? t : vt(t, e.itemTitle),
        l = vt(t, e.itemValue, void 0),
        r = vt(t, e.itemChildren),
        o = e.itemProps === !0 ? We(t, ["children"]) : vt(t, e.itemProps),
        i = {
            title: a,
            value: l,
            ...o
        };
    return {
        type: n,
        title: i.title,
        value: i.value,
        props: i,
        children: n === "item" && r ? xw(e, r) : void 0,
        raw: t
    }
}

function xw(e, t) {
    const n = [];
    for (const a of t) n.push(J$(e, a));
    return n
}

function Pw(e) {
    return {
        items: C(() => xw(e, e.items))
    }
}
const Ew = W({
        baseColor: String,
        activeColor: String,
        activeClass: String,
        bgColor: String,
        disabled: Boolean,
        expandIcon: String,
        collapseIcon: String,
        lines: {
            type: [Boolean, String],
            default: "one"
        },
        slim: Boolean,
        nav: Boolean,
        "onClick:open": It(),
        "onClick:select": It(),
        "onUpdate:opened": It(),
        ...j$({
            selectStrategy: "single-leaf",
            openStrategy: "list"
        }),
        ...an(),
        ...Se(),
        ...Vt(),
        ...bt(),
        ...Pt(),
        itemType: {
            type: String,
            default: "type"
        },
        ...kw(),
        ...rt(),
        ...Ae(),
        ...Ne(),
        ...Rn({
            variant: "text"
        })
    }, "VList"),
    Mr = Z()({
        name: "VList",
        props: Ew(),
        emits: {
            "update:selected": e => !0,
            "update:activated": e => !0,
            "update:opened": e => !0,
            "click:open": e => !0,
            "click:activate": e => !0,
            "click:select": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                items: a
            } = Pw(e), {
                themeClasses: l
            } = je(e), {
                backgroundColorClasses: r,
                backgroundColorStyles: o
            } = Ke(Y(e, "bgColor")), {
                borderClasses: i
            } = Sn(e), {
                densityClasses: s
            } = zt(e), {
                dimensionStyles: u
            } = pt(e), {
                elevationClasses: c
            } = Dt(e), {
                roundedClasses: d
            } = ct(e), {
                children: f,
                open: v,
                parents: g,
                select: h
            } = U$(e), y = C(() => e.lines ? `v-list--${e.lines}-line` : void 0), S = Y(e, "activeColor"), b = Y(e, "baseColor"), p = Y(e, "color");
            dw(), lt({
                VListGroup: {
                    activeColor: S,
                    baseColor: b,
                    color: p,
                    expandIcon: Y(e, "expandIcon"),
                    collapseIcon: Y(e, "collapseIcon")
                },
                VListItem: {
                    activeClass: Y(e, "activeClass"),
                    activeColor: S,
                    baseColor: b,
                    color: p,
                    density: Y(e, "density"),
                    disabled: Y(e, "disabled"),
                    lines: Y(e, "lines"),
                    nav: Y(e, "nav"),
                    slim: Y(e, "slim"),
                    variant: Y(e, "variant")
                }
            });
            const _ = fe(!1),
                w = Q();

            function k(I) {
                _.value = !0
            }

            function E(I) {
                _.value = !1
            }

            function P(I) {
                var R;
                !_.value && !(I.relatedTarget && ((R = w.value) != null && R.contains(I.relatedTarget))) && V()
            }

            function x(I) {
                const R = I.target;
                if (!(!w.value || ["INPUT", "TEXTAREA"].includes(R.tagName))) {
                    if (I.key === "ArrowDown") V("next");
                    else if (I.key === "ArrowUp") V("prev");
                    else if (I.key === "Home") V("first");
                    else if (I.key === "End") V("last");
                    else return;
                    I.preventDefault()
                }
            }

            function T(I) {
                _.value = !0
            }

            function V(I) {
                if (w.value) return xl(w.value, I)
            }
            return ne(() => m(e.tag, {
                ref: w,
                class: ["v-list", {
                    "v-list--disabled": e.disabled,
                    "v-list--nav": e.nav,
                    "v-list--slim": e.slim
                }, l.value, r.value, i.value, s.value, c.value, y.value, d.value, e.class],
                style: [o.value, u.value, e.style],
                tabindex: e.disabled || _.value ? -1 : 0,
                role: "listbox",
                "aria-activedescendant": void 0,
                onFocusin: k,
                onFocusout: E,
                onFocus: P,
                onKeydown: x,
                onMousedown: T
            }, {
                default: () => [m(ww, {
                    items: a.value,
                    returnObject: e.returnObject
                }, n)]
            })), {
                open: v,
                select: h,
                focus: V,
                children: f,
                parents: g
            }
        }
    }),
    Z$ = oa("v-list-img"),
    Q$ = W({
        start: Boolean,
        end: Boolean,
        ...Se(),
        ...Ae()
    }, "VListItemAction"),
    Iw = Z()({
        name: "VListItemAction",
        props: Q$(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            return ne(() => m(e.tag, {
                class: ["v-list-item-action", {
                    "v-list-item-action--start": e.start,
                    "v-list-item-action--end": e.end
                }, e.class],
                style: e.style
            }, n)), {}
        }
    }),
    eB = W({
        start: Boolean,
        end: Boolean,
        ...Se(),
        ...Ae()
    }, "VListItemMedia"),
    tB = Z()({
        name: "VListItemMedia",
        props: eB(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            return ne(() => m(e.tag, {
                class: ["v-list-item-media", {
                    "v-list-item-media--start": e.start,
                    "v-list-item-media--end": e.end
                }, e.class],
                style: e.style
            }, n)), {}
        }
    });

function Cc(e, t) {
    return {
        x: e.x + t.x,
        y: e.y + t.y
    }
}

function nB(e, t) {
    return {
        x: e.x - t.x,
        y: e.y - t.y
    }
}

function jy(e, t) {
    if (e.side === "top" || e.side === "bottom") {
        const {
            side: n,
            align: a
        } = e, l = a === "left" ? 0 : a === "center" ? t.width / 2 : a === "right" ? t.width : a, r = n === "top" ? 0 : n === "bottom" ? t.height : n;
        return Cc({
            x: l,
            y: r
        }, t)
    } else if (e.side === "left" || e.side === "right") {
        const {
            side: n,
            align: a
        } = e, l = n === "left" ? 0 : n === "right" ? t.width : n, r = a === "top" ? 0 : a === "center" ? t.height / 2 : a === "bottom" ? t.height : a;
        return Cc({
            x: l,
            y: r
        }, t)
    }
    return Cc({
        x: t.width / 2,
        y: t.height / 2
    }, t)
}
const Tw = {
        static: rB,
        connected: iB
    },
    aB = W({
        locationStrategy: {
            type: [String, Function],
            default: "static",
            validator: e => typeof e == "function" || e in Tw
        },
        location: {
            type: String,
            default: "bottom"
        },
        origin: {
            type: String,
            default: "auto"
        },
        offset: [Number, String, Array]
    }, "VOverlay-location-strategies");

function lB(e, t) {
    const n = Q({}),
        a = Q();
    Ue && Yt(() => !!(t.isActive.value && e.locationStrategy), r => {
        var o, i;
        de(() => e.locationStrategy, r), kt(() => {
            window.removeEventListener("resize", l), a.value = void 0
        }), window.addEventListener("resize", l, {
            passive: !0
        }), typeof e.locationStrategy == "function" ? a.value = (o = e.locationStrategy(t, e, n)) == null ? void 0 : o.updateLocation : a.value = (i = Tw[e.locationStrategy](t, e, n)) == null ? void 0 : i.updateLocation
    });

    function l(r) {
        var o;
        (o = a.value) == null || o.call(a, r)
    }
    return {
        contentStyles: n,
        updateLocation: a
    }
}

function rB() {}

function oB(e, t) {
    const n = Ov(e);
    return t ? n.x += parseFloat(e.style.right || 0) : n.x -= parseFloat(e.style.left || 0), n.y -= parseFloat(e.style.top || 0), n
}

function iB(e, t, n) {
    (Array.isArray(e.target.value) || yM(e.target.value)) && Object.assign(n.value, {
        position: "fixed",
        top: 0,
        [e.isRtl.value ? "right" : "left"]: 0
    });
    const {
        preferredAnchor: l,
        preferredOrigin: r
    } = Av(() => {
        const g = Od(t.location, e.isRtl.value),
            h = t.origin === "overlap" ? g : t.origin === "auto" ? pc(g) : Od(t.origin, e.isRtl.value);
        return g.side === h.side && g.align === _c(h).align ? {
            preferredAnchor: uy(g),
            preferredOrigin: uy(h)
        } : {
            preferredAnchor: g,
            preferredOrigin: h
        }
    }), [o, i, s, u] = ["minWidth", "minHeight", "maxWidth", "maxHeight"].map(g => C(() => {
        const h = parseFloat(t[g]);
        return isNaN(h) ? 1 / 0 : h
    })), c = C(() => {
        if (Array.isArray(t.offset)) return t.offset;
        if (typeof t.offset == "string") {
            const g = t.offset.split(" ").map(parseFloat);
            return g.length < 2 && g.push(0), g
        }
        return typeof t.offset == "number" ? [t.offset, 0] : [0, 0]
    });
    let d = !1;
    const f = new ResizeObserver(() => {
        d && v()
    });
    de([e.target, e.contentEl], (g, h) => {
        let [y, S] = g, [b, p] = h;
        b && !Array.isArray(b) && f.unobserve(b), y && !Array.isArray(y) && f.observe(y), p && f.unobserve(p), S && f.observe(S)
    }, {
        immediate: !0
    }), kt(() => {
        f.disconnect()
    });

    function v() {
        if (d = !1, requestAnimationFrame(() => d = !0), !e.target.value || !e.contentEl.value) return;
        const g = aS(e.target.value),
            h = oB(e.contentEl.value, e.isRtl.value),
            y = Bo(e.contentEl.value),
            S = 12;
        y.length || (y.push(document.documentElement), e.contentEl.value.style.top && e.contentEl.value.style.left || (h.x -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-x") || 0), h.y -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-y") || 0)));
        const b = y.reduce((V, I) => {
            const R = I.getBoundingClientRect(),
                B = new Pl({
                    x: I === document.documentElement ? 0 : R.x,
                    y: I === document.documentElement ? 0 : R.y,
                    width: I.clientWidth,
                    height: I.clientHeight
                });
            return V ? new Pl({
                x: Math.max(V.left, B.left),
                y: Math.max(V.top, B.top),
                width: Math.min(V.right, B.right) - Math.max(V.left, B.left),
                height: Math.min(V.bottom, B.bottom) - Math.max(V.top, B.top)
            }) : B
        }, void 0);
        b.x += S, b.y += S, b.width -= S * 2, b.height -= S * 2;
        let p = {
            anchor: l.value,
            origin: r.value
        };

        function _(V) {
            const I = new Pl(h),
                R = jy(V.anchor, g),
                B = jy(V.origin, I);
            let {
                x: $,
                y: D
            } = nB(R, B);
            switch (V.anchor.side) {
                case "top":
                    D -= c.value[0];
                    break;
                case "bottom":
                    D += c.value[0];
                    break;
                case "left":
                    $ -= c.value[0];
                    break;
                case "right":
                    $ += c.value[0];
                    break
            }
            switch (V.anchor.align) {
                case "top":
                    D -= c.value[1];
                    break;
                case "bottom":
                    D += c.value[1];
                    break;
                case "left":
                    $ -= c.value[1];
                    break;
                case "right":
                    $ += c.value[1];
                    break
            }
            return I.x += $, I.y += D, I.width = Math.min(I.width, s.value), I.height = Math.min(I.height, u.value), {
                overflows: dy(I, b),
                x: $,
                y: D
            }
        }
        let w = 0,
            k = 0;
        const E = {
                x: 0,
                y: 0
            },
            P = {
                x: !1,
                y: !1
            };
        let x = -1;
        for (; !(x++ > 10);) {
            const {
                x: V,
                y: I,
                overflows: R
            } = _(p);
            w += V, k += I, h.x += V, h.y += I; {
                const B = cy(p.anchor),
                    $ = R.x.before || R.x.after,
                    D = R.y.before || R.y.after;
                let z = !1;
                if (["x", "y"].forEach(N => {
                        if (N === "x" && $ && !P.x || N === "y" && D && !P.y) {
                            const H = {
                                    anchor: { ...p.anchor
                                    },
                                    origin: { ...p.origin
                                    }
                                },
                                F = N === "x" ? B === "y" ? _c : pc : B === "y" ? pc : _c;
                            H.anchor = F(H.anchor), H.origin = F(H.origin);
                            const {
                                overflows: j
                            } = _(H);
                            (j[N].before <= R[N].before && j[N].after <= R[N].after || j[N].before + j[N].after < (R[N].before + R[N].after) / 2) && (p = H, z = P[N] = !0)
                        }
                    }), z) continue
            }
            R.x.before && (w += R.x.before, h.x += R.x.before), R.x.after && (w -= R.x.after, h.x -= R.x.after), R.y.before && (k += R.y.before, h.y += R.y.before), R.y.after && (k -= R.y.after, h.y -= R.y.after); {
                const B = dy(h, b);
                E.x = b.width - B.x.before - B.x.after, E.y = b.height - B.y.before - B.y.after, w += B.x.before, h.x += B.x.before, k += B.y.before, h.y += B.y.before
            }
            break
        }
        const T = cy(p.anchor);
        return Object.assign(n.value, {
            "--v-overlay-anchor-origin": `${p.anchor.side} ${p.anchor.align}`,
            transformOrigin: `${p.origin.side} ${p.origin.align}`,
            top: ge(xc(k)),
            left: e.isRtl.value ? void 0 : ge(xc(w)),
            right: e.isRtl.value ? ge(xc(-w)) : void 0,
            minWidth: ge(T === "y" ? Math.min(o.value, g.width) : o.value),
            maxWidth: ge(Uy(ot(E.x, o.value === 1 / 0 ? 0 : o.value, s.value))),
            maxHeight: ge(Uy(ot(E.y, i.value === 1 / 0 ? 0 : i.value, u.value)))
        }), {
            available: E,
            contentBox: h
        }
    }
    return de(() => [l.value, r.value, t.offset, t.minWidth, t.minHeight, t.maxWidth, t.maxHeight], () => v()), Re(() => {
        const g = v();
        if (!g) return;
        const {
            available: h,
            contentBox: y
        } = g;
        y.height > h.y && requestAnimationFrame(() => {
            v(), requestAnimationFrame(() => {
                v()
            })
        })
    }), {
        updateLocation: v
    }
}

function xc(e) {
    return Math.round(e * devicePixelRatio) / devicePixelRatio
}

function Uy(e) {
    return Math.ceil(e * devicePixelRatio) / devicePixelRatio
}
let Gd = !0;
const Ms = [];

function sB(e) {
    !Gd || Ms.length ? (Ms.push(e), Yd()) : (Gd = !1, e(), Yd())
}
let Wy = -1;

function Yd() {
    cancelAnimationFrame(Wy), Wy = requestAnimationFrame(() => {
        const e = Ms.shift();
        e && e(), Ms.length ? Yd() : Gd = !0
    })
}
const ts = {
        none: null,
        close: dB,
        block: fB,
        reposition: vB
    },
    uB = W({
        scrollStrategy: {
            type: [String, Function],
            default: "block",
            validator: e => typeof e == "function" || e in ts
        }
    }, "VOverlay-scroll-strategies");

function cB(e, t) {
    if (!Ue) return;
    let n;
    st(async () => {
        n == null || n.stop(), t.isActive.value && e.scrollStrategy && (n = xa(), await new Promise(a => setTimeout(a)), n.active && n.run(() => {
            var a;
            typeof e.scrollStrategy == "function" ? e.scrollStrategy(t, e, n) : (a = ts[e.scrollStrategy]) == null || a.call(ts, t, e, n)
        }))
    }), kt(() => {
        n == null || n.stop()
    })
}

function dB(e) {
    function t(n) {
        e.isActive.value = !1
    }
    Vw(e.targetEl.value ? ? e.contentEl.value, t)
}

function fB(e, t) {
    var o;
    const n = (o = e.root.value) == null ? void 0 : o.offsetParent,
        a = [...new Set([...Bo(e.targetEl.value, t.contained ? n : void 0), ...Bo(e.contentEl.value, t.contained ? n : void 0)])].filter(i => !i.classList.contains("v-overlay-scroll-blocked")),
        l = window.innerWidth - document.documentElement.offsetWidth,
        r = (i => $v(i) && i)(n || document.documentElement);
    r && e.root.value.classList.add("v-overlay--scroll-blocked"), a.forEach((i, s) => {
        i.style.setProperty("--v-body-scroll-x", ge(-i.scrollLeft)), i.style.setProperty("--v-body-scroll-y", ge(-i.scrollTop)), i !== document.documentElement && i.style.setProperty("--v-scrollbar-offset", ge(l)), i.classList.add("v-overlay-scroll-blocked")
    }), kt(() => {
        a.forEach((i, s) => {
            const u = parseFloat(i.style.getPropertyValue("--v-body-scroll-x")),
                c = parseFloat(i.style.getPropertyValue("--v-body-scroll-y")),
                d = i.style.scrollBehavior;
            i.style.scrollBehavior = "auto", i.style.removeProperty("--v-body-scroll-x"), i.style.removeProperty("--v-body-scroll-y"), i.style.removeProperty("--v-scrollbar-offset"), i.classList.remove("v-overlay-scroll-blocked"), i.scrollLeft = -u, i.scrollTop = -c, i.style.scrollBehavior = d
        }), r && e.root.value.classList.remove("v-overlay--scroll-blocked")
    })
}

function vB(e, t, n) {
    let a = !1,
        l = -1,
        r = -1;

    function o(i) {
        sB(() => {
            var c, d;
            const s = performance.now();
            (d = (c = e.updateLocation).value) == null || d.call(c, i), a = (performance.now() - s) / (1e3 / 60) > 2
        })
    }
    r = (typeof requestIdleCallback > "u" ? i => i() : requestIdleCallback)(() => {
        n.run(() => {
            Vw(e.targetEl.value ? ? e.contentEl.value, i => {
                a ? (cancelAnimationFrame(l), l = requestAnimationFrame(() => {
                    l = requestAnimationFrame(() => {
                        o(i)
                    })
                })) : o(i)
            })
        })
    }), kt(() => {
        typeof cancelIdleCallback < "u" && cancelIdleCallback(r), cancelAnimationFrame(l)
    })
}

function Vw(e, t) {
    const n = [document, ...Bo(e)];
    n.forEach(a => {
        a.addEventListener("scroll", t, {
            passive: !0
        })
    }), kt(() => {
        n.forEach(a => {
            a.removeEventListener("scroll", t)
        })
    })
}
const qd = Symbol.for("vuetify:v-menu"),
    em = W({
        closeDelay: [Number, String],
        openDelay: [Number, String]
    }, "delay");

function tm(e, t) {
    let n = () => {};

    function a(o) {
        n == null || n();
        const i = Number(o ? e.openDelay : e.closeDelay);
        return new Promise(s => {
            n = $D(i, () => {
                t == null || t(o), s(o)
            })
        })
    }

    function l() {
        return a(!0)
    }

    function r() {
        return a(!1)
    }
    return {
        clearDelay: n,
        runOpenDelay: l,
        runCloseDelay: r
    }
}
const mB = W({
    target: [String, Object],
    activator: [String, Object],
    activatorProps: {
        type: Object,
        default: () => ({})
    },
    openOnClick: {
        type: Boolean,
        default: void 0
    },
    openOnHover: Boolean,
    openOnFocus: {
        type: Boolean,
        default: void 0
    },
    closeOnContentClick: Boolean,
    ...em()
}, "VOverlay-activator");

function hB(e, t) {
    let {
        isActive: n,
        isTop: a,
        contentEl: l
    } = t;
    const r = ut("useActivator"),
        o = Q();
    let i = !1,
        s = !1,
        u = !0;
    const c = C(() => e.openOnFocus || e.openOnFocus == null && e.openOnHover),
        d = C(() => e.openOnClick || e.openOnClick == null && !e.openOnHover && !c.value),
        {
            runOpenDelay: f,
            runCloseDelay: v
        } = tm(e, P => {
            P === (e.openOnHover && i || c.value && s) && !(e.openOnHover && n.value && !a.value) && (n.value !== P && (u = !0), n.value = P)
        }),
        g = Q(),
        h = {
            onClick: P => {
                P.stopPropagation(), o.value = P.currentTarget || P.target, n.value || (g.value = [P.clientX, P.clientY]), n.value = !n.value
            },
            onMouseenter: P => {
                var x;
                (x = P.sourceCapabilities) != null && x.firesTouchEvents || (i = !0, o.value = P.currentTarget || P.target, f())
            },
            onMouseleave: P => {
                i = !1, v()
            },
            onFocus: P => {
                Or(P.target, ":focus-visible") !== !1 && (s = !0, P.stopPropagation(), o.value = P.currentTarget || P.target, f())
            },
            onBlur: P => {
                s = !1, P.stopPropagation(), v()
            }
        },
        y = C(() => {
            const P = {};
            return d.value && (P.onClick = h.onClick), e.openOnHover && (P.onMouseenter = h.onMouseenter, P.onMouseleave = h.onMouseleave), c.value && (P.onFocus = h.onFocus, P.onBlur = h.onBlur), P
        }),
        S = C(() => {
            const P = {};
            if (e.openOnHover && (P.onMouseenter = () => {
                    i = !0, f()
                }, P.onMouseleave = () => {
                    i = !1, v()
                }), c.value && (P.onFocusin = () => {
                    s = !0, f()
                }, P.onFocusout = () => {
                    s = !1, v()
                }), e.closeOnContentClick) {
                const x = Te(qd, null);
                P.onClick = () => {
                    n.value = !1, x == null || x.closeParents()
                }
            }
            return P
        }),
        b = C(() => {
            const P = {};
            return e.openOnHover && (P.onMouseenter = () => {
                u && (i = !0, u = !1, f())
            }, P.onMouseleave = () => {
                i = !1, v()
            }), P
        });
    de(a, P => {
        var x;
        P && (e.openOnHover && !i && (!c.value || !s) || c.value && !s && (!e.openOnHover || !i)) && !((x = l.value) != null && x.contains(document.activeElement)) && (n.value = !1)
    }), de(n, P => {
        P || setTimeout(() => {
            g.value = void 0
        })
    }, {
        flush: "post"
    });
    const p = As();
    st(() => {
        p.value && Re(() => {
            o.value = p.el
        })
    });
    const _ = As(),
        w = C(() => e.target === "cursor" && g.value ? g.value : _.value ? _.el : Aw(e.target, r) || o.value),
        k = C(() => Array.isArray(w.value) ? void 0 : w.value);
    let E;
    return de(() => !!e.activator, P => {
        P && Ue ? (E = xa(), E.run(() => {
            gB(e, r, {
                activatorEl: o,
                activatorEvents: y
            })
        })) : E && E.stop()
    }, {
        flush: "post",
        immediate: !0
    }), kt(() => {
        E == null || E.stop()
    }), {
        activatorEl: o,
        activatorRef: p,
        target: w,
        targetEl: k,
        targetRef: _,
        activatorEvents: y,
        contentEvents: S,
        scrimEvents: b
    }
}

function gB(e, t, n) {
    let {
        activatorEl: a,
        activatorEvents: l
    } = n;
    de(() => e.activator, (s, u) => {
        if (u && s !== u) {
            const c = i(u);
            c && o(c)
        }
        s && Re(() => r())
    }, {
        immediate: !0
    }), de(() => e.activatorProps, () => {
        r()
    }), kt(() => {
        o()
    });

    function r() {
        let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : i(),
            u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.activatorProps;
        s && HD(s, te(l.value, u))
    }

    function o() {
        let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : i(),
            u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.activatorProps;
        s && jD(s, te(l.value, u))
    }

    function i() {
        let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : e.activator;
        const u = Aw(s, t);
        return a.value = (u == null ? void 0 : u.nodeType) === Node.ELEMENT_NODE ? u : void 0, a.value
    }
}

function Aw(e, t) {
    var a, l;
    if (!e) return;
    let n;
    if (e === "parent") {
        let r = (l = (a = t == null ? void 0 : t.proxy) == null ? void 0 : a.$el) == null ? void 0 : l.parentNode;
        for (; r != null && r.hasAttribute("data-no-activator");) r = r.parentNode;
        n = r
    } else typeof e == "string" ? n = document.querySelector(e) : "$el" in e ? n = e.$el : n = e;
    return n
}

function Lw() {
    if (!Ue) return fe(!1);
    const {
        ssr: e
    } = On();
    if (e) {
        const t = fe(!1);
        return it(() => {
            t.value = !0
        }), t
    } else return fe(!0)
}
const nm = W({
    eager: Boolean
}, "lazy");

function am(e, t) {
    const n = fe(!1),
        a = C(() => n.value || e.eager || t.value);
    de(t, () => n.value = !0);

    function l() {
        e.eager || (n.value = !1)
    }
    return {
        isBooted: n,
        hasContent: a,
        onAfterLeave: l
    }
}

function Ql() {
    const t = ut("useScopeId").vnode.scopeId;
    return {
        scopeId: t ? {
            [t]: ""
        } : void 0
    }
}
const zy = Symbol.for("vuetify:stack"),
    lo = mt([]);

function yB(e, t, n) {
    const a = ut("useStack"),
        l = !n,
        r = Te(zy, void 0),
        o = mt({
            activeChildren: new Set
        });
    He(zy, o);
    const i = fe(+t.value);
    Yt(e, () => {
        var d;
        const c = (d = lo.at(-1)) == null ? void 0 : d[1];
        i.value = c ? c + 10 : +t.value, l && lo.push([a.uid, i.value]), r == null || r.activeChildren.add(a.uid), kt(() => {
            if (l) {
                const f = xe(lo).findIndex(v => v[0] === a.uid);
                lo.splice(f, 1)
            }
            r == null || r.activeChildren.delete(a.uid)
        })
    });
    const s = fe(!0);
    l && st(() => {
        var d;
        const c = ((d = lo.at(-1)) == null ? void 0 : d[0]) === a.uid;
        setTimeout(() => s.value = c)
    });
    const u = C(() => !o.activeChildren.size);
    return {
        globalTop: Br(s),
        localTop: u,
        stackStyles: C(() => ({
            zIndex: i.value
        }))
    }
}

function bB(e) {
    return {
        teleportTarget: C(() => {
            const n = e();
            if (n === !0 || !Ue) return;
            const a = n === !1 ? document.body : typeof n == "string" ? document.querySelector(n) : n;
            if (a == null) return;
            let l = [...a.children].find(r => r.matches(".v-overlay-container"));
            return l || (l = document.createElement("div"), l.className = "v-overlay-container", a.appendChild(l)), l
        })
    }
}

function pB() {
    return !0
}

function Ow(e, t, n) {
    if (!e || Rw(e, n) === !1) return !1;
    const a = gS(t);
    if (typeof ShadowRoot < "u" && a instanceof ShadowRoot && a.host === e.target) return !1;
    const l = (typeof n.value == "object" && n.value.include || (() => []))();
    return l.push(t), !l.some(r => r == null ? void 0 : r.contains(e.target))
}

function Rw(e, t) {
    return (typeof t.value == "object" && t.value.closeConditional || pB)(e)
}

function _B(e, t, n) {
    const a = typeof n.value == "function" ? n.value : n.value.handler;
    e.shadowTarget = e.target, t._clickOutside.lastMousedownWasOutside && Ow(e, t, n) && setTimeout(() => {
        Rw(e, n) && a && a(e)
    }, 0)
}

function Ky(e, t) {
    const n = gS(e);
    t(document), typeof ShadowRoot < "u" && n instanceof ShadowRoot && t(n)
}
const Dw = {
    mounted(e, t) {
        const n = l => _B(l, e, t),
            a = l => {
                e._clickOutside.lastMousedownWasOutside = Ow(l, e, t)
            };
        Ky(e, l => {
            l.addEventListener("click", n, !0), l.addEventListener("mousedown", a, !0)
        }), e._clickOutside || (e._clickOutside = {
            lastMousedownWasOutside: !1
        }), e._clickOutside[t.instance.$.uid] = {
            onClick: n,
            onMousedown: a
        }
    },
    beforeUnmount(e, t) {
        e._clickOutside && (Ky(e, n => {
            var r;
            if (!n || !((r = e._clickOutside) != null && r[t.instance.$.uid])) return;
            const {
                onClick: a,
                onMousedown: l
            } = e._clickOutside[t.instance.$.uid];
            n.removeEventListener("click", a, !0), n.removeEventListener("mousedown", l, !0)
        }), delete e._clickOutside[t.instance.$.uid])
    }
};

function SB(e) {
    const {
        modelValue: t,
        color: n,
        ...a
    } = e;
    return m(Tn, {
        name: "fade-transition",
        appear: !0
    }, {
        default: () => [e.modelValue && m("div", te({
            class: ["v-overlay__scrim", e.color.backgroundColorClasses.value],
            style: e.color.backgroundColorStyles.value
        }, a), null)]
    })
}
const yi = W({
        absolute: Boolean,
        attach: [Boolean, String, Object],
        closeOnBack: {
            type: Boolean,
            default: !0
        },
        contained: Boolean,
        contentClass: null,
        contentProps: null,
        disabled: Boolean,
        opacity: [Number, String],
        noClickAnimation: Boolean,
        modelValue: Boolean,
        persistent: Boolean,
        scrim: {
            type: [Boolean, String],
            default: !0
        },
        zIndex: {
            type: [Number, String],
            default: 2e3
        },
        ...mB(),
        ...Se(),
        ...bt(),
        ...nm(),
        ...aB(),
        ...uB(),
        ...Ne(),
        ...Wn()
    }, "VOverlay"),
    ea = Z()({
        name: "VOverlay",
        directives: {
            ClickOutside: Dw
        },
        inheritAttrs: !1,
        props: {
            _disableGlobalStack: Boolean,
            ...yi()
        },
        emits: {
            "click:outside": e => !0,
            "update:modelValue": e => !0,
            afterEnter: () => !0,
            afterLeave: () => !0
        },
        setup(e, t) {
            let {
                slots: n,
                attrs: a,
                emit: l
            } = t;
            const r = ut("VOverlay"),
                o = Q(),
                i = Q(),
                s = Q(),
                u = Ce(e, "modelValue"),
                c = C({
                    get: () => u.value,
                    set: ee => {
                        ee && e.disabled || (u.value = ee)
                    }
                }),
                {
                    themeClasses: d
                } = je(e),
                {
                    rtlClasses: f,
                    isRtl: v
                } = xt(),
                {
                    hasContent: g,
                    onAfterLeave: h
                } = am(e, c),
                y = Ke(C(() => typeof e.scrim == "string" ? e.scrim : null)),
                {
                    globalTop: S,
                    localTop: b,
                    stackStyles: p
                } = yB(c, Y(e, "zIndex"), e._disableGlobalStack),
                {
                    activatorEl: _,
                    activatorRef: w,
                    target: k,
                    targetEl: E,
                    targetRef: P,
                    activatorEvents: x,
                    contentEvents: T,
                    scrimEvents: V
                } = hB(e, {
                    isActive: c,
                    isTop: b,
                    contentEl: s
                }),
                {
                    teleportTarget: I
                } = bB(() => {
                    var le, se, ce;
                    const ee = e.attach || e.contained;
                    if (ee) return ee;
                    const G = ((le = _ == null ? void 0 : _.value) == null ? void 0 : le.getRootNode()) || ((ce = (se = r.proxy) == null ? void 0 : se.$el) == null ? void 0 : ce.getRootNode());
                    return G instanceof ShadowRoot ? G : !1
                }),
                {
                    dimensionStyles: R
                } = pt(e),
                B = Lw(),
                {
                    scopeId: $
                } = Ql();
            de(() => e.disabled, ee => {
                ee && (c.value = !1)
            });
            const {
                contentStyles: D,
                updateLocation: z
            } = lB(e, {
                isRtl: v,
                contentEl: s,
                target: k,
                isActive: c
            });
            cB(e, {
                root: o,
                contentEl: s,
                targetEl: E,
                isActive: c,
                updateLocation: z
            });

            function N(ee) {
                l("click:outside", ee), e.persistent ? he() : c.value = !1
            }

            function H(ee) {
                return c.value && S.value && (!e.scrim || ee.target === i.value || ee instanceof MouseEvent && ee.shadowTarget === i.value)
            }
            Ue && de(c, ee => {
                ee ? window.addEventListener("keydown", F) : window.removeEventListener("keydown", F)
            }, {
                immediate: !0
            }), Ct(() => {
                Ue && window.removeEventListener("keydown", F)
            });

            function F(ee) {
                var G, le;
                ee.key === "Escape" && S.value && (e.persistent ? he() : (c.value = !1, (G = s.value) != null && G.contains(document.activeElement) && ((le = _.value) == null || le.focus())))
            }
            const j = US();
            Yt(() => e.closeOnBack, () => {
                i$(j, ee => {
                    S.value && c.value ? (ee(!1), e.persistent ? he() : c.value = !1) : ee()
                })
            });
            const ae = Q();
            de(() => c.value && (e.absolute || e.contained) && I.value == null, ee => {
                if (ee) {
                    const G = Nv(o.value);
                    G && G !== document.scrollingElement && (ae.value = G.scrollTop)
                }
            });

            function he() {
                e.noClickAnimation || s.value && yl(s.value, [{
                    transformOrigin: "center"
                }, {
                    transform: "scale(1.03)"
                }, {
                    transformOrigin: "center"
                }], {
                    duration: 150,
                    easing: $o
                })
            }

            function ve() {
                l("afterEnter")
            }

            function we() {
                h(), l("afterLeave")
            }
            return ne(() => {
                var ee;
                return m(ye, null, [(ee = n.activator) == null ? void 0 : ee.call(n, {
                    isActive: c.value,
                    targetRef: P,
                    props: te({
                        ref: w
                    }, x.value, e.activatorProps)
                }), B.value && g.value && m(pp, {
                    disabled: !I.value,
                    to: I.value
                }, {
                    default: () => [m("div", te({
                        class: ["v-overlay", {
                            "v-overlay--absolute": e.absolute || e.contained,
                            "v-overlay--active": c.value,
                            "v-overlay--contained": e.contained
                        }, d.value, f.value, e.class],
                        style: [p.value, {
                            "--v-overlay-opacity": e.opacity,
                            top: ge(ae.value)
                        }, e.style],
                        ref: o
                    }, $, a), [m(SB, te({
                        color: y,
                        modelValue: c.value && !!e.scrim,
                        ref: i
                    }, V.value), null), m(jt, {
                        appear: !0,
                        persisted: !0,
                        transition: e.transition,
                        target: k.value,
                        onAfterEnter: ve,
                        onAfterLeave: we
                    }, {
                        default: () => {
                            var G;
                            return [at(m("div", te({
                                ref: s,
                                class: ["v-overlay__content", e.contentClass],
                                style: [R.value, D.value]
                            }, T.value, e.contentProps), [(G = n.default) == null ? void 0 : G.call(n, {
                                isActive: c
                            })]), [
                                [bn, c.value],
                                [tn("click-outside"), {
                                    handler: N,
                                    closeConditional: H,
                                    include: () => [_.value]
                                }]
                            ])]
                        }
                    })])]
                })])
            }), {
                activatorEl: _,
                scrimEl: i,
                target: k,
                animateClick: he,
                contentEl: s,
                globalTop: S,
                localTop: b,
                updateLocation: z
            }
        }
    }),
    Pc = Symbol("Forwarded refs");

function Ec(e, t) {
    let n = e;
    for (; n;) {
        const a = Reflect.getOwnPropertyDescriptor(n, t);
        if (a) return a;
        n = Object.getPrototypeOf(n)
    }
}

function wn(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), a = 1; a < t; a++) n[a - 1] = arguments[a];
    return e[Pc] = n, new Proxy(e, {
        get(l, r) {
            if (Reflect.has(l, r)) return Reflect.get(l, r);
            if (!(typeof r == "symbol" || r.startsWith("$") || r.startsWith("__"))) {
                for (const o of n)
                    if (o.value && Reflect.has(o.value, r)) {
                        const i = Reflect.get(o.value, r);
                        return typeof i == "function" ? i.bind(o.value) : i
                    }
            }
        },
        has(l, r) {
            if (Reflect.has(l, r)) return !0;
            if (typeof r == "symbol" || r.startsWith("$") || r.startsWith("__")) return !1;
            for (const o of n)
                if (o.value && Reflect.has(o.value, r)) return !0;
            return !1
        },
        set(l, r, o) {
            if (Reflect.has(l, r)) return Reflect.set(l, r, o);
            if (typeof r == "symbol" || r.startsWith("$") || r.startsWith("__")) return !1;
            for (const i of n)
                if (i.value && Reflect.has(i.value, r)) return Reflect.set(i.value, r, o);
            return !1
        },
        getOwnPropertyDescriptor(l, r) {
            var i;
            const o = Reflect.getOwnPropertyDescriptor(l, r);
            if (o) return o;
            if (!(typeof r == "symbol" || r.startsWith("$") || r.startsWith("__"))) {
                for (const s of n) {
                    if (!s.value) continue;
                    const u = Ec(s.value, r) ? ? ("_" in s.value ? Ec((i = s.value._) == null ? void 0 : i.setupState, r) : void 0);
                    if (u) return u
                }
                for (const s of n) {
                    const u = s.value && s.value[Pc];
                    if (!u) continue;
                    const c = u.slice();
                    for (; c.length;) {
                        const d = c.shift(),
                            f = Ec(d.value, r);
                        if (f) return f;
                        const v = d.value && d.value[Pc];
                        v && c.push(...v)
                    }
                }
            }
        }
    })
}
const Mw = W({
        id: String,
        submenu: Boolean,
        ...We(yi({
            closeDelay: 250,
            closeOnContentClick: !0,
            locationStrategy: "connected",
            location: void 0,
            openDelay: 300,
            scrim: !1,
            scrollStrategy: "reposition",
            transition: {
                component: Tu
            }
        }), ["absolute"])
    }, "VMenu"),
    Ol = Z()({
        name: "VMenu",
        props: Mw(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Ce(e, "modelValue"),
                {
                    scopeId: l
                } = Ql(),
                {
                    isRtl: r
                } = xt(),
                o = Rt(),
                i = C(() => e.id || `v-menu-${o}`),
                s = Q(),
                u = Te(qd, null),
                c = fe(new Set);
            He(qd, {
                register() {
                    c.value.add(o)
                },
                unregister() {
                    c.value.delete(o)
                },
                closeParents(y) {
                    setTimeout(() => {
                        var S;
                        !c.value.size && !e.persistent && (y == null || (S = s.value) != null && S.contentEl && !BD(y, s.value.contentEl)) && (a.value = !1, u == null || u.closeParents())
                    }, 40)
                }
            }), Ct(() => u == null ? void 0 : u.unregister()), Qs(() => a.value = !1);
            async function d(y) {
                var p, _, w;
                const S = y.relatedTarget,
                    b = y.target;
                await Re(), a.value && S !== b && ((p = s.value) != null && p.contentEl) && ((_ = s.value) != null && _.globalTop) && ![document, s.value.contentEl].includes(b) && !s.value.contentEl.contains(b) && ((w = No(s.value.contentEl)[0]) == null || w.focus())
            }
            de(a, y => {
                y ? (u == null || u.register(), document.addEventListener("focusin", d, {
                    once: !0
                })) : (u == null || u.unregister(), document.removeEventListener("focusin", d))
            });

            function f(y) {
                u == null || u.closeParents(y)
            }

            function v(y) {
                var S, b, p, _, w;
                if (!e.disabled)
                    if (y.key === "Tab" || y.key === "Enter" && !e.closeOnContentClick) {
                        if (y.key === "Enter" && (y.target instanceof HTMLTextAreaElement || y.target instanceof HTMLInputElement && y.target.closest("form"))) return;
                        y.key === "Enter" && y.preventDefault(), eS(No((S = s.value) == null ? void 0 : S.contentEl, !1), y.shiftKey ? "prev" : "next", E => E.tabIndex >= 0) || (a.value = !1, (p = (b = s.value) == null ? void 0 : b.activatorEl) == null || p.focus())
                    } else e.submenu && y.key === (r.value ? "ArrowRight" : "ArrowLeft") && (a.value = !1, (w = (_ = s.value) == null ? void 0 : _.activatorEl) == null || w.focus())
            }

            function g(y) {
                var b;
                if (e.disabled) return;
                const S = (b = s.value) == null ? void 0 : b.contentEl;
                S && a.value ? y.key === "ArrowDown" ? (y.preventDefault(), y.stopImmediatePropagation(), xl(S, "next")) : y.key === "ArrowUp" ? (y.preventDefault(), y.stopImmediatePropagation(), xl(S, "prev")) : e.submenu && (y.key === (r.value ? "ArrowRight" : "ArrowLeft") ? a.value = !1 : y.key === (r.value ? "ArrowLeft" : "ArrowRight") && (y.preventDefault(), xl(S, "first"))) : (e.submenu ? y.key === (r.value ? "ArrowLeft" : "ArrowRight") : ["ArrowDown", "ArrowUp"].includes(y.key)) && (a.value = !0, y.preventDefault(), setTimeout(() => setTimeout(() => g(y))))
            }
            const h = C(() => te({
                "aria-haspopup": "menu",
                "aria-expanded": String(a.value),
                "aria-owns": i.value,
                onKeydown: g
            }, e.activatorProps));
            return ne(() => {
                const y = ea.filterProps(e);
                return m(ea, te({
                    ref: s,
                    id: i.value,
                    class: ["v-menu", e.class],
                    style: e.style
                }, y, {
                    modelValue: a.value,
                    "onUpdate:modelValue": S => a.value = S,
                    absolute: !0,
                    activatorProps: h.value,
                    location: e.location ? ? (e.submenu ? "end" : "bottom"),
                    "onClick:outside": f,
                    onKeydown: v
                }, l), {
                    activator: n.activator,
                    default: function() {
                        for (var S = arguments.length, b = new Array(S), p = 0; p < S; p++) b[p] = arguments[p];
                        return m(Ve, {
                            root: "VMenu"
                        }, {
                            default: () => {
                                var _;
                                return [(_ = n.default) == null ? void 0 : _.call(n, ...b)]
                            }
                        })
                    }
                })
            }), wn({
                id: i,
                ΨopenChildren: c
            }, s)
        }
    }),
    wB = W({
        active: Boolean,
        disabled: Boolean,
        max: [Number, String],
        value: {
            type: [Number, String],
            default: 0
        },
        ...Se(),
        ...Wn({
            transition: {
                component: Wv
            }
        })
    }, "VCounter"),
    Mu = Z()({
        name: "VCounter",
        functional: !0,
        props: wB(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = C(() => e.max ? `${e.value} / ${e.max}` : String(e.value));
            return ne(() => m(jt, {
                transition: e.transition
            }, {
                default: () => [at(m("div", {
                    class: ["v-counter", {
                        "text-error": e.max && !e.disabled && parseFloat(e.value) > parseFloat(e.max)
                    }, e.class],
                    style: e.style
                }, [n.default ? n.default({
                    counter: a.value,
                    max: e.max,
                    value: e.value
                }) : a.value]), [
                    [bn, e.active]
                ])]
            })), {}
        }
    }),
    kB = W({
        floating: Boolean,
        ...Se()
    }, "VFieldLabel"),
    io = Z()({
        name: "VFieldLabel",
        props: kB(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            return ne(() => m(Yr, {
                class: ["v-field-label", {
                    "v-field-label--floating": e.floating
                }, e.class],
                style: e.style,
                "aria-hidden": e.floating || void 0
            }, n)), {}
        }
    }),
    CB = ["underlined", "outlined", "filled", "solo", "solo-inverted", "solo-filled", "plain"],
    bi = W({
        appendInnerIcon: Pe,
        bgColor: String,
        clearable: Boolean,
        clearIcon: {
            type: Pe,
            default: "$clear"
        },
        active: Boolean,
        centerAffix: {
            type: Boolean,
            default: void 0
        },
        color: String,
        baseColor: String,
        dirty: Boolean,
        disabled: {
            type: Boolean,
            default: null
        },
        error: Boolean,
        flat: Boolean,
        label: String,
        persistentClear: Boolean,
        prependInnerIcon: Pe,
        reverse: Boolean,
        singleLine: Boolean,
        variant: {
            type: String,
            default: "filled",
            validator: e => CB.includes(e)
        },
        "onClick:clear": It(),
        "onClick:appendInner": It(),
        "onClick:prependInner": It(),
        ...Se(),
        ...Ou(),
        ...rt(),
        ...Ne()
    }, "VField"),
    Xr = Z()({
        name: "VField",
        inheritAttrs: !1,
        props: {
            id: String,
            ...qr(),
            ...bi()
        },
        emits: {
            "update:focused": e => !0,
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                attrs: n,
                emit: a,
                slots: l
            } = t;
            const {
                themeClasses: r
            } = je(e), {
                loaderClasses: o
            } = vi(e), {
                focusClasses: i,
                isFocused: s,
                focus: u,
                blur: c
            } = ua(e), {
                InputIcon: d
            } = nw(e), {
                roundedClasses: f
            } = ct(e), {
                rtlClasses: v
            } = xt(), g = C(() => e.dirty || e.active), h = C(() => !e.singleLine && !!(e.label || l.label)), y = Rt(), S = C(() => e.id || `input-${y}`), b = C(() => `${S.value}-messages`), p = Q(), _ = Q(), w = Q(), k = C(() => ["plain", "underlined"].includes(e.variant)), {
                backgroundColorClasses: E,
                backgroundColorStyles: P
            } = Ke(Y(e, "bgColor")), {
                textColorClasses: x,
                textColorStyles: T
            } = Ot(C(() => e.error || e.disabled ? void 0 : g.value && s.value ? e.color : e.baseColor));
            de(g, B => {
                if (h.value) {
                    const $ = p.value.$el,
                        D = _.value.$el;
                    requestAnimationFrame(() => {
                        const z = Ov($),
                            N = D.getBoundingClientRect(),
                            H = N.x - z.x,
                            F = N.y - z.y - (z.height / 2 - N.height / 2),
                            j = N.width / .75,
                            ae = Math.abs(j - z.width) > 1 ? {
                                maxWidth: ge(j)
                            } : void 0,
                            he = getComputedStyle($),
                            ve = getComputedStyle(D),
                            we = parseFloat(he.transitionDuration) * 1e3 || 150,
                            ee = parseFloat(ve.getPropertyValue("--v-field-label-scale")),
                            G = ve.getPropertyValue("color");
                        $.style.visibility = "visible", D.style.visibility = "hidden", yl($, {
                            transform: `translate(${H}px, ${F}px) scale(${ee})`,
                            color: G,
                            ...ae
                        }, {
                            duration: we,
                            easing: $o,
                            direction: B ? "normal" : "reverse"
                        }).finished.then(() => {
                            $.style.removeProperty("visibility"), D.style.removeProperty("visibility")
                        })
                    })
                }
            }, {
                flush: "post"
            });
            const V = C(() => ({
                isActive: g,
                isFocused: s,
                controlRef: w,
                blur: c,
                focus: u
            }));

            function I(B) {
                B.target !== document.activeElement && B.preventDefault()
            }

            function R(B) {
                var $;
                B.key !== "Enter" && B.key !== " " || (B.preventDefault(), B.stopPropagation(), ($ = e["onClick:clear"]) == null || $.call(e, new MouseEvent("click")))
            }
            return ne(() => {
                var H, F, j;
                const B = e.variant === "outlined",
                    $ = !!(l["prepend-inner"] || e.prependInnerIcon),
                    D = !!(e.clearable || l.clear),
                    z = !!(l["append-inner"] || e.appendInnerIcon || D),
                    N = () => l.label ? l.label({ ...V.value,
                        label: e.label,
                        props: {
                            for: S.value
                        }
                    }) : e.label;
                return m("div", te({
                    class: ["v-field", {
                        "v-field--active": g.value,
                        "v-field--appended": z,
                        "v-field--center-affix": e.centerAffix ? ? !k.value,
                        "v-field--disabled": e.disabled,
                        "v-field--dirty": e.dirty,
                        "v-field--error": e.error,
                        "v-field--flat": e.flat,
                        "v-field--has-background": !!e.bgColor,
                        "v-field--persistent-clear": e.persistentClear,
                        "v-field--prepended": $,
                        "v-field--reverse": e.reverse,
                        "v-field--single-line": e.singleLine,
                        "v-field--no-label": !N(),
                        [`v-field--variant-${e.variant}`]: !0
                    }, r.value, E.value, i.value, o.value, f.value, v.value, e.class],
                    style: [P.value, e.style],
                    onClick: I
                }, n), [m("div", {
                    class: "v-field__overlay"
                }, null), m(mi, {
                    name: "v-field",
                    active: !!e.loading,
                    color: e.error ? "error" : typeof e.loading == "string" ? e.loading : e.color
                }, {
                    default: l.loader
                }), $ && m("div", {
                    key: "prepend",
                    class: "v-field__prepend-inner"
                }, [e.prependInnerIcon && m(d, {
                    key: "prepend-icon",
                    name: "prependInner"
                }, null), (H = l["prepend-inner"]) == null ? void 0 : H.call(l, V.value)]), m("div", {
                    class: "v-field__field",
                    "data-no-activator": ""
                }, [
                    ["filled", "solo", "solo-inverted", "solo-filled"].includes(e.variant) && h.value && m(io, {
                        key: "floating-label",
                        ref: _,
                        class: [x.value],
                        floating: !0,
                        for: S.value,
                        style: T.value
                    }, {
                        default: () => [N()]
                    }), m(io, {
                        ref: p,
                        for: S.value
                    }, {
                        default: () => [N()]
                    }), (F = l.default) == null ? void 0 : F.call(l, { ...V.value,
                        props: {
                            id: S.value,
                            class: "v-field__input",
                            "aria-describedby": b.value
                        },
                        focus: u,
                        blur: c
                    })
                ]), D && m(zv, {
                    key: "clear"
                }, {
                    default: () => [at(m("div", {
                        class: "v-field__clearable",
                        onMousedown: ae => {
                            ae.preventDefault(), ae.stopPropagation()
                        }
                    }, [m(Ve, {
                        defaults: {
                            VIcon: {
                                icon: e.clearIcon
                            }
                        }
                    }, {
                        default: () => [l.clear ? l.clear({ ...V.value,
                            props: {
                                onKeydown: R,
                                onFocus: u,
                                onBlur: c,
                                onClick: e["onClick:clear"]
                            }
                        }) : m(d, {
                            name: "clear",
                            onKeydown: R,
                            onFocus: u,
                            onBlur: c
                        }, null)]
                    })]), [
                        [bn, e.dirty]
                    ])]
                }), z && m("div", {
                    key: "append",
                    class: "v-field__append-inner"
                }, [(j = l["append-inner"]) == null ? void 0 : j.call(l, V.value), e.appendInnerIcon && m(d, {
                    key: "append-icon",
                    name: "appendInner"
                }, null)]), m("div", {
                    class: ["v-field__outline", x.value],
                    style: T.value
                }, [B && m(ye, null, [m("div", {
                    class: "v-field__outline__start"
                }, null), h.value && m("div", {
                    class: "v-field__outline__notch"
                }, [m(io, {
                    ref: _,
                    floating: !0,
                    for: S.value
                }, {
                    default: () => [N()]
                })]), m("div", {
                    class: "v-field__outline__end"
                }, null)]), k.value && h.value && m(io, {
                    ref: _,
                    floating: !0,
                    for: S.value
                }, {
                    default: () => [N()]
                })])])
            }), {
                controlRef: w
            }
        }
    });

function lm(e) {
    const t = Object.keys(Xr.props).filter(n => !ku(n) && n !== "class" && n !== "style");
    return Vv(e, t)
}
const xB = ["color", "file", "time", "date", "datetime-local", "week", "month"],
    Jr = W({
        autofocus: Boolean,
        counter: [Boolean, Number, String],
        counterValue: [Number, Function],
        prefix: String,
        placeholder: String,
        persistentPlaceholder: Boolean,
        persistentCounter: Boolean,
        suffix: String,
        role: String,
        type: {
            type: String,
            default: "text"
        },
        modelModifiers: Object,
        ...Ta(),
        ...bi()
    }, "VTextField"),
    Un = Z()({
        name: "VTextField",
        directives: {
            Intersect: fi
        },
        inheritAttrs: !1,
        props: Jr(),
        emits: {
            "click:control": e => !0,
            "mousedown:control": e => !0,
            "update:focused": e => !0,
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                attrs: n,
                emit: a,
                slots: l
            } = t;
            const r = Ce(e, "modelValue"),
                {
                    isFocused: o,
                    focus: i,
                    blur: s
                } = ua(e),
                u = C(() => typeof e.counterValue == "function" ? e.counterValue(r.value) : typeof e.counterValue == "number" ? e.counterValue : (r.value ? ? "").toString().length),
                c = C(() => {
                    if (n.maxlength) return n.maxlength;
                    if (!(!e.counter || typeof e.counter != "number" && typeof e.counter != "string")) return e.counter
                }),
                d = C(() => ["plain", "underlined"].includes(e.variant));

            function f(k, E) {
                var P, x;
                !e.autofocus || !k || (x = (P = E[0].target) == null ? void 0 : P.focus) == null || x.call(P)
            }
            const v = Q(),
                g = Q(),
                h = Q(),
                y = C(() => xB.includes(e.type) || e.persistentPlaceholder || o.value || e.active);

            function S() {
                var k;
                h.value !== document.activeElement && ((k = h.value) == null || k.focus()), o.value || i()
            }

            function b(k) {
                a("mousedown:control", k), k.target !== h.value && (S(), k.preventDefault())
            }

            function p(k) {
                S(), a("click:control", k)
            }

            function _(k) {
                k.stopPropagation(), S(), Re(() => {
                    r.value = null, Lv(e["onClick:clear"], k)
                })
            }

            function w(k) {
                var P;
                const E = k.target;
                if (r.value = E.value, (P = e.modelModifiers) != null && P.trim && ["text", "search", "password", "tel", "url"].includes(e.type)) {
                    const x = [E.selectionStart, E.selectionEnd];
                    Re(() => {
                        E.selectionStart = x[0], E.selectionEnd = x[1]
                    })
                }
            }
            return ne(() => {
                const k = !!(l.counter || e.counter !== !1 && e.counter != null),
                    E = !!(k || l.details),
                    [P, x] = al(n),
                    {
                        modelValue: T,
                        ...V
                    } = $t.filterProps(e),
                    I = lm(e);
                return m($t, te({
                    ref: v,
                    modelValue: r.value,
                    "onUpdate:modelValue": R => r.value = R,
                    class: ["v-text-field", {
                        "v-text-field--prefixed": e.prefix,
                        "v-text-field--suffixed": e.suffix,
                        "v-input--plain-underlined": d.value
                    }, e.class],
                    style: e.style
                }, P, V, {
                    centerAffix: !d.value,
                    focused: o.value
                }), { ...l,
                    default: R => {
                        let {
                            id: B,
                            isDisabled: $,
                            isDirty: D,
                            isReadonly: z,
                            isValid: N
                        } = R;
                        return m(Xr, te({
                            ref: g,
                            onMousedown: b,
                            onClick: p,
                            "onClick:clear": _,
                            "onClick:prependInner": e["onClick:prependInner"],
                            "onClick:appendInner": e["onClick:appendInner"],
                            role: e.role
                        }, I, {
                            id: B.value,
                            active: y.value || D.value,
                            dirty: D.value || e.dirty,
                            disabled: $.value,
                            focused: o.value,
                            error: N.value === !1
                        }), { ...l,
                            default: H => {
                                let {
                                    props: {
                                        class: F,
                                        ...j
                                    }
                                } = H;
                                const ae = at(m("input", te({
                                    ref: h,
                                    value: r.value,
                                    onInput: w,
                                    autofocus: e.autofocus,
                                    readonly: z.value,
                                    disabled: $.value,
                                    name: e.name,
                                    placeholder: e.placeholder,
                                    size: 1,
                                    type: e.type,
                                    onFocus: S,
                                    onBlur: s
                                }, j, x), null), [
                                    [tn("intersect"), {
                                        handler: f
                                    }, null, {
                                        once: !0
                                    }]
                                ]);
                                return m(ye, null, [e.prefix && m("span", {
                                    class: "v-text-field__prefix"
                                }, [m("span", {
                                    class: "v-text-field__prefix__text"
                                }, [e.prefix])]), l.default ? m("div", {
                                    class: F,
                                    "data-no-activator": ""
                                }, [l.default(), ae]) : $n(ae, {
                                    class: F
                                }), e.suffix && m("span", {
                                    class: "v-text-field__suffix"
                                }, [m("span", {
                                    class: "v-text-field__suffix__text"
                                }, [e.suffix])])])
                            }
                        })
                    },
                    details: E ? R => {
                        var B;
                        return m(ye, null, [(B = l.details) == null ? void 0 : B.call(l, R), k && m(ye, null, [m("span", null, null), m(Mu, {
                            active: e.persistentCounter || o.value,
                            value: u.value,
                            max: c.value,
                            disabled: e.disabled
                        }, l.counter)])])
                    } : void 0
                })
            }), wn({}, v, g, h)
        }
    }),
    PB = W({
        renderless: Boolean,
        ...Se()
    }, "VVirtualScrollItem"),
    Nw = Z()({
        name: "VVirtualScrollItem",
        inheritAttrs: !1,
        props: PB(),
        emits: {
            "update:height": e => !0
        },
        setup(e, t) {
            let {
                attrs: n,
                emit: a,
                slots: l
            } = t;
            const {
                resizeRef: r,
                contentRect: o
            } = Hn(void 0, "border");
            de(() => {
                var i;
                return (i = o.value) == null ? void 0 : i.height
            }, i => {
                i != null && a("update:height", i)
            }), ne(() => {
                var i, s;
                return e.renderless ? m(ye, null, [(i = l.default) == null ? void 0 : i.call(l, {
                    itemRef: r
                })]) : m("div", te({
                    ref: r,
                    class: ["v-virtual-scroll__item", e.class],
                    style: e.style
                }, n), [(s = l.default) == null ? void 0 : s.call(l)])
            })
        }
    }),
    EB = -1,
    IB = 1,
    Ic = 100,
    $w = W({
        itemHeight: {
            type: [Number, String],
            default: null
        },
        height: [Number, String]
    }, "virtual");

function Bw(e, t) {
    const n = On(),
        a = fe(0);
    st(() => {
        a.value = parseFloat(e.itemHeight || 0)
    });
    const l = fe(0),
        r = fe(Math.ceil((parseInt(e.height) || n.height.value) / (a.value || 16)) || 1),
        o = fe(0),
        i = fe(0),
        s = Q(),
        u = Q();
    let c = 0;
    const {
        resizeRef: d,
        contentRect: f
    } = Hn();
    st(() => {
        d.value = s.value
    });
    const v = C(() => {
            var H;
            return s.value === document.documentElement ? n.height.value : ((H = f.value) == null ? void 0 : H.height) || parseInt(e.height) || 0
        }),
        g = C(() => !!(s.value && u.value && v.value && a.value));
    let h = Array.from({
            length: t.value.length
        }),
        y = Array.from({
            length: t.value.length
        });
    const S = fe(0);
    let b = -1;

    function p(H) {
        return h[H] || a.value
    }
    const _ = OD(() => {
            const H = performance.now();
            y[0] = 0;
            const F = t.value.length;
            for (let j = 1; j <= F - 1; j++) y[j] = (y[j - 1] || 0) + p(j - 1);
            S.value = Math.max(S.value, performance.now() - H)
        }, S),
        w = de(g, H => {
            H && (w(), c = u.value.offsetTop, _.immediate(), $(), ~b && Re(() => {
                Ue && window.requestAnimationFrame(() => {
                    z(b), b = -1
                })
            }))
        });
    kt(() => {
        _.clear()
    });

    function k(H, F) {
        const j = h[H],
            ae = a.value;
        a.value = ae ? Math.min(a.value, F) : F, (j !== F || ae !== a.value) && (h[H] = F, _())
    }

    function E(H) {
        return H = ot(H, 0, t.value.length - 1), y[H] || 0
    }

    function P(H) {
        return TB(y, H)
    }
    let x = 0,
        T = 0,
        V = 0;
    de(v, (H, F) => {
        F && ($(), H < F && requestAnimationFrame(() => {
            T = 0, $()
        }))
    });

    function I() {
        if (!s.value || !u.value) return;
        const H = s.value.scrollTop,
            F = performance.now();
        F - V > 500 ? (T = Math.sign(H - x), c = u.value.offsetTop) : T = H - x, x = H, V = F, $()
    }

    function R() {
        !s.value || !u.value || (T = 0, V = 0, $())
    }
    let B = -1;

    function $() {
        cancelAnimationFrame(B), B = requestAnimationFrame(D)
    }

    function D() {
        if (!s.value || !v.value) return;
        const H = x - c,
            F = Math.sign(T),
            j = Math.max(0, H - Ic),
            ae = ot(P(j), 0, t.value.length),
            he = H + v.value + Ic,
            ve = ot(P(he) + 1, ae + 1, t.value.length);
        if ((F !== EB || ae < l.value) && (F !== IB || ve > r.value)) {
            const we = E(l.value) - E(ae),
                ee = E(ve) - E(r.value);
            Math.max(we, ee) > Ic ? (l.value = ae, r.value = ve) : (ae <= 0 && (l.value = ae), ve >= t.value.length && (r.value = ve))
        }
        o.value = E(l.value), i.value = E(t.value.length) - E(r.value)
    }

    function z(H) {
        const F = E(H);
        !s.value || H && !F ? b = H : s.value.scrollTop = F
    }
    const N = C(() => t.value.slice(l.value, r.value).map((H, F) => ({
        raw: H,
        index: F + l.value
    })));
    return de(t, () => {
        h = Array.from({
            length: t.value.length
        }), y = Array.from({
            length: t.value.length
        }), _.immediate(), $()
    }, {
        deep: !0
    }), {
        calculateVisibleItems: $,
        containerRef: s,
        markerRef: u,
        computedItems: N,
        paddingTop: o,
        paddingBottom: i,
        scrollToIndex: z,
        handleScroll: I,
        handleScrollend: R,
        handleItemResize: k
    }
}

function TB(e, t) {
    let n = e.length - 1,
        a = 0,
        l = 0,
        r = null,
        o = -1;
    if (e[n] < t) return n;
    for (; a <= n;)
        if (l = a + n >> 1, r = e[l], r > t) n = l - 1;
        else if (r < t) o = l, a = l + 1;
    else return r === t ? l : a;
    return o
}
const VB = W({
        items: {
            type: Array,
            default: () => []
        },
        renderless: Boolean,
        ...$w(),
        ...Se(),
        ...bt()
    }, "VVirtualScroll"),
    Nu = Z()({
        name: "VVirtualScroll",
        props: VB(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = ut("VVirtualScroll"),
                {
                    dimensionStyles: l
                } = pt(e),
                {
                    calculateVisibleItems: r,
                    containerRef: o,
                    markerRef: i,
                    handleScroll: s,
                    handleScrollend: u,
                    handleItemResize: c,
                    scrollToIndex: d,
                    paddingTop: f,
                    paddingBottom: v,
                    computedItems: g
                } = Bw(e, Y(e, "items"));
            return Yt(() => e.renderless, () => {
                function h() {
                    var b, p;
                    const S = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1) ? "addEventListener" : "removeEventListener";
                    o.value === document.documentElement ? (document[S]("scroll", s, {
                        passive: !0
                    }), document[S]("scrollend", u)) : ((b = o.value) == null || b[S]("scroll", s, {
                        passive: !0
                    }), (p = o.value) == null || p[S]("scrollend", u))
                }
                it(() => {
                    o.value = Nv(a.vnode.el, !0), h(!0)
                }), kt(h)
            }), ne(() => {
                const h = g.value.map(y => m(Nw, {
                    key: y.index,
                    renderless: e.renderless,
                    "onUpdate:height": S => c(y.index, S)
                }, {
                    default: S => {
                        var b;
                        return (b = n.default) == null ? void 0 : b.call(n, {
                            item: y.raw,
                            index: y.index,
                            ...S
                        })
                    }
                }));
                return e.renderless ? m(ye, null, [m("div", {
                    ref: i,
                    class: "v-virtual-scroll__spacer",
                    style: {
                        paddingTop: ge(f.value)
                    }
                }, null), h, m("div", {
                    class: "v-virtual-scroll__spacer",
                    style: {
                        paddingBottom: ge(v.value)
                    }
                }, null)]) : m("div", {
                    ref: o,
                    class: ["v-virtual-scroll", e.class],
                    onScrollPassive: s,
                    onScrollend: u,
                    style: [l.value, e.style]
                }, [m("div", {
                    ref: i,
                    class: "v-virtual-scroll__container",
                    style: {
                        paddingTop: ge(f.value),
                        paddingBottom: ge(v.value)
                    }
                }, [h])])
            }), {
                calculateVisibleItems: r,
                scrollToIndex: d
            }
        }
    });

function rm(e, t) {
    const n = fe(!1);
    let a;

    function l(i) {
        cancelAnimationFrame(a), n.value = !0, a = requestAnimationFrame(() => {
            a = requestAnimationFrame(() => {
                n.value = !1
            })
        })
    }
    async function r() {
        await new Promise(i => requestAnimationFrame(i)), await new Promise(i => requestAnimationFrame(i)), await new Promise(i => requestAnimationFrame(i)), await new Promise(i => {
            if (n.value) {
                const s = de(n, () => {
                    s(), i()
                })
            } else i()
        })
    }
    async function o(i) {
        var c, d;
        if (i.key === "Tab" && ((c = t.value) == null || c.focus()), !["PageDown", "PageUp", "Home", "End"].includes(i.key)) return;
        const s = (d = e.value) == null ? void 0 : d.$el;
        if (!s) return;
        (i.key === "Home" || i.key === "End") && s.scrollTo({
            top: i.key === "Home" ? 0 : s.scrollHeight,
            behavior: "smooth"
        }), await r();
        const u = s.querySelectorAll(":scope > :not(.v-virtual-scroll__spacer)");
        if (i.key === "PageDown" || i.key === "Home") {
            const f = s.getBoundingClientRect().top;
            for (const v of u)
                if (v.getBoundingClientRect().top >= f) {
                    v.focus();
                    break
                }
        } else {
            const f = s.getBoundingClientRect().bottom;
            for (const v of [...u].reverse())
                if (v.getBoundingClientRect().bottom <= f) {
                    v.focus();
                    break
                }
        }
    }
    return {
        onScrollPassive: l,
        onKeydown: o
    }
}
const om = W({
        chips: Boolean,
        closableChips: Boolean,
        closeText: {
            type: String,
            default: "$vuetify.close"
        },
        openText: {
            type: String,
            default: "$vuetify.open"
        },
        eager: Boolean,
        hideNoData: Boolean,
        hideSelected: Boolean,
        listProps: {
            type: Object
        },
        menu: Boolean,
        menuIcon: {
            type: Pe,
            default: "$dropdown"
        },
        menuProps: {
            type: Object
        },
        multiple: Boolean,
        noDataText: {
            type: String,
            default: "$vuetify.noDataText"
        },
        openOnClear: Boolean,
        itemColor: String,
        ...kw({
            itemChildren: !1
        })
    }, "Select"),
    AB = W({ ...om(),
        ...We(Jr({
            modelValue: null,
            role: "combobox"
        }), ["validationValue", "dirty", "appendInnerIcon"]),
        ...Wn({
            transition: {
                component: Tu
            }
        })
    }, "VSelect"),
    im = Z()({
        name: "VSelect",
        props: AB(),
        emits: {
            "update:focused": e => !0,
            "update:modelValue": e => !0,
            "update:menu": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                t: a
            } = Qe(), l = Q(), r = Q(), o = Q(), i = Ce(e, "menu"), s = C({
                get: () => i.value,
                set: H => {
                    var F;
                    i.value && !H && ((F = r.value) != null && F.ΨopenChildren.size) || (i.value = H)
                }
            }), {
                items: u,
                transformIn: c,
                transformOut: d
            } = Qv(e), f = Ce(e, "modelValue", [], H => c(H === null ? [null] : nt(H)), H => {
                const F = d(H);
                return e.multiple ? F : F[0] ? ? null
            }), v = C(() => typeof e.counterValue == "function" ? e.counterValue(f.value) : typeof e.counterValue == "number" ? e.counterValue : f.value.length), g = gi(), h = C(() => f.value.map(H => H.value)), y = fe(!1), S = C(() => s.value ? e.closeText : e.openText);
            let b = "",
                p;
            const _ = C(() => e.hideSelected ? u.value.filter(H => !f.value.some(F => e.valueComparator(F, H))) : u.value),
                w = C(() => e.hideNoData && !_.value.length || e.readonly || (g == null ? void 0 : g.isReadonly.value)),
                k = C(() => {
                    var H;
                    return { ...e.menuProps,
                        activatorProps: { ...((H = e.menuProps) == null ? void 0 : H.activatorProps) || {},
                            "aria-haspopup": "listbox"
                        }
                    }
                }),
                E = Q(),
                P = rm(E, l);

            function x(H) {
                e.openOnClear && (s.value = !0)
            }

            function T() {
                w.value || (s.value = !s.value)
            }

            function V(H) {
                Ls(H) && I(H)
            }

            function I(H) {
                var he, ve;
                if (!H.key || e.readonly || g != null && g.isReadonly.value) return;
                ["Enter", " ", "ArrowDown", "ArrowUp", "Home", "End"].includes(H.key) && H.preventDefault(), ["Enter", "ArrowDown", " "].includes(H.key) && (s.value = !0), ["Escape", "Tab"].includes(H.key) && (s.value = !1), H.key === "Home" ? (he = E.value) == null || he.focus("first") : H.key === "End" && ((ve = E.value) == null || ve.focus("last"));
                const F = 1e3;
                if (e.multiple || !Ls(H)) return;
                const j = performance.now();
                j - p > F && (b = ""), b += H.key.toLowerCase(), p = j;
                const ae = u.value.find(we => we.title.toLowerCase().startsWith(b));
                if (ae !== void 0) {
                    f.value = [ae];
                    const we = _.value.indexOf(ae);
                    Ue && window.requestAnimationFrame(() => {
                        var ee;
                        we >= 0 && ((ee = o.value) == null || ee.scrollToIndex(we))
                    })
                }
            }

            function R(H) {
                let F = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
                if (!H.props.disabled)
                    if (e.multiple) {
                        const j = f.value.findIndex(he => e.valueComparator(he.value, H.value)),
                            ae = F ? ? !~j;
                        if (~j) {
                            const he = ae ? [...f.value, H] : [...f.value];
                            he.splice(j, 1), f.value = he
                        } else ae && (f.value = [...f.value, H])
                    } else {
                        const j = F !== !1;
                        f.value = j ? [H] : [], Re(() => {
                            s.value = !1
                        })
                    }
            }

            function B(H) {
                var F;
                (F = E.value) != null && F.$el.contains(H.relatedTarget) || (s.value = !1)
            }

            function $() {
                var H;
                e.eager && ((H = o.value) == null || H.calculateVisibleItems())
            }

            function D() {
                var H;
                y.value && ((H = l.value) == null || H.focus())
            }

            function z(H) {
                y.value = !0
            }

            function N(H) {
                if (H == null) f.value = [];
                else if (Or(l.value, ":autofill") || Or(l.value, ":-webkit-autofill")) {
                    const F = u.value.find(j => j.title === H);
                    F && R(F)
                } else l.value && (l.value.value = "")
            }
            return de(s, () => {
                if (!e.hideSelected && s.value && f.value.length) {
                    const H = _.value.findIndex(F => f.value.some(j => e.valueComparator(j.value, F.value)));
                    Ue && window.requestAnimationFrame(() => {
                        var F;
                        H >= 0 && ((F = o.value) == null || F.scrollToIndex(H))
                    })
                }
            }), de(() => e.items, (H, F) => {
                s.value || y.value && !F.length && H.length && (s.value = !0)
            }), ne(() => {
                const H = !!(e.chips || n.chip),
                    F = !!(!e.hideNoData || _.value.length || n["prepend-item"] || n["append-item"] || n["no-data"]),
                    j = f.value.length > 0,
                    ae = Un.filterProps(e),
                    he = j || !y.value && e.label && !e.persistentPlaceholder ? void 0 : e.placeholder;
                return m(Un, te({
                    ref: l
                }, ae, {
                    modelValue: f.value.map(ve => ve.props.value).join(", "),
                    "onUpdate:modelValue": N,
                    focused: y.value,
                    "onUpdate:focused": ve => y.value = ve,
                    validationValue: f.externalValue,
                    counterValue: v.value,
                    dirty: j,
                    class: ["v-select", {
                        "v-select--active-menu": s.value,
                        "v-select--chips": !!e.chips,
                        [`v-select--${e.multiple?"multiple":"single"}`]: !0,
                        "v-select--selected": f.value.length,
                        "v-select--selection-slot": !!n.selection
                    }, e.class],
                    style: e.style,
                    inputmode: "none",
                    placeholder: he,
                    "onClick:clear": x,
                    "onMousedown:control": T,
                    onBlur: B,
                    onKeydown: I,
                    "aria-label": a(S.value),
                    title: a(S.value)
                }), { ...n,
                    default: () => m(ye, null, [m(Ol, te({
                        ref: r,
                        modelValue: s.value,
                        "onUpdate:modelValue": ve => s.value = ve,
                        activator: "parent",
                        contentClass: "v-select__content",
                        disabled: w.value,
                        eager: e.eager,
                        maxHeight: 310,
                        openOnClick: !1,
                        closeOnContentClick: !1,
                        transition: e.transition,
                        onAfterEnter: $,
                        onAfterLeave: D
                    }, k.value), {
                        default: () => [F && m(Mr, te({
                            ref: E,
                            selected: h.value,
                            selectStrategy: e.multiple ? "independent" : "single-independent",
                            onMousedown: ve => ve.preventDefault(),
                            onKeydown: V,
                            onFocusin: z,
                            tabindex: "-1",
                            "aria-live": "polite",
                            color: e.itemColor ? ? e.color
                        }, P, e.listProps), {
                            default: () => {
                                var ve, we, ee;
                                return [(ve = n["prepend-item"]) == null ? void 0 : ve.call(n), !_.value.length && !e.hideNoData && (((we = n["no-data"]) == null ? void 0 : we.call(n)) ? ? m(jn, {
                                    title: a(e.noDataText)
                                }, null)), m(Nu, {
                                    ref: o,
                                    renderless: !0,
                                    items: _.value
                                }, {
                                    default: G => {
                                        var pe;
                                        let {
                                            item: le,
                                            index: se,
                                            itemRef: ce
                                        } = G;
                                        const re = te(le.props, {
                                            ref: ce,
                                            key: se,
                                            onClick: () => R(le, null)
                                        });
                                        return ((pe = n.item) == null ? void 0 : pe.call(n, {
                                            item: le,
                                            index: se,
                                            props: re
                                        })) ? ? m(jn, te(re, {
                                            role: "option"
                                        }), {
                                            prepend: A => {
                                                let {
                                                    isSelected: O
                                                } = A;
                                                return m(ye, null, [e.multiple && !e.hideSelected ? m(Qn, {
                                                    key: le.value,
                                                    modelValue: O,
                                                    ripple: !1,
                                                    tabindex: "-1"
                                                }, null) : void 0, le.props.prependAvatar && m(yn, {
                                                    image: le.props.prependAvatar
                                                }, null), le.props.prependIcon && m(Be, {
                                                    icon: le.props.prependIcon
                                                }, null)])
                                            }
                                        })
                                    }
                                }), (ee = n["append-item"]) == null ? void 0 : ee.call(n)]
                            }
                        })]
                    }), f.value.map((ve, we) => {
                        function ee(ce) {
                            ce.stopPropagation(), ce.preventDefault(), R(ve, !1)
                        }
                        const G = {
                                "onClick:close": ee,
                                onKeydown(ce) {
                                    ce.key !== "Enter" && ce.key !== " " || (ce.preventDefault(), ce.stopPropagation(), ee(ce))
                                },
                                onMousedown(ce) {
                                    ce.preventDefault(), ce.stopPropagation()
                                },
                                modelValue: !0,
                                "onUpdate:modelValue": void 0
                            },
                            le = H ? !!n.chip : !!n.selection,
                            se = le ? Cu(H ? n.chip({
                                item: ve,
                                index: we,
                                props: G
                            }) : n.selection({
                                item: ve,
                                index: we
                            })) : void 0;
                        if (!(le && !se)) return m("div", {
                            key: ve.value,
                            class: "v-select__selection"
                        }, [H ? n.chip ? m(Ve, {
                            key: "chip-defaults",
                            defaults: {
                                VChip: {
                                    closable: e.closableChips,
                                    size: "small",
                                    text: ve.title
                                }
                            }
                        }, {
                            default: () => [se]
                        }) : m(Zl, te({
                            key: "chip",
                            closable: e.closableChips,
                            size: "small",
                            text: ve.title,
                            disabled: ve.props.disabled
                        }, G), null) : se ? ? m("span", {
                            class: "v-select__selection-text"
                        }, [ve.title, e.multiple && we < f.value.length - 1 && m("span", {
                            class: "v-select__selection-comma"
                        }, [hn(",")])])])
                    })]),
                    "append-inner": function() {
                        var G;
                        for (var ve = arguments.length, we = new Array(ve), ee = 0; ee < ve; ee++) we[ee] = arguments[ee];
                        return m(ye, null, [(G = n["append-inner"]) == null ? void 0 : G.call(n, ...we), e.menuIcon ? m(Be, {
                            class: "v-select__menu-icon",
                            icon: e.menuIcon
                        }, null) : void 0])
                    }
                })
            }), wn({
                isFocused: y,
                menu: s,
                select: R
            }, l)
        }
    }),
    LB = (e, t, n) => e == null || t == null ? -1 : e.toString().toLocaleLowerCase().indexOf(t.toString().toLocaleLowerCase()),
    Zr = W({
        customFilter: Function,
        customKeyFilter: Object,
        filterKeys: [Array, String],
        filterMode: {
            type: String,
            default: "intersection"
        },
        noFilter: Boolean
    }, "filter");

function OB(e, t, n) {
    var i;
    const a = [],
        l = (n == null ? void 0 : n.default) ? ? LB,
        r = n != null && n.filterKeys ? nt(n.filterKeys) : !1,
        o = Object.keys((n == null ? void 0 : n.customKeyFilter) ? ? {}).length;
    if (!(e != null && e.length)) return a;
    e: for (let s = 0; s < e.length; s++) {
        const [u, c = u] = nt(e[s]), d = {}, f = {};
        let v = -1;
        if ((t || o > 0) && !(n != null && n.noFilter)) {
            if (typeof u == "object") {
                const y = r || Object.keys(c);
                for (const S of y) {
                    const b = vt(c, S),
                        p = (i = n == null ? void 0 : n.customKeyFilter) == null ? void 0 : i[S];
                    if (v = p ? p(b, t, u) : l(b, t, u), v !== -1 && v !== !1) p ? d[S] = v : f[S] = v;
                    else if ((n == null ? void 0 : n.filterMode) === "every") continue e
                }
            } else v = l(u, t, u), v !== -1 && v !== !1 && (f.title = v);
            const g = Object.keys(f).length,
                h = Object.keys(d).length;
            if (!g && !h || (n == null ? void 0 : n.filterMode) === "union" && h !== o && !g || (n == null ? void 0 : n.filterMode) === "intersection" && (h !== o || !g)) continue
        }
        a.push({
            index: s,
            matches: { ...f,
                ...d
            }
        })
    }
    return a
}

function Qr(e, t, n, a) {
    const l = Q([]),
        r = Q(new Map),
        o = C(() => a != null && a.transform ? Ie(t).map(s => [s, a.transform(s)]) : Ie(t));
    st(() => {
        const s = typeof n == "function" ? n() : Ie(n),
            u = typeof s != "string" && typeof s != "number" ? "" : String(s),
            c = OB(o.value, u, {
                customKeyFilter: { ...e.customKeyFilter,
                    ...Ie(a == null ? void 0 : a.customKeyFilter)
                },
                default: e.customFilter,
                filterKeys: e.filterKeys,
                filterMode: e.filterMode,
                noFilter: e.noFilter
            }),
            d = Ie(t),
            f = [],
            v = new Map;
        c.forEach(g => {
            let {
                index: h,
                matches: y
            } = g;
            const S = d[h];
            f.push(S), v.set(S.value, y)
        }), l.value = f, r.value = v
    });

    function i(s) {
        return r.value.get(s.value)
    }
    return {
        filteredItems: l,
        filteredMatches: r,
        getMatches: i
    }
}

function RB(e, t, n) {
    if (t == null) return e;
    if (Array.isArray(t)) throw new Error("Multiple matches is not implemented");
    return typeof t == "number" && ~t ? m(ye, null, [m("span", {
        class: "v-autocomplete__unmask"
    }, [e.substr(0, t)]), m("span", {
        class: "v-autocomplete__mask"
    }, [e.substr(t, n)]), m("span", {
        class: "v-autocomplete__unmask"
    }, [e.substr(t + n)])]) : e
}
const DB = W({
        autoSelectFirst: {
            type: [Boolean, String]
        },
        clearOnSelect: Boolean,
        search: String,
        ...Zr({
            filterKeys: ["title"]
        }),
        ...om(),
        ...We(Jr({
            modelValue: null,
            role: "combobox"
        }), ["validationValue", "dirty", "appendInnerIcon"]),
        ...Wn({
            transition: !1
        })
    }, "VAutocomplete"),
    MB = Z()({
        name: "VAutocomplete",
        props: DB(),
        emits: {
            "update:focused": e => !0,
            "update:search": e => !0,
            "update:modelValue": e => !0,
            "update:menu": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                t: a
            } = Qe(), l = Q(), r = fe(!1), o = fe(!0), i = fe(!1), s = Q(), u = Q(), c = Ce(e, "menu"), d = C({
                get: () => c.value,
                set: re => {
                    var pe;
                    c.value && !re && ((pe = s.value) != null && pe.ΨopenChildren.size) || (c.value = re)
                }
            }), f = fe(-1), v = C(() => {
                var re;
                return (re = l.value) == null ? void 0 : re.color
            }), g = C(() => d.value ? e.closeText : e.openText), {
                items: h,
                transformIn: y,
                transformOut: S
            } = Qv(e), {
                textColorClasses: b,
                textColorStyles: p
            } = Ot(v), _ = Ce(e, "search", ""), w = Ce(e, "modelValue", [], re => y(re === null ? [null] : nt(re)), re => {
                const pe = S(re);
                return e.multiple ? pe : pe[0] ? ? null
            }), k = C(() => typeof e.counterValue == "function" ? e.counterValue(w.value) : typeof e.counterValue == "number" ? e.counterValue : w.value.length), E = gi(), {
                filteredItems: P,
                getMatches: x
            } = Qr(e, h, () => o.value ? "" : _.value), T = C(() => e.hideSelected ? P.value.filter(re => !w.value.some(pe => pe.value === re.value)) : P.value), V = C(() => !!(e.chips || n.chip)), I = C(() => V.value || !!n.selection), R = C(() => w.value.map(re => re.props.value)), B = C(() => {
                var pe;
                return (e.autoSelectFirst === !0 || e.autoSelectFirst === "exact" && _.value === ((pe = T.value[0]) == null ? void 0 : pe.title)) && T.value.length > 0 && !o.value && !i.value
            }), $ = C(() => e.hideNoData && !T.value.length || e.readonly || (E == null ? void 0 : E.isReadonly.value)), D = Q(), z = rm(D, l);

            function N(re) {
                e.openOnClear && (d.value = !0), _.value = ""
            }

            function H() {
                $.value || (d.value = !0)
            }

            function F(re) {
                $.value || (r.value && (re.preventDefault(), re.stopPropagation()), d.value = !d.value)
            }

            function j(re) {
                var pe;
                Ls(re) && ((pe = l.value) == null || pe.focus())
            }

            function ae(re) {
                var O, K, J;
                if (e.readonly || E != null && E.isReadonly.value) return;
                const pe = l.value.selectionStart,
                    A = w.value.length;
                if ((f.value > -1 || ["Enter", "ArrowDown", "ArrowUp"].includes(re.key)) && re.preventDefault(), ["Enter", "ArrowDown"].includes(re.key) && (d.value = !0), ["Escape"].includes(re.key) && (d.value = !1), B.value && ["Enter", "Tab"].includes(re.key) && !w.value.some(X => {
                        let {
                            value: ue
                        } = X;
                        return ue === T.value[0].value
                    }) && ce(T.value[0]), re.key === "ArrowDown" && B.value && ((O = D.value) == null || O.focus("next")), ["Backspace", "Delete"].includes(re.key)) {
                    if (!e.multiple && I.value && w.value.length > 0 && !_.value) return ce(w.value[0], !1);
                    if (~f.value) {
                        const X = f.value;
                        ce(w.value[f.value], !1), f.value = X >= A - 1 ? A - 2 : X
                    } else re.key === "Backspace" && !_.value && (f.value = A - 1)
                }
                if (e.multiple) {
                    if (re.key === "ArrowLeft") {
                        if (f.value < 0 && pe > 0) return;
                        const X = f.value > -1 ? f.value - 1 : A - 1;
                        w.value[X] ? f.value = X : (f.value = -1, l.value.setSelectionRange((K = _.value) == null ? void 0 : K.length, (J = _.value) == null ? void 0 : J.length))
                    }
                    if (re.key === "ArrowRight") {
                        if (f.value < 0) return;
                        const X = f.value + 1;
                        w.value[X] ? f.value = X : (f.value = -1, l.value.setSelectionRange(0, 0))
                    }
                }
            }

            function he(re) {
                if (Or(l.value, ":autofill") || Or(l.value, ":-webkit-autofill")) {
                    const pe = h.value.find(A => A.title === re.target.value);
                    pe && ce(pe)
                }
            }

            function ve() {
                var re;
                e.eager && ((re = u.value) == null || re.calculateVisibleItems())
            }

            function we() {
                var re;
                r.value && (o.value = !0, (re = l.value) == null || re.focus())
            }

            function ee(re) {
                r.value = !0, setTimeout(() => {
                    i.value = !0
                })
            }

            function G(re) {
                i.value = !1
            }

            function le(re) {
                (re == null || re === "" && !e.multiple && !I.value) && (w.value = [])
            }
            const se = fe(!1);

            function ce(re) {
                let pe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
                if (!(!re || re.props.disabled))
                    if (e.multiple) {
                        const A = w.value.findIndex(K => e.valueComparator(K.value, re.value)),
                            O = pe ? ? !~A;
                        if (~A) {
                            const K = O ? [...w.value, re] : [...w.value];
                            K.splice(A, 1), w.value = K
                        } else O && (w.value = [...w.value, re]);
                        e.clearOnSelect && (_.value = "")
                    } else {
                        const A = pe !== !1;
                        w.value = A ? [re] : [], _.value = A && !I.value ? re.title : "", Re(() => {
                            d.value = !1, o.value = !0
                        })
                    }
            }
            return de(r, (re, pe) => {
                var A;
                re !== pe && (re ? (se.value = !0, _.value = e.multiple || I.value ? "" : String(((A = w.value.at(-1)) == null ? void 0 : A.props.title) ? ? ""), o.value = !0, Re(() => se.value = !1)) : (!e.multiple && _.value == null && (w.value = []), d.value = !1, w.value.some(O => {
                    let {
                        title: K
                    } = O;
                    return K === _.value
                }) || (_.value = ""), f.value = -1))
            }), de(_, re => {
                !r.value || se.value || (re && (d.value = !0), o.value = !re)
            }), de(d, () => {
                if (!e.hideSelected && d.value && w.value.length) {
                    const re = T.value.findIndex(pe => w.value.some(A => pe.value === A.value));
                    Ue && window.requestAnimationFrame(() => {
                        var pe;
                        re >= 0 && ((pe = u.value) == null || pe.scrollToIndex(re))
                    })
                }
            }), de(() => e.items, (re, pe) => {
                d.value || r.value && !pe.length && re.length && (d.value = !0)
            }), ne(() => {
                const re = !!(!e.hideNoData || T.value.length || n["prepend-item"] || n["append-item"] || n["no-data"]),
                    pe = w.value.length > 0,
                    A = Un.filterProps(e);
                return m(Un, te({
                    ref: l
                }, A, {
                    modelValue: _.value,
                    "onUpdate:modelValue": [O => _.value = O, le],
                    focused: r.value,
                    "onUpdate:focused": O => r.value = O,
                    validationValue: w.externalValue,
                    counterValue: k.value,
                    dirty: pe,
                    onChange: he,
                    class: ["v-autocomplete", `v-autocomplete--${e.multiple?"multiple":"single"}`, {
                        "v-autocomplete--active-menu": d.value,
                        "v-autocomplete--chips": !!e.chips,
                        "v-autocomplete--selection-slot": !!I.value,
                        "v-autocomplete--selecting-index": f.value > -1
                    }, e.class],
                    style: e.style,
                    readonly: e.readonly,
                    placeholder: pe ? void 0 : e.placeholder,
                    "onClick:clear": N,
                    "onMousedown:control": H,
                    onKeydown: ae
                }), { ...n,
                    default: () => m(ye, null, [m(Ol, te({
                        ref: s,
                        modelValue: d.value,
                        "onUpdate:modelValue": O => d.value = O,
                        activator: "parent",
                        contentClass: "v-autocomplete__content",
                        disabled: $.value,
                        eager: e.eager,
                        maxHeight: 310,
                        openOnClick: !1,
                        closeOnContentClick: !1,
                        transition: e.transition,
                        onAfterEnter: ve,
                        onAfterLeave: we
                    }, e.menuProps), {
                        default: () => [re && m(Mr, te({
                            ref: D,
                            selected: R.value,
                            selectStrategy: e.multiple ? "independent" : "single-independent",
                            onMousedown: O => O.preventDefault(),
                            onKeydown: j,
                            onFocusin: ee,
                            onFocusout: G,
                            tabindex: "-1",
                            "aria-live": "polite",
                            color: e.itemColor ? ? e.color
                        }, z, e.listProps), {
                            default: () => {
                                var O, K, J;
                                return [(O = n["prepend-item"]) == null ? void 0 : O.call(n), !T.value.length && !e.hideNoData && (((K = n["no-data"]) == null ? void 0 : K.call(n)) ? ? m(jn, {
                                    title: a(e.noDataText)
                                }, null)), m(Nu, {
                                    ref: u,
                                    renderless: !0,
                                    items: T.value
                                }, {
                                    default: X => {
                                        var U;
                                        let {
                                            item: ue,
                                            index: be,
                                            itemRef: L
                                        } = X;
                                        const M = te(ue.props, {
                                            ref: L,
                                            key: be,
                                            active: B.value && be === 0 ? !0 : void 0,
                                            onClick: () => ce(ue, null)
                                        });
                                        return ((U = n.item) == null ? void 0 : U.call(n, {
                                            item: ue,
                                            index: be,
                                            props: M
                                        })) ? ? m(jn, te(M, {
                                            role: "option"
                                        }), {
                                            prepend: ie => {
                                                let {
                                                    isSelected: _e
                                                } = ie;
                                                return m(ye, null, [e.multiple && !e.hideSelected ? m(Qn, {
                                                    key: ue.value,
                                                    modelValue: _e,
                                                    ripple: !1,
                                                    tabindex: "-1"
                                                }, null) : void 0, ue.props.prependAvatar && m(yn, {
                                                    image: ue.props.prependAvatar
                                                }, null), ue.props.prependIcon && m(Be, {
                                                    icon: ue.props.prependIcon
                                                }, null)])
                                            },
                                            title: () => {
                                                var ie, _e;
                                                return o.value ? ue.title : RB(ue.title, (ie = x(ue)) == null ? void 0 : ie.title, ((_e = _.value) == null ? void 0 : _e.length) ? ? 0)
                                            }
                                        })
                                    }
                                }), (J = n["append-item"]) == null ? void 0 : J.call(n)]
                            }
                        })]
                    }), w.value.map((O, K) => {
                        function J(L) {
                            L.stopPropagation(), L.preventDefault(), ce(O, !1)
                        }
                        const X = {
                                "onClick:close": J,
                                onKeydown(L) {
                                    L.key !== "Enter" && L.key !== " " || (L.preventDefault(), L.stopPropagation(), J(L))
                                },
                                onMousedown(L) {
                                    L.preventDefault(), L.stopPropagation()
                                },
                                modelValue: !0,
                                "onUpdate:modelValue": void 0
                            },
                            ue = V.value ? !!n.chip : !!n.selection,
                            be = ue ? Cu(V.value ? n.chip({
                                item: O,
                                index: K,
                                props: X
                            }) : n.selection({
                                item: O,
                                index: K
                            })) : void 0;
                        if (!(ue && !be)) return m("div", {
                            key: O.value,
                            class: ["v-autocomplete__selection", K === f.value && ["v-autocomplete__selection--selected", b.value]],
                            style: K === f.value ? p.value : {}
                        }, [V.value ? n.chip ? m(Ve, {
                            key: "chip-defaults",
                            defaults: {
                                VChip: {
                                    closable: e.closableChips,
                                    size: "small",
                                    text: O.title
                                }
                            }
                        }, {
                            default: () => [be]
                        }) : m(Zl, te({
                            key: "chip",
                            closable: e.closableChips,
                            size: "small",
                            text: O.title,
                            disabled: O.props.disabled
                        }, X), null) : be ? ? m("span", {
                            class: "v-autocomplete__selection-text"
                        }, [O.title, e.multiple && K < w.value.length - 1 && m("span", {
                            class: "v-autocomplete__selection-comma"
                        }, [hn(",")])])])
                    })]),
                    "append-inner": function() {
                        var X;
                        for (var O = arguments.length, K = new Array(O), J = 0; J < O; J++) K[J] = arguments[J];
                        return m(ye, null, [(X = n["append-inner"]) == null ? void 0 : X.call(n, ...K), e.menuIcon ? m(Be, {
                            class: "v-autocomplete__menu-icon",
                            icon: e.menuIcon,
                            onMousedown: F,
                            onClick: tS,
                            "aria-label": a(g.value),
                            title: a(g.value),
                            tabindex: "-1"
                        }, null) : void 0])
                    }
                })
            }), wn({
                isFocused: r,
                isPristine: o,
                menu: d,
                search: _,
                filteredItems: P,
                select: ce
            }, l)
        }
    }),
    NB = W({
        bordered: Boolean,
        color: String,
        content: [Number, String],
        dot: Boolean,
        floating: Boolean,
        icon: Pe,
        inline: Boolean,
        label: {
            type: String,
            default: "$vuetify.badge"
        },
        max: [Number, String],
        modelValue: {
            type: Boolean,
            default: !0
        },
        offsetX: [Number, String],
        offsetY: [Number, String],
        textColor: String,
        ...Se(),
        ...Ea({
            location: "top end"
        }),
        ...rt(),
        ...Ae(),
        ...Ne(),
        ...Wn({
            transition: "scale-rotate-transition"
        })
    }, "VBadge"),
    Fw = Z()({
        name: "VBadge",
        inheritAttrs: !1,
        props: NB(),
        setup(e, t) {
            const {
                backgroundColorClasses: n,
                backgroundColorStyles: a
            } = Ke(Y(e, "color")), {
                roundedClasses: l
            } = ct(e), {
                t: r
            } = Qe(), {
                textColorClasses: o,
                textColorStyles: i
            } = Ot(Y(e, "textColor")), {
                themeClasses: s
            } = IS(), {
                locationStyles: u
            } = Jl(e, !0, c => (e.floating ? e.dot ? 2 : 4 : e.dot ? 8 : 12) + (["top", "bottom"].includes(c) ? +(e.offsetY ? ? 0) : ["left", "right"].includes(c) ? +(e.offsetX ? ? 0) : 0));
            return ne(() => {
                const c = Number(e.content),
                    d = !e.max || isNaN(c) ? e.content : c <= +e.max ? c : `${e.max}+`,
                    [f, v] = Ld(t.attrs, ["aria-atomic", "aria-label", "aria-live", "role", "title"]);
                return m(e.tag, te({
                    class: ["v-badge", {
                        "v-badge--bordered": e.bordered,
                        "v-badge--dot": e.dot,
                        "v-badge--floating": e.floating,
                        "v-badge--inline": e.inline
                    }, e.class]
                }, v, {
                    style: e.style
                }), {
                    default: () => {
                        var g, h;
                        return [m("div", {
                            class: "v-badge__wrapper"
                        }, [(h = (g = t.slots).default) == null ? void 0 : h.call(g), m(jt, {
                            transition: e.transition
                        }, {
                            default: () => {
                                var y, S;
                                return [at(m("span", te({
                                    class: ["v-badge__badge", s.value, n.value, l.value, o.value],
                                    style: [a.value, i.value, e.inline ? {} : u.value],
                                    "aria-atomic": "true",
                                    "aria-label": r(e.label, c),
                                    "aria-live": "polite",
                                    role: "status"
                                }, f), [e.dot ? void 0 : t.slots.badge ? (S = (y = t.slots).badge) == null ? void 0 : S.call(y) : e.icon ? m(Be, {
                                    icon: e.icon
                                }, null) : d]), [
                                    [bn, e.modelValue]
                                ])]
                            }
                        })])]
                    }
                })
            }), {}
        }
    }),
    $B = W({
        color: String,
        density: String,
        ...Se()
    }, "VBannerActions"),
    Hw = Z()({
        name: "VBannerActions",
        props: $B(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            return lt({
                VBtn: {
                    color: e.color,
                    density: e.density,
                    slim: !0,
                    variant: "text"
                }
            }), ne(() => {
                var a;
                return m("div", {
                    class: ["v-banner-actions", e.class],
                    style: e.style
                }, [(a = n.default) == null ? void 0 : a.call(n)])
            }), {}
        }
    }),
    jw = oa("v-banner-text"),
    BB = W({
        avatar: String,
        bgColor: String,
        color: String,
        icon: Pe,
        lines: String,
        stacked: Boolean,
        sticky: Boolean,
        text: String,
        ...an(),
        ...Se(),
        ...Vt(),
        ...bt(),
        ...Ul({
            mobile: null
        }),
        ...Pt(),
        ...Ea(),
        ...zr(),
        ...rt(),
        ...Ae(),
        ...Ne()
    }, "VBanner"),
    FB = Z()({
        name: "VBanner",
        props: BB(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                backgroundColorClasses: a,
                backgroundColorStyles: l
            } = Ke(e, "bgColor"), {
                borderClasses: r
            } = Sn(e), {
                densityClasses: o
            } = zt(e), {
                displayClasses: i,
                mobile: s
            } = On(e), {
                dimensionStyles: u
            } = pt(e), {
                elevationClasses: c
            } = Dt(e), {
                locationStyles: d
            } = Jl(e), {
                positionClasses: f
            } = Kr(e), {
                roundedClasses: v
            } = ct(e), {
                themeClasses: g
            } = je(e), h = Y(e, "color"), y = Y(e, "density");
            lt({
                VBannerActions: {
                    color: h,
                    density: y
                }
            }), ne(() => {
                const S = !!(e.text || n.text),
                    b = !!(e.avatar || e.icon),
                    p = !!(b || n.prepend);
                return m(e.tag, {
                    class: ["v-banner", {
                        "v-banner--stacked": e.stacked || s.value,
                        "v-banner--sticky": e.sticky,
                        [`v-banner--${e.lines}-line`]: !!e.lines
                    }, g.value, a.value, r.value, o.value, i.value, c.value, f.value, v.value, e.class],
                    style: [l.value, u.value, d.value, e.style],
                    role: "banner"
                }, {
                    default: () => {
                        var _;
                        return [p && m("div", {
                            key: "prepend",
                            class: "v-banner__prepend"
                        }, [n.prepend ? m(Ve, {
                            key: "prepend-defaults",
                            disabled: !b,
                            defaults: {
                                VAvatar: {
                                    color: h.value,
                                    density: y.value,
                                    icon: e.icon,
                                    image: e.avatar
                                }
                            }
                        }, n.prepend) : m(yn, {
                            key: "prepend-avatar",
                            color: h.value,
                            density: y.value,
                            icon: e.icon,
                            image: e.avatar
                        }, null)]), m("div", {
                            class: "v-banner__content"
                        }, [S && m(jw, {
                            key: "text"
                        }, {
                            default: () => {
                                var w;
                                return [((w = n.text) == null ? void 0 : w.call(n)) ? ? e.text]
                            }
                        }), (_ = n.default) == null ? void 0 : _.call(n)]), n.actions && m(Hw, {
                            key: "actions"
                        }, n.actions)]
                    }
                })
            })
        }
    }),
    HB = W({
        baseColor: String,
        bgColor: String,
        color: String,
        grow: Boolean,
        mode: {
            type: String,
            validator: e => !e || ["horizontal", "shift"].includes(e)
        },
        height: {
            type: [Number, String],
            default: 56
        },
        active: {
            type: Boolean,
            default: !0
        },
        ...an(),
        ...Se(),
        ...Vt(),
        ...Pt(),
        ...rt(),
        ...Wl({
            name: "bottom-navigation"
        }),
        ...Ae({
            tag: "header"
        }),
        ...Yl({
            selectedClass: "v-btn--selected"
        }),
        ...Ne()
    }, "VBottomNavigation"),
    jB = Z()({
        name: "VBottomNavigation",
        props: HB(),
        emits: {
            "update:active": e => !0,
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                themeClasses: a
            } = IS(), {
                borderClasses: l
            } = Sn(e), {
                backgroundColorClasses: r,
                backgroundColorStyles: o
            } = Ke(Y(e, "bgColor")), {
                densityClasses: i
            } = zt(e), {
                elevationClasses: s
            } = Dt(e), {
                roundedClasses: u
            } = ct(e), {
                ssrBootStyles: c
            } = Kl(), d = C(() => Number(e.height) - (e.density === "comfortable" ? 8 : 0) - (e.density === "compact" ? 16 : 0)), f = Ce(e, "active", e.active), {
                layoutItemStyles: v
            } = zl({
                id: e.name,
                order: C(() => parseInt(e.order, 10)),
                position: C(() => "bottom"),
                layoutSize: C(() => f.value ? d.value : 0),
                elementSize: d,
                active: f,
                absolute: Y(e, "absolute")
            });
            return rl(e, Gv), lt({
                VBtn: {
                    baseColor: Y(e, "baseColor"),
                    color: Y(e, "color"),
                    density: Y(e, "density"),
                    stacked: C(() => e.mode !== "horizontal"),
                    variant: "text"
                }
            }, {
                scoped: !0
            }), ne(() => m(e.tag, {
                class: ["v-bottom-navigation", {
                    "v-bottom-navigation--active": f.value,
                    "v-bottom-navigation--grow": e.grow,
                    "v-bottom-navigation--shift": e.mode === "shift"
                }, a.value, r.value, l.value, i.value, s.value, u.value, e.class],
                style: [o.value, v.value, {
                    height: ge(d.value)
                }, c.value, e.style]
            }, {
                default: () => [n.default && m("div", {
                    class: "v-bottom-navigation__content"
                }, [n.default()])]
            })), {}
        }
    }),
    Uw = W({
        fullscreen: Boolean,
        retainFocus: {
            type: Boolean,
            default: !0
        },
        scrollable: Boolean,
        ...yi({
            origin: "center center",
            scrollStrategy: "block",
            transition: {
                component: Tu
            },
            zIndex: 2400
        })
    }, "VDialog"),
    Xd = Z()({
        name: "VDialog",
        props: Uw(),
        emits: {
            "update:modelValue": e => !0,
            afterEnter: () => !0,
            afterLeave: () => !0
        },
        setup(e, t) {
            let {
                emit: n,
                slots: a
            } = t;
            const l = Ce(e, "modelValue"),
                {
                    scopeId: r
                } = Ql(),
                o = Q();

            function i(c) {
                var v, g;
                const d = c.relatedTarget,
                    f = c.target;
                if (d !== f && ((v = o.value) != null && v.contentEl) && ((g = o.value) != null && g.globalTop) && ![document, o.value.contentEl].includes(f) && !o.value.contentEl.contains(f)) {
                    const h = No(o.value.contentEl);
                    if (!h.length) return;
                    const y = h[0],
                        S = h[h.length - 1];
                    d === y ? S.focus() : y.focus()
                }
            }
            Ue && de(() => l.value && e.retainFocus, c => {
                c ? document.addEventListener("focusin", i) : document.removeEventListener("focusin", i)
            }, {
                immediate: !0
            });

            function s() {
                var c;
                n("afterEnter"), (c = o.value) != null && c.contentEl && !o.value.contentEl.contains(document.activeElement) && o.value.contentEl.focus({
                    preventScroll: !0
                })
            }

            function u() {
                n("afterLeave")
            }
            return de(l, async c => {
                var d;
                c || (await Re(), (d = o.value.activatorEl) == null || d.focus({
                    preventScroll: !0
                }))
            }), ne(() => {
                const c = ea.filterProps(e),
                    d = te({
                        "aria-haspopup": "dialog",
                        "aria-expanded": String(l.value)
                    }, e.activatorProps),
                    f = te({
                        tabindex: -1
                    }, e.contentProps);
                return m(ea, te({
                    ref: o,
                    class: ["v-dialog", {
                        "v-dialog--fullscreen": e.fullscreen,
                        "v-dialog--scrollable": e.scrollable
                    }, e.class],
                    style: e.style
                }, c, {
                    modelValue: l.value,
                    "onUpdate:modelValue": v => l.value = v,
                    "aria-modal": "true",
                    activatorProps: d,
                    contentProps: f,
                    role: "dialog",
                    onAfterEnter: s,
                    onAfterLeave: u
                }, r), {
                    activator: a.activator,
                    default: function() {
                        for (var v = arguments.length, g = new Array(v), h = 0; h < v; h++) g[h] = arguments[h];
                        return m(Ve, {
                            root: "VDialog"
                        }, {
                            default: () => {
                                var y;
                                return [(y = a.default) == null ? void 0 : y.call(a, ...g)]
                            }
                        })
                    }
                })
            }), wn({}, o)
        }
    }),
    UB = W({
        inset: Boolean,
        ...Uw({
            transition: "bottom-sheet-transition"
        })
    }, "VBottomSheet"),
    WB = Z()({
        name: "VBottomSheet",
        props: UB(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Ce(e, "modelValue");
            return ne(() => {
                const l = Xd.filterProps(e);
                return m(Xd, te(l, {
                    contentClass: ["v-bottom-sheet__content", e.contentClass],
                    modelValue: a.value,
                    "onUpdate:modelValue": r => a.value = r,
                    class: ["v-bottom-sheet", {
                        "v-bottom-sheet--inset": e.inset
                    }, e.class],
                    style: e.style
                }), n)
            }), {}
        }
    }),
    zB = W({
        divider: [Number, String],
        ...Se()
    }, "VBreadcrumbsDivider"),
    Ww = Z()({
        name: "VBreadcrumbsDivider",
        props: zB(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            return ne(() => {
                var a;
                return m("li", {
                    class: ["v-breadcrumbs-divider", e.class],
                    style: e.style
                }, [((a = n == null ? void 0 : n.default) == null ? void 0 : a.call(n)) ? ? e.divider])
            }), {}
        }
    }),
    KB = W({
        active: Boolean,
        activeClass: String,
        activeColor: String,
        color: String,
        disabled: Boolean,
        title: String,
        ...Se(),
        ...hi(),
        ...Ae({
            tag: "li"
        })
    }, "VBreadcrumbsItem"),
    zw = Z()({
        name: "VBreadcrumbsItem",
        props: KB(),
        setup(e, t) {
            let {
                slots: n,
                attrs: a
            } = t;
            const l = Gr(e, a),
                r = C(() => {
                    var u;
                    return e.active || ((u = l.isActive) == null ? void 0 : u.value)
                }),
                o = C(() => r.value ? e.activeColor : e.color),
                {
                    textColorClasses: i,
                    textColorStyles: s
                } = Ot(o);
            return ne(() => m(e.tag, {
                class: ["v-breadcrumbs-item", {
                    "v-breadcrumbs-item--active": r.value,
                    "v-breadcrumbs-item--disabled": e.disabled,
                    [`${e.activeClass}`]: r.value && e.activeClass
                }, i.value, e.class],
                style: [s.value, e.style],
                "aria-current": r.value ? "page" : void 0
            }, {
                default: () => {
                    var u, c;
                    return [l.isLink.value ? m("a", {
                        class: "v-breadcrumbs-item--link",
                        href: l.href.value,
                        "aria-current": r.value ? "page" : void 0,
                        onClick: l.navigate
                    }, [((c = n.default) == null ? void 0 : c.call(n)) ? ? e.title]) : ((u = n.default) == null ? void 0 : u.call(n)) ? ? e.title]
                }
            })), {}
        }
    }),
    GB = W({
        activeClass: String,
        activeColor: String,
        bgColor: String,
        color: String,
        disabled: Boolean,
        divider: {
            type: String,
            default: "/"
        },
        icon: Pe,
        items: {
            type: Array,
            default: () => []
        },
        ...Se(),
        ...Vt(),
        ...rt(),
        ...Ae({
            tag: "ul"
        })
    }, "VBreadcrumbs"),
    YB = Z()({
        name: "VBreadcrumbs",
        props: GB(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                backgroundColorClasses: a,
                backgroundColorStyles: l
            } = Ke(Y(e, "bgColor")), {
                densityClasses: r
            } = zt(e), {
                roundedClasses: o
            } = ct(e);
            lt({
                VBreadcrumbsDivider: {
                    divider: Y(e, "divider")
                },
                VBreadcrumbsItem: {
                    activeClass: Y(e, "activeClass"),
                    activeColor: Y(e, "activeColor"),
                    color: Y(e, "color"),
                    disabled: Y(e, "disabled")
                }
            });
            const i = C(() => e.items.map(s => typeof s == "string" ? {
                item: {
                    title: s
                },
                raw: s
            } : {
                item: s,
                raw: s
            }));
            return ne(() => {
                const s = !!(n.prepend || e.icon);
                return m(e.tag, {
                    class: ["v-breadcrumbs", a.value, r.value, o.value, e.class],
                    style: [l.value, e.style]
                }, {
                    default: () => {
                        var u;
                        return [s && m("li", {
                            key: "prepend",
                            class: "v-breadcrumbs__prepend"
                        }, [n.prepend ? m(Ve, {
                            key: "prepend-defaults",
                            disabled: !e.icon,
                            defaults: {
                                VIcon: {
                                    icon: e.icon,
                                    start: !0
                                }
                            }
                        }, n.prepend) : m(Be, {
                            key: "prepend-icon",
                            start: !0,
                            icon: e.icon
                        }, null)]), i.value.map((c, d, f) => {
                            var h;
                            let {
                                item: v,
                                raw: g
                            } = c;
                            return m(ye, null, [((h = n.item) == null ? void 0 : h.call(n, {
                                item: v,
                                index: d
                            })) ? ? m(zw, te({
                                key: d,
                                disabled: d >= f.length - 1
                            }, typeof v == "string" ? {
                                title: v
                            } : v), {
                                default: n.title ? () => {
                                    var y;
                                    return (y = n.title) == null ? void 0 : y.call(n, {
                                        item: v,
                                        index: d
                                    })
                                } : void 0
                            }), d < f.length - 1 && m(Ww, null, {
                                default: n.divider ? () => {
                                    var y;
                                    return (y = n.divider) == null ? void 0 : y.call(n, {
                                        item: g,
                                        index: d
                                    })
                                } : void 0
                            })])
                        }), (u = n.default) == null ? void 0 : u.call(n)]
                    }
                })
            }), {}
        }
    }),
    Kw = Z()({
        name: "VCardActions",
        props: Se(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            return lt({
                VBtn: {
                    slim: !0,
                    variant: "text"
                }
            }), ne(() => {
                var a;
                return m("div", {
                    class: ["v-card-actions", e.class],
                    style: e.style
                }, [(a = n.default) == null ? void 0 : a.call(n)])
            }), {}
        }
    }),
    qB = W({
        opacity: [Number, String],
        ...Se(),
        ...Ae()
    }, "VCardSubtitle"),
    Gw = Z()({
        name: "VCardSubtitle",
        props: qB(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            return ne(() => m(e.tag, {
                class: ["v-card-subtitle", e.class],
                style: [{
                    "--v-card-subtitle-opacity": e.opacity
                }, e.style]
            }, n)), {}
        }
    }),
    Yw = oa("v-card-title"),
    XB = W({
        appendAvatar: String,
        appendIcon: Pe,
        prependAvatar: String,
        prependIcon: Pe,
        subtitle: [String, Number],
        title: [String, Number],
        ...Se(),
        ...Vt()
    }, "VCardItem"),
    qw = Z()({
        name: "VCardItem",
        props: XB(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            return ne(() => {
                var u;
                const a = !!(e.prependAvatar || e.prependIcon),
                    l = !!(a || n.prepend),
                    r = !!(e.appendAvatar || e.appendIcon),
                    o = !!(r || n.append),
                    i = !!(e.title != null || n.title),
                    s = !!(e.subtitle != null || n.subtitle);
                return m("div", {
                    class: ["v-card-item", e.class],
                    style: e.style
                }, [l && m("div", {
                    key: "prepend",
                    class: "v-card-item__prepend"
                }, [n.prepend ? m(Ve, {
                    key: "prepend-defaults",
                    disabled: !a,
                    defaults: {
                        VAvatar: {
                            density: e.density,
                            image: e.prependAvatar
                        },
                        VIcon: {
                            density: e.density,
                            icon: e.prependIcon
                        }
                    }
                }, n.prepend) : m(ye, null, [e.prependAvatar && m(yn, {
                    key: "prepend-avatar",
                    density: e.density,
                    image: e.prependAvatar
                }, null), e.prependIcon && m(Be, {
                    key: "prepend-icon",
                    density: e.density,
                    icon: e.prependIcon
                }, null)])]), m("div", {
                    class: "v-card-item__content"
                }, [i && m(Yw, {
                    key: "title"
                }, {
                    default: () => {
                        var c;
                        return [((c = n.title) == null ? void 0 : c.call(n)) ? ? e.title]
                    }
                }), s && m(Gw, {
                    key: "subtitle"
                }, {
                    default: () => {
                        var c;
                        return [((c = n.subtitle) == null ? void 0 : c.call(n)) ? ? e.subtitle]
                    }
                }), (u = n.default) == null ? void 0 : u.call(n)]), o && m("div", {
                    key: "append",
                    class: "v-card-item__append"
                }, [n.append ? m(Ve, {
                    key: "append-defaults",
                    disabled: !r,
                    defaults: {
                        VAvatar: {
                            density: e.density,
                            image: e.appendAvatar
                        },
                        VIcon: {
                            density: e.density,
                            icon: e.appendIcon
                        }
                    }
                }, n.append) : m(ye, null, [e.appendIcon && m(Be, {
                    key: "append-icon",
                    density: e.density,
                    icon: e.appendIcon
                }, null), e.appendAvatar && m(yn, {
                    key: "append-avatar",
                    density: e.density,
                    image: e.appendAvatar
                }, null)])])])
            }), {}
        }
    }),
    JB = W({
        opacity: [Number, String],
        ...Se(),
        ...Ae()
    }, "VCardText"),
    Xw = Z()({
        name: "VCardText",
        props: JB(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            return ne(() => m(e.tag, {
                class: ["v-card-text", e.class],
                style: [{
                    "--v-card-text-opacity": e.opacity
                }, e.style]
            }, n)), {}
        }
    }),
    ZB = W({
        appendAvatar: String,
        appendIcon: Pe,
        disabled: Boolean,
        flat: Boolean,
        hover: Boolean,
        image: String,
        link: {
            type: Boolean,
            default: void 0
        },
        prependAvatar: String,
        prependIcon: Pe,
        ripple: {
            type: [Boolean, Object],
            default: !0
        },
        subtitle: [String, Number],
        text: [String, Number],
        title: [String, Number],
        ...an(),
        ...Se(),
        ...Vt(),
        ...bt(),
        ...Pt(),
        ...Ou(),
        ...Ea(),
        ...zr(),
        ...rt(),
        ...hi(),
        ...Ae(),
        ...Ne(),
        ...Rn({
            variant: "elevated"
        })
    }, "VCard"),
    QB = Z()({
        name: "VCard",
        directives: {
            Ripple: Ia
        },
        props: ZB(),
        setup(e, t) {
            let {
                attrs: n,
                slots: a
            } = t;
            const {
                themeClasses: l
            } = je(e), {
                borderClasses: r
            } = Sn(e), {
                colorClasses: o,
                colorStyles: i,
                variantClasses: s
            } = Gl(e), {
                densityClasses: u
            } = zt(e), {
                dimensionStyles: c
            } = pt(e), {
                elevationClasses: d
            } = Dt(e), {
                loaderClasses: f
            } = vi(e), {
                locationStyles: v
            } = Jl(e), {
                positionClasses: g
            } = Kr(e), {
                roundedClasses: h
            } = ct(e), y = Gr(e, n), S = C(() => e.link !== !1 && y.isLink.value), b = C(() => !e.disabled && e.link !== !1 && (e.link || y.isClickable.value));
            return ne(() => {
                const p = S.value ? "a" : e.tag,
                    _ = !!(a.title || e.title != null),
                    w = !!(a.subtitle || e.subtitle != null),
                    k = _ || w,
                    E = !!(a.append || e.appendAvatar || e.appendIcon),
                    P = !!(a.prepend || e.prependAvatar || e.prependIcon),
                    x = !!(a.image || e.image),
                    T = k || P || E,
                    V = !!(a.text || e.text != null);
                return at(m(p, {
                    class: ["v-card", {
                        "v-card--disabled": e.disabled,
                        "v-card--flat": e.flat,
                        "v-card--hover": e.hover && !(e.disabled || e.flat),
                        "v-card--link": b.value
                    }, l.value, r.value, o.value, u.value, d.value, f.value, g.value, h.value, s.value, e.class],
                    style: [i.value, c.value, v.value, e.style],
                    href: y.href.value,
                    onClick: b.value && y.navigate,
                    tabindex: e.disabled ? -1 : void 0
                }, {
                    default: () => {
                        var I;
                        return [x && m("div", {
                            key: "image",
                            class: "v-card__image"
                        }, [a.image ? m(Ve, {
                            key: "image-defaults",
                            disabled: !e.image,
                            defaults: {
                                VImg: {
                                    cover: !0,
                                    src: e.image
                                }
                            }
                        }, a.image) : m(Ca, {
                            key: "image-img",
                            cover: !0,
                            src: e.image
                        }, null)]), m(mi, {
                            name: "v-card",
                            active: !!e.loading,
                            color: typeof e.loading == "boolean" ? void 0 : e.loading
                        }, {
                            default: a.loader
                        }), T && m(qw, {
                            key: "item",
                            prependAvatar: e.prependAvatar,
                            prependIcon: e.prependIcon,
                            title: e.title,
                            subtitle: e.subtitle,
                            appendAvatar: e.appendAvatar,
                            appendIcon: e.appendIcon
                        }, {
                            default: a.item,
                            prepend: a.prepend,
                            title: a.title,
                            subtitle: a.subtitle,
                            append: a.append
                        }), V && m(Xw, {
                            key: "text"
                        }, {
                            default: () => {
                                var R;
                                return [((R = a.text) == null ? void 0 : R.call(a)) ? ? e.text]
                            }
                        }), (I = a.default) == null ? void 0 : I.call(a), a.actions && m(Kw, null, {
                            default: a.actions
                        }), ll(b.value, "v-card")]
                    }
                }), [
                    [tn("ripple"), b.value && e.ripple]
                ])
            }), {}
        }
    }),
    eF = e => {
        const {
            touchstartX: t,
            touchendX: n,
            touchstartY: a,
            touchendY: l
        } = e, r = .5, o = 16;
        e.offsetX = n - t, e.offsetY = l - a, Math.abs(e.offsetY) < r * Math.abs(e.offsetX) && (e.left && n < t - o && e.left(e), e.right && n > t + o && e.right(e)), Math.abs(e.offsetX) < r * Math.abs(e.offsetY) && (e.up && l < a - o && e.up(e), e.down && l > a + o && e.down(e))
    };

function tF(e, t) {
    var a;
    const n = e.changedTouches[0];
    t.touchstartX = n.clientX, t.touchstartY = n.clientY, (a = t.start) == null || a.call(t, {
        originalEvent: e,
        ...t
    })
}

function nF(e, t) {
    var a;
    const n = e.changedTouches[0];
    t.touchendX = n.clientX, t.touchendY = n.clientY, (a = t.end) == null || a.call(t, {
        originalEvent: e,
        ...t
    }), eF(t)
}

function aF(e, t) {
    var a;
    const n = e.changedTouches[0];
    t.touchmoveX = n.clientX, t.touchmoveY = n.clientY, (a = t.move) == null || a.call(t, {
        originalEvent: e,
        ...t
    })
}

function lF() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = {
        touchstartX: 0,
        touchstartY: 0,
        touchendX: 0,
        touchendY: 0,
        touchmoveX: 0,
        touchmoveY: 0,
        offsetX: 0,
        offsetY: 0,
        left: e.left,
        right: e.right,
        up: e.up,
        down: e.down,
        start: e.start,
        move: e.move,
        end: e.end
    };
    return {
        touchstart: n => tF(n, t),
        touchend: n => nF(n, t),
        touchmove: n => aF(n, t)
    }
}

function rF(e, t) {
    var i;
    const n = t.value,
        a = n != null && n.parent ? e.parentElement : e,
        l = (n == null ? void 0 : n.options) ? ? {
            passive: !0
        },
        r = (i = t.instance) == null ? void 0 : i.$.uid;
    if (!a || !r) return;
    const o = lF(t.value);
    a._touchHandlers = a._touchHandlers ? ? Object.create(null), a._touchHandlers[r] = o, X0(o).forEach(s => {
        a.addEventListener(s, o[s], l)
    })
}

function oF(e, t) {
    var r, o;
    const n = (r = t.value) != null && r.parent ? e.parentElement : e,
        a = (o = t.instance) == null ? void 0 : o.$.uid;
    if (!(n != null && n._touchHandlers) || !a) return;
    const l = n._touchHandlers[a];
    X0(l).forEach(i => {
        n.removeEventListener(i, l[i])
    }), delete n._touchHandlers[a]
}
const sm = {
        mounted: rF,
        unmounted: oF
    },
    Jw = Symbol.for("vuetify:v-window"),
    Zw = Symbol.for("vuetify:v-window-group"),
    $u = W({
        continuous: Boolean,
        nextIcon: {
            type: [Boolean, String, Function, Object],
            default: "$next"
        },
        prevIcon: {
            type: [Boolean, String, Function, Object],
            default: "$prev"
        },
        reverse: Boolean,
        showArrows: {
            type: [Boolean, String],
            validator: e => typeof e == "boolean" || e === "hover"
        },
        touch: {
            type: [Object, Boolean],
            default: void 0
        },
        direction: {
            type: String,
            default: "horizontal"
        },
        modelValue: null,
        disabled: Boolean,
        selectedClass: {
            type: String,
            default: "v-window-item--active"
        },
        mandatory: {
            type: [Boolean, String],
            default: "force"
        },
        ...Se(),
        ...Ae(),
        ...Ne()
    }, "VWindow"),
    Rl = Z()({
        name: "VWindow",
        directives: {
            Touch: sm
        },
        props: $u(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                themeClasses: a
            } = je(e), {
                isRtl: l
            } = xt(), {
                t: r
            } = Qe(), o = rl(e, Zw), i = Q(), s = C(() => l.value ? !e.reverse : e.reverse), u = fe(!1), c = C(() => {
                const _ = e.direction === "vertical" ? "y" : "x",
                    k = (s.value ? !u.value : u.value) ? "-reverse" : "";
                return `v-window-${_}${k}-transition`
            }), d = fe(0), f = Q(void 0), v = C(() => o.items.value.findIndex(_ => o.selected.value.includes(_.id)));
            de(v, (_, w) => {
                const k = o.items.value.length,
                    E = k - 1;
                k <= 2 ? u.value = _ < w : _ === E && w === 0 ? u.value = !0 : _ === 0 && w === E ? u.value = !1 : u.value = _ < w
            }), He(Jw, {
                transition: c,
                isReversed: u,
                transitionCount: d,
                transitionHeight: f,
                rootRef: i
            });
            const g = C(() => e.continuous || v.value !== 0),
                h = C(() => e.continuous || v.value !== o.items.value.length - 1);

            function y() {
                g.value && o.prev()
            }

            function S() {
                h.value && o.next()
            }
            const b = C(() => {
                    const _ = [],
                        w = {
                            icon: l.value ? e.nextIcon : e.prevIcon,
                            class: `v-window__${s.value?"right":"left"}`,
                            onClick: o.prev,
                            "aria-label": r("$vuetify.carousel.prev")
                        };
                    _.push(g.value ? n.prev ? n.prev({
                        props: w
                    }) : m(Le, w, null) : m("div", null, null));
                    const k = {
                        icon: l.value ? e.prevIcon : e.nextIcon,
                        class: `v-window__${s.value?"left":"right"}`,
                        onClick: o.next,
                        "aria-label": r("$vuetify.carousel.next")
                    };
                    return _.push(h.value ? n.next ? n.next({
                        props: k
                    }) : m(Le, k, null) : m("div", null, null)), _
                }),
                p = C(() => e.touch === !1 ? e.touch : { ...{
                        left: () => {
                            s.value ? y() : S()
                        },
                        right: () => {
                            s.value ? S() : y()
                        },
                        start: w => {
                            let {
                                originalEvent: k
                            } = w;
                            k.stopPropagation()
                        }
                    },
                    ...e.touch === !0 ? {} : e.touch
                });
            return ne(() => at(m(e.tag, {
                ref: i,
                class: ["v-window", {
                    "v-window--show-arrows-on-hover": e.showArrows === "hover"
                }, a.value, e.class],
                style: e.style
            }, {
                default: () => {
                    var _, w;
                    return [m("div", {
                        class: "v-window__container",
                        style: {
                            height: f.value
                        }
                    }, [(_ = n.default) == null ? void 0 : _.call(n, {
                        group: o
                    }), e.showArrows !== !1 && m("div", {
                        class: "v-window__controls"
                    }, [b.value])]), (w = n.additional) == null ? void 0 : w.call(n, {
                        group: o
                    })]
                }
            }), [
                [tn("touch"), p.value]
            ])), {
                group: o
            }
        }
    }),
    iF = W({
        color: String,
        cycle: Boolean,
        delimiterIcon: {
            type: Pe,
            default: "$delimiter"
        },
        height: {
            type: [Number, String],
            default: 500
        },
        hideDelimiters: Boolean,
        hideDelimiterBackground: Boolean,
        interval: {
            type: [Number, String],
            default: 6e3,
            validator: e => Number(e) > 0
        },
        progress: [Boolean, String],
        verticalDelimiters: [Boolean, String],
        ...$u({
            continuous: !0,
            mandatory: "force",
            showArrows: !0
        })
    }, "VCarousel"),
    sF = Z()({
        name: "VCarousel",
        props: iF(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Ce(e, "modelValue"),
                {
                    t: l
                } = Qe(),
                r = Q();
            let o = -1;
            de(a, s), de(() => e.interval, s), de(() => e.cycle, u => {
                u ? s() : window.clearTimeout(o)
            }), it(i);

            function i() {
                !e.cycle || !r.value || (o = window.setTimeout(r.value.group.next, +e.interval > 0 ? +e.interval : 6e3))
            }

            function s() {
                window.clearTimeout(o), window.requestAnimationFrame(i)
            }
            return ne(() => {
                const u = Rl.filterProps(e);
                return m(Rl, te({
                    ref: r
                }, u, {
                    modelValue: a.value,
                    "onUpdate:modelValue": c => a.value = c,
                    class: ["v-carousel", {
                        "v-carousel--hide-delimiter-background": e.hideDelimiterBackground,
                        "v-carousel--vertical-delimiters": e.verticalDelimiters
                    }, e.class],
                    style: [{
                        height: ge(e.height)
                    }, e.style]
                }), {
                    default: n.default,
                    additional: c => {
                        let {
                            group: d
                        } = c;
                        return m(ye, null, [!e.hideDelimiters && m("div", {
                            class: "v-carousel__controls",
                            style: {
                                left: e.verticalDelimiters === "left" && e.verticalDelimiters ? 0 : "auto",
                                right: e.verticalDelimiters === "right" ? 0 : "auto"
                            }
                        }, [d.items.value.length > 0 && m(Ve, {
                            defaults: {
                                VBtn: {
                                    color: e.color,
                                    icon: e.delimiterIcon,
                                    size: "x-small",
                                    variant: "text"
                                }
                            },
                            scoped: !0
                        }, {
                            default: () => [d.items.value.map((f, v) => {
                                const g = {
                                    id: `carousel-item-${f.id}`,
                                    "aria-label": l("$vuetify.carousel.ariaLabel.delimiter", v + 1, d.items.value.length),
                                    class: ["v-carousel__controls__item", d.isSelected(f.id) && "v-btn--active"],
                                    onClick: () => d.select(f.id, !0)
                                };
                                return n.item ? n.item({
                                    props: g,
                                    item: f
                                }) : m(Le, te(f, g), null)
                            })]
                        })]), e.progress && m(Lu, {
                            class: "v-carousel__progress",
                            color: typeof e.progress == "string" ? e.progress : void 0,
                            modelValue: (d.getItemIndex(a.value) + 1) / d.items.value.length * 100
                        }, null)])
                    },
                    prev: n.prev,
                    next: n.next
                })
            }), {}
        }
    }),
    Bu = W({
        reverseTransition: {
            type: [Boolean, String],
            default: void 0
        },
        transition: {
            type: [Boolean, String],
            default: void 0
        },
        ...Se(),
        ...ql(),
        ...nm()
    }, "VWindowItem"),
    Dl = Z()({
        name: "VWindowItem",
        directives: {
            Touch: sm
        },
        props: Bu(),
        emits: {
            "group:selected": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Te(Jw),
                l = Xl(e, Zw),
                {
                    isBooted: r
                } = Kl();
            if (!a || !l) throw new Error("[Vuetify] VWindowItem must be used inside VWindow");
            const o = fe(!1),
                i = C(() => r.value && (a.isReversed.value ? e.reverseTransition !== !1 : e.transition !== !1));

            function s() {
                !o.value || !a || (o.value = !1, a.transitionCount.value > 0 && (a.transitionCount.value -= 1, a.transitionCount.value === 0 && (a.transitionHeight.value = void 0)))
            }

            function u() {
                var g;
                o.value || !a || (o.value = !0, a.transitionCount.value === 0 && (a.transitionHeight.value = ge((g = a.rootRef.value) == null ? void 0 : g.clientHeight)), a.transitionCount.value += 1)
            }

            function c() {
                s()
            }

            function d(g) {
                o.value && Re(() => {
                    !i.value || !o.value || !a || (a.transitionHeight.value = ge(g.clientHeight))
                })
            }
            const f = C(() => {
                    const g = a.isReversed.value ? e.reverseTransition : e.transition;
                    return i.value ? {
                        name: typeof g != "string" ? a.transition.value : g,
                        onBeforeEnter: u,
                        onAfterEnter: s,
                        onEnterCancelled: c,
                        onBeforeLeave: u,
                        onAfterLeave: s,
                        onLeaveCancelled: c,
                        onEnter: d
                    } : !1
                }),
                {
                    hasContent: v
                } = am(e, l.isSelected);
            return ne(() => m(jt, {
                transition: f.value,
                disabled: !r.value
            }, {
                default: () => {
                    var g;
                    return [at(m("div", {
                        class: ["v-window-item", l.selectedClass.value, e.class],
                        style: e.style
                    }, [v.value && ((g = n.default) == null ? void 0 : g.call(n))]), [
                        [bn, l.isSelected.value]
                    ])]
                }
            })), {
                groupItem: l
            }
        }
    }),
    uF = W({ ...BS(),
        ...Bu()
    }, "VCarouselItem"),
    cF = Z()({
        name: "VCarouselItem",
        inheritAttrs: !1,
        props: uF(),
        setup(e, t) {
            let {
                slots: n,
                attrs: a
            } = t;
            ne(() => {
                const l = Ca.filterProps(e),
                    r = Dl.filterProps(e);
                return m(Dl, te({
                    class: ["v-carousel-item", e.class]
                }, r), {
                    default: () => [m(Ca, te(a, l), n)]
                })
            })
        }
    }),
    dF = oa("v-code"),
    fF = W({
        color: {
            type: Object
        },
        disabled: Boolean,
        dotSize: {
            type: [Number, String],
            default: 10
        },
        height: {
            type: [Number, String],
            default: 150
        },
        width: {
            type: [Number, String],
            default: 300
        },
        ...Se()
    }, "VColorPickerCanvas"),
    vF = pn({
        name: "VColorPickerCanvas",
        props: fF(),
        emits: {
            "update:color": e => !0,
            "update:position": e => !0
        },
        setup(e, t) {
            let {
                emit: n
            } = t;
            const a = fe(!1),
                l = Q(),
                r = fe(parseFloat(e.width)),
                o = fe(parseFloat(e.height)),
                i = Q({
                    x: 0,
                    y: 0
                }),
                s = C({
                    get: () => i.value,
                    set(y) {
                        var p, _;
                        if (!l.value) return;
                        const {
                            x: S,
                            y: b
                        } = y;
                        i.value = y, n("update:color", {
                            h: ((p = e.color) == null ? void 0 : p.h) ? ? 0,
                            s: ot(S, 0, r.value) / r.value,
                            v: 1 - ot(b, 0, o.value) / o.value,
                            a: ((_ = e.color) == null ? void 0 : _.a) ? ? 1
                        })
                    }
                }),
                u = C(() => {
                    const {
                        x: y,
                        y: S
                    } = s.value, b = parseInt(e.dotSize, 10) / 2;
                    return {
                        width: ge(e.dotSize),
                        height: ge(e.dotSize),
                        transform: `translate(${ge(y-b)}, ${ge(S-b)})`
                    }
                }),
                {
                    resizeRef: c
                } = Hn(y => {
                    var p;
                    if (!((p = c.el) != null && p.offsetParent)) return;
                    const {
                        width: S,
                        height: b
                    } = y[0].contentRect;
                    r.value = S, o.value = b
                });

            function d(y, S, b) {
                const {
                    left: p,
                    top: _,
                    width: w,
                    height: k
                } = b;
                s.value = {
                    x: ot(y - p, 0, w),
                    y: ot(S - _, 0, k)
                }
            }

            function f(y) {
                y.type === "mousedown" && y.preventDefault(), !e.disabled && (v(y), window.addEventListener("mousemove", v), window.addEventListener("mouseup", g), window.addEventListener("touchmove", v), window.addEventListener("touchend", g))
            }

            function v(y) {
                if (e.disabled || !l.value) return;
                a.value = !0;
                const S = ND(y);
                d(S.clientX, S.clientY, l.value.getBoundingClientRect())
            }

            function g() {
                window.removeEventListener("mousemove", v), window.removeEventListener("mouseup", g), window.removeEventListener("touchmove", v), window.removeEventListener("touchend", g)
            }

            function h() {
                var _;
                if (!l.value) return;
                const y = l.value,
                    S = y.getContext("2d");
                if (!S) return;
                const b = S.createLinearGradient(0, 0, y.width, 0);
                b.addColorStop(0, "hsla(0, 0%, 100%, 1)"), b.addColorStop(1, `hsla(${((_=e.color)==null?void 0:_.h)??0}, 100%, 50%, 1)`), S.fillStyle = b, S.fillRect(0, 0, y.width, y.height);
                const p = S.createLinearGradient(0, 0, 0, y.height);
                p.addColorStop(0, "hsla(0, 0%, 0%, 0)"), p.addColorStop(1, "hsla(0, 0%, 0%, 1)"), S.fillStyle = p, S.fillRect(0, 0, y.width, y.height)
            }
            return de(() => {
                var y;
                return (y = e.color) == null ? void 0 : y.h
            }, h, {
                immediate: !0
            }), de(() => [r.value, o.value], (y, S) => {
                h(), i.value = {
                    x: s.value.x * y[0] / S[0],
                    y: s.value.y * y[1] / S[1]
                }
            }, {
                flush: "post"
            }), de(() => e.color, () => {
                if (a.value) {
                    a.value = !1;
                    return
                }
                i.value = e.color ? {
                    x: e.color.s * r.value,
                    y: (1 - e.color.v) * o.value
                } : {
                    x: 0,
                    y: 0
                }
            }, {
                deep: !0,
                immediate: !0
            }), it(() => h()), ne(() => m("div", {
                ref: c,
                class: ["v-color-picker-canvas", e.class],
                style: e.style,
                onMousedown: f,
                onTouchstartPassive: f
            }, [m("canvas", {
                ref: l,
                width: r.value,
                height: o.value
            }, null), e.color && m("div", {
                class: ["v-color-picker-canvas__dot", {
                    "v-color-picker-canvas__dot--disabled": e.disabled
                }],
                style: u.value
            }, null)])), {}
        }
    });

function mF(e, t) {
    if (t) {
        const {
            a: n,
            ...a
        } = e;
        return a
    }
    return e
}

function hF(e, t) {
    if (t == null || typeof t == "string") {
        const n = vS(e);
        return e.a === 1 ? n.slice(0, 7) : n
    }
    if (typeof t == "object") {
        let n;
        return gl(t, ["r", "g", "b"]) ? n = ka(e) : gl(t, ["h", "s", "l"]) ? n = iS(e) : gl(t, ["h", "s", "v"]) && (n = e), mF(n, !gl(t, ["a"]) && e.a === 1)
    }
    return e
}
const vr = {
        h: 0,
        s: 0,
        v: 0,
        a: 1
    },
    Jd = {
        inputProps: {
            type: "number",
            min: 0
        },
        inputs: [{
            label: "R",
            max: 255,
            step: 1,
            getValue: e => Math.round(e.r),
            getColor: (e, t) => ({ ...e,
                r: Number(t)
            })
        }, {
            label: "G",
            max: 255,
            step: 1,
            getValue: e => Math.round(e.g),
            getColor: (e, t) => ({ ...e,
                g: Number(t)
            })
        }, {
            label: "B",
            max: 255,
            step: 1,
            getValue: e => Math.round(e.b),
            getColor: (e, t) => ({ ...e,
                b: Number(t)
            })
        }, {
            label: "A",
            max: 1,
            step: .01,
            getValue: e => {
                let {
                    a: t
                } = e;
                return t != null ? Math.round(t * 100) / 100 : 1
            },
            getColor: (e, t) => ({ ...e,
                a: Number(t)
            })
        }],
        to: ka,
        from: xu
    };
var ib;
const gF = { ...Jd,
        inputs: (ib = Jd.inputs) == null ? void 0 : ib.slice(0, 3)
    },
    Zd = {
        inputProps: {
            type: "number",
            min: 0
        },
        inputs: [{
            label: "H",
            max: 360,
            step: 1,
            getValue: e => Math.round(e.h),
            getColor: (e, t) => ({ ...e,
                h: Number(t)
            })
        }, {
            label: "S",
            max: 1,
            step: .01,
            getValue: e => Math.round(e.s * 100) / 100,
            getColor: (e, t) => ({ ...e,
                s: Number(t)
            })
        }, {
            label: "L",
            max: 1,
            step: .01,
            getValue: e => Math.round(e.l * 100) / 100,
            getColor: (e, t) => ({ ...e,
                l: Number(t)
            })
        }, {
            label: "A",
            max: 1,
            step: .01,
            getValue: e => {
                let {
                    a: t
                } = e;
                return t != null ? Math.round(t * 100) / 100 : 1
            },
            getColor: (e, t) => ({ ...e,
                a: Number(t)
            })
        }],
        to: iS,
        from: Dv
    },
    yF = { ...Zd,
        inputs: Zd.inputs.slice(0, 3)
    },
    Qw = {
        inputProps: {
            type: "text"
        },
        inputs: [{
            label: "HEXA",
            getValue: e => e,
            getColor: (e, t) => t
        }],
        to: vS,
        from: fS
    },
    bF = { ...Qw,
        inputs: [{
            label: "HEX",
            getValue: e => e.slice(0, 7),
            getColor: (e, t) => t
        }]
    },
    El = {
        rgb: gF,
        rgba: Jd,
        hsl: yF,
        hsla: Zd,
        hex: bF,
        hexa: Qw
    },
    pF = e => {
        let {
            label: t,
            ...n
        } = e;
        return m("div", {
            class: "v-color-picker-edit__input"
        }, [m("input", n, null), m("span", null, [t])])
    },
    _F = W({
        color: Object,
        disabled: Boolean,
        mode: {
            type: String,
            default: "rgba",
            validator: e => Object.keys(El).includes(e)
        },
        modes: {
            type: Array,
            default: () => Object.keys(El),
            validator: e => Array.isArray(e) && e.every(t => Object.keys(El).includes(t))
        },
        ...Se()
    }, "VColorPickerEdit"),
    SF = pn({
        name: "VColorPickerEdit",
        props: _F(),
        emits: {
            "update:color": e => !0,
            "update:mode": e => !0
        },
        setup(e, t) {
            let {
                emit: n
            } = t;
            const a = C(() => e.modes.map(r => ({ ...El[r],
                    name: r
                }))),
                l = C(() => {
                    var i;
                    const r = a.value.find(s => s.name === e.mode);
                    if (!r) return [];
                    const o = e.color ? r.to(e.color) : null;
                    return (i = r.inputs) == null ? void 0 : i.map(s => {
                        let {
                            getValue: u,
                            getColor: c,
                            ...d
                        } = s;
                        return { ...r.inputProps,
                            ...d,
                            disabled: e.disabled,
                            value: o && u(o),
                            onChange: f => {
                                const v = f.target;
                                v && n("update:color", r.from(c(o ? ? r.to(vr), v.value)))
                            }
                        }
                    })
                });
            return ne(() => {
                var r;
                return m("div", {
                    class: ["v-color-picker-edit", e.class],
                    style: e.style
                }, [(r = l.value) == null ? void 0 : r.map(o => m(pF, o, null)), a.value.length > 1 && m(Le, {
                    icon: "$unfold",
                    size: "x-small",
                    variant: "plain",
                    onClick: () => {
                        const o = a.value.findIndex(i => i.name === e.mode);
                        n("update:mode", a.value[(o + 1) % a.value.length].name)
                    }
                }, null)])
            }), {}
        }
    }),
    um = Symbol.for("vuetify:v-slider");

function Qd(e, t, n) {
    const a = n === "vertical",
        l = t.getBoundingClientRect(),
        r = "touches" in e ? e.touches[0] : e;
    return a ? r.clientY - (l.top + l.height / 2) : r.clientX - (l.left + l.width / 2)
}

function wF(e, t) {
    return "touches" in e && e.touches.length ? e.touches[0][t] : "changedTouches" in e && e.changedTouches.length ? e.changedTouches[0][t] : e[t]
}
const ek = W({
        disabled: {
            type: Boolean,
            default: null
        },
        error: Boolean,
        readonly: {
            type: Boolean,
            default: null
        },
        max: {
            type: [Number, String],
            default: 100
        },
        min: {
            type: [Number, String],
            default: 0
        },
        step: {
            type: [Number, String],
            default: 0
        },
        thumbColor: String,
        thumbLabel: {
            type: [Boolean, String],
            default: void 0,
            validator: e => typeof e == "boolean" || e === "always"
        },
        thumbSize: {
            type: [Number, String],
            default: 20
        },
        showTicks: {
            type: [Boolean, String],
            default: !1,
            validator: e => typeof e == "boolean" || e === "always"
        },
        ticks: {
            type: [Array, Object]
        },
        tickSize: {
            type: [Number, String],
            default: 2
        },
        color: String,
        trackColor: String,
        trackFillColor: String,
        trackSize: {
            type: [Number, String],
            default: 4
        },
        direction: {
            type: String,
            default: "horizontal",
            validator: e => ["vertical", "horizontal"].includes(e)
        },
        reverse: Boolean,
        ...rt(),
        ...Pt({
            elevation: 2
        }),
        ripple: {
            type: Boolean,
            default: !0
        }
    }, "Slider"),
    tk = e => {
        const t = C(() => parseFloat(e.min)),
            n = C(() => parseFloat(e.max)),
            a = C(() => +e.step > 0 ? parseFloat(e.step) : 0),
            l = C(() => Math.max(Ts(a.value), Ts(t.value)));

        function r(o) {
            if (o = parseFloat(o), a.value <= 0) return o;
            const i = ot(o, t.value, n.value),
                s = t.value % a.value,
                u = Math.round((i - s) / a.value) * a.value + s;
            return parseFloat(Math.min(u, n.value).toFixed(l.value))
        }
        return {
            min: t,
            max: n,
            step: a,
            decimals: l,
            roundValue: r
        }
    },
    nk = e => {
        let {
            props: t,
            steps: n,
            onSliderStart: a,
            onSliderMove: l,
            onSliderEnd: r,
            getActiveThumb: o
        } = e;
        const {
            isRtl: i
        } = xt(), s = Y(t, "reverse"), u = C(() => t.direction === "vertical"), c = C(() => u.value !== s.value), {
            min: d,
            max: f,
            step: v,
            decimals: g,
            roundValue: h
        } = n, y = C(() => parseInt(t.thumbSize, 10)), S = C(() => parseInt(t.tickSize, 10)), b = C(() => parseInt(t.trackSize, 10)), p = C(() => (f.value - d.value) / v.value), _ = Y(t, "disabled"), w = C(() => t.error || t.disabled ? void 0 : t.thumbColor ? ? t.color), k = C(() => t.error || t.disabled ? void 0 : t.trackColor ? ? t.color), E = C(() => t.error || t.disabled ? void 0 : t.trackFillColor ? ? t.color), P = fe(!1), x = fe(0), T = Q(), V = Q();

        function I(ee) {
            var K;
            const G = t.direction === "vertical",
                le = G ? "top" : "left",
                se = G ? "height" : "width",
                ce = G ? "clientY" : "clientX",
                {
                    [le]: re,
                    [se]: pe
                } = (K = T.value) == null ? void 0 : K.$el.getBoundingClientRect(),
                A = wF(ee, ce);
            let O = Math.min(Math.max((A - re - x.value) / pe, 0), 1) || 0;
            return (G ? c.value : c.value !== i.value) && (O = 1 - O), h(d.value + O * (f.value - d.value))
        }
        const R = ee => {
                r({
                    value: I(ee)
                }), P.value = !1, x.value = 0
            },
            B = ee => {
                V.value = o(ee), V.value && (V.value.focus(), P.value = !0, V.value.contains(ee.target) ? x.value = Qd(ee, V.value, t.direction) : (x.value = 0, l({
                    value: I(ee)
                })), a({
                    value: I(ee)
                }))
            },
            $ = {
                passive: !0,
                capture: !0
            };

        function D(ee) {
            l({
                value: I(ee)
            })
        }

        function z(ee) {
            ee.stopPropagation(), ee.preventDefault(), R(ee), window.removeEventListener("mousemove", D, $), window.removeEventListener("mouseup", z)
        }

        function N(ee) {
            var G;
            R(ee), window.removeEventListener("touchmove", D, $), (G = ee.target) == null || G.removeEventListener("touchend", N)
        }

        function H(ee) {
            var G;
            B(ee), window.addEventListener("touchmove", D, $), (G = ee.target) == null || G.addEventListener("touchend", N, {
                passive: !1
            })
        }

        function F(ee) {
            ee.preventDefault(), B(ee), window.addEventListener("mousemove", D, $), window.addEventListener("mouseup", z, {
                passive: !1
            })
        }
        const j = ee => {
                const G = (ee - d.value) / (f.value - d.value) * 100;
                return ot(isNaN(G) ? 0 : G, 0, 100)
            },
            ae = Y(t, "showTicks"),
            he = C(() => ae.value ? t.ticks ? Array.isArray(t.ticks) ? t.ticks.map(ee => ({
                value: ee,
                position: j(ee),
                label: ee.toString()
            })) : Object.keys(t.ticks).map(ee => ({
                value: parseFloat(ee),
                position: j(parseFloat(ee)),
                label: t.ticks[ee]
            })) : p.value !== 1 / 0 ? fn(p.value + 1).map(ee => {
                const G = d.value + ee * v.value;
                return {
                    value: G,
                    position: j(G)
                }
            }) : [] : []),
            ve = C(() => he.value.some(ee => {
                let {
                    label: G
                } = ee;
                return !!G
            })),
            we = {
                activeThumbRef: V,
                color: Y(t, "color"),
                decimals: g,
                disabled: _,
                direction: Y(t, "direction"),
                elevation: Y(t, "elevation"),
                hasLabels: ve,
                isReversed: s,
                indexFromEnd: c,
                min: d,
                max: f,
                mousePressed: P,
                numTicks: p,
                onSliderMousedown: F,
                onSliderTouchstart: H,
                parsedTicks: he,
                parseMouseMove: I,
                position: j,
                readonly: Y(t, "readonly"),
                rounded: Y(t, "rounded"),
                roundValue: h,
                showTicks: ae,
                startOffset: x,
                step: v,
                thumbSize: y,
                thumbColor: w,
                thumbLabel: Y(t, "thumbLabel"),
                ticks: Y(t, "ticks"),
                tickSize: S,
                trackColor: k,
                trackContainerRef: T,
                trackFillColor: E,
                trackSize: b,
                vertical: u
            };
        return He(um, we), we
    },
    kF = W({
        focused: Boolean,
        max: {
            type: Number,
            required: !0
        },
        min: {
            type: Number,
            required: !0
        },
        modelValue: {
            type: Number,
            required: !0
        },
        position: {
            type: Number,
            required: !0
        },
        ripple: {
            type: [Boolean, Object],
            default: !0
        },
        name: String,
        ...Se()
    }, "VSliderThumb"),
    ef = Z()({
        name: "VSliderThumb",
        directives: {
            Ripple: Ia
        },
        props: kF(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                slots: n,
                emit: a
            } = t;
            const l = Te(um),
                {
                    isRtl: r,
                    rtlClasses: o
                } = xt();
            if (!l) throw new Error("[Vuetify] v-slider-thumb must be used inside v-slider or v-range-slider");
            const {
                thumbColor: i,
                step: s,
                disabled: u,
                thumbSize: c,
                thumbLabel: d,
                direction: f,
                isReversed: v,
                vertical: g,
                readonly: h,
                elevation: y,
                mousePressed: S,
                decimals: b,
                indexFromEnd: p
            } = l, _ = C(() => u.value ? void 0 : y.value), {
                elevationClasses: w
            } = Dt(_), {
                textColorClasses: k,
                textColorStyles: E
            } = Ot(i), {
                pageup: P,
                pagedown: x,
                end: T,
                home: V,
                left: I,
                right: R,
                down: B,
                up: $
            } = Ad, D = [P, x, T, V, I, R, B, $], z = C(() => s.value ? [1, 2, 3] : [1, 5, 10]);

            function N(F, j) {
                if (!D.includes(F.key)) return;
                F.preventDefault();
                const ae = s.value || .1,
                    he = (e.max - e.min) / ae;
                if ([I, R, B, $].includes(F.key)) {
                    const we = (g.value ? [r.value ? I : R, v.value ? B : $] : p.value !== r.value ? [I, $] : [R, $]).includes(F.key) ? 1 : -1,
                        ee = F.shiftKey ? 2 : F.ctrlKey ? 1 : 0;
                    j = j + we * ae * z.value[ee]
                } else if (F.key === V) j = e.min;
                else if (F.key === T) j = e.max;
                else {
                    const ve = F.key === x ? 1 : -1;
                    j = j - ve * ae * (he > 100 ? he / 10 : 10)
                }
                return Math.max(e.min, Math.min(e.max, j))
            }

            function H(F) {
                const j = N(F, e.modelValue);
                j != null && a("update:modelValue", j)
            }
            return ne(() => {
                const F = ge(p.value ? 100 - e.position : e.position, "%");
                return m("div", {
                    class: ["v-slider-thumb", {
                        "v-slider-thumb--focused": e.focused,
                        "v-slider-thumb--pressed": e.focused && S.value
                    }, e.class, o.value],
                    style: [{
                        "--v-slider-thumb-position": F,
                        "--v-slider-thumb-size": ge(c.value)
                    }, e.style],
                    role: "slider",
                    tabindex: u.value ? -1 : 0,
                    "aria-label": e.name,
                    "aria-valuemin": e.min,
                    "aria-valuemax": e.max,
                    "aria-valuenow": e.modelValue,
                    "aria-readonly": !!h.value,
                    "aria-orientation": f.value,
                    onKeydown: h.value ? void 0 : H
                }, [m("div", {
                    class: ["v-slider-thumb__surface", k.value, w.value],
                    style: { ...E.value
                    }
                }, null), at(m("div", {
                    class: ["v-slider-thumb__ripple", k.value],
                    style: E.value
                }, null), [
                    [tn("ripple"), e.ripple, null, {
                        circle: !0,
                        center: !0
                    }]
                ]), m(Uv, {
                    origin: "bottom center"
                }, {
                    default: () => {
                        var j;
                        return [at(m("div", {
                            class: "v-slider-thumb__label-container"
                        }, [m("div", {
                            class: ["v-slider-thumb__label"]
                        }, [m("div", null, [((j = n["thumb-label"]) == null ? void 0 : j.call(n, {
                            modelValue: e.modelValue
                        })) ? ? e.modelValue.toFixed(s.value ? b.value : 1)])])]), [
                            [bn, d.value && e.focused || d.value === "always"]
                        ])]
                    }
                })])
            }), {}
        }
    }),
    CF = W({
        start: {
            type: Number,
            required: !0
        },
        stop: {
            type: Number,
            required: !0
        },
        ...Se()
    }, "VSliderTrack"),
    ak = Z()({
        name: "VSliderTrack",
        props: CF(),
        emits: {},
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Te(um);
            if (!a) throw new Error("[Vuetify] v-slider-track must be inside v-slider or v-range-slider");
            const {
                color: l,
                parsedTicks: r,
                rounded: o,
                showTicks: i,
                tickSize: s,
                trackColor: u,
                trackFillColor: c,
                trackSize: d,
                vertical: f,
                min: v,
                max: g,
                indexFromEnd: h
            } = a, {
                roundedClasses: y
            } = ct(o), {
                backgroundColorClasses: S,
                backgroundColorStyles: b
            } = Ke(c), {
                backgroundColorClasses: p,
                backgroundColorStyles: _
            } = Ke(u), w = C(() => `inset-${f.value?"block":"inline"}-${h.value?"end":"start"}`), k = C(() => f.value ? "height" : "width"), E = C(() => ({
                [w.value]: "0%",
                [k.value]: "100%"
            })), P = C(() => e.stop - e.start), x = C(() => ({
                [w.value]: ge(e.start, "%"),
                [k.value]: ge(P.value, "%")
            })), T = C(() => i.value ? (f.value ? r.value.slice().reverse() : r.value).map((I, R) => {
                var $;
                const B = I.value !== v.value && I.value !== g.value ? ge(I.position, "%") : void 0;
                return m("div", {
                    key: I.value,
                    class: ["v-slider-track__tick", {
                        "v-slider-track__tick--filled": I.position >= e.start && I.position <= e.stop,
                        "v-slider-track__tick--first": I.value === v.value,
                        "v-slider-track__tick--last": I.value === g.value
                    }],
                    style: {
                        [w.value]: B
                    }
                }, [(I.label || n["tick-label"]) && m("div", {
                    class: "v-slider-track__tick-label"
                }, [(($ = n["tick-label"]) == null ? void 0 : $.call(n, {
                    tick: I,
                    index: R
                })) ? ? I.label])])
            }) : []);
            return ne(() => m("div", {
                class: ["v-slider-track", y.value, e.class],
                style: [{
                    "--v-slider-track-size": ge(d.value),
                    "--v-slider-tick-size": ge(s.value)
                }, e.style]
            }, [m("div", {
                class: ["v-slider-track__background", p.value, {
                    "v-slider-track__background--opacity": !!l.value || !c.value
                }],
                style: { ...E.value,
                    ..._.value
                }
            }, null), m("div", {
                class: ["v-slider-track__fill", S.value],
                style: { ...x.value,
                    ...b.value
                }
            }, null), i.value && m("div", {
                class: ["v-slider-track__ticks", {
                    "v-slider-track__ticks--always-show": i.value === "always"
                }]
            }, [T.value])])), {}
        }
    }),
    xF = W({ ...qr(),
        ...ek(),
        ...Ta(),
        modelValue: {
            type: [Number, String],
            default: 0
        }
    }, "VSlider"),
    tf = Z()({
        name: "VSlider",
        props: xF(),
        emits: {
            "update:focused": e => !0,
            "update:modelValue": e => !0,
            start: e => !0,
            end: e => !0
        },
        setup(e, t) {
            let {
                slots: n,
                emit: a
            } = t;
            const l = Q(),
                {
                    rtlClasses: r
                } = xt(),
                o = tk(e),
                i = Ce(e, "modelValue", void 0, k => o.roundValue(k ? ? o.min.value)),
                {
                    min: s,
                    max: u,
                    mousePressed: c,
                    roundValue: d,
                    onSliderMousedown: f,
                    onSliderTouchstart: v,
                    trackContainerRef: g,
                    position: h,
                    hasLabels: y,
                    readonly: S
                } = nk({
                    props: e,
                    steps: o,
                    onSliderStart: () => {
                        a("start", i.value)
                    },
                    onSliderEnd: k => {
                        let {
                            value: E
                        } = k;
                        const P = d(E);
                        i.value = P, a("end", P)
                    },
                    onSliderMove: k => {
                        let {
                            value: E
                        } = k;
                        return i.value = d(E)
                    },
                    getActiveThumb: () => {
                        var k;
                        return (k = l.value) == null ? void 0 : k.$el
                    }
                }),
                {
                    isFocused: b,
                    focus: p,
                    blur: _
                } = ua(e),
                w = C(() => h(i.value));
            return ne(() => {
                const k = $t.filterProps(e),
                    E = !!(e.label || n.label || n.prepend);
                return m($t, te({
                    class: ["v-slider", {
                        "v-slider--has-labels": !!n["tick-label"] || y.value,
                        "v-slider--focused": b.value,
                        "v-slider--pressed": c.value,
                        "v-slider--disabled": e.disabled
                    }, r.value, e.class],
                    style: e.style
                }, k, {
                    focused: b.value
                }), { ...n,
                    prepend: E ? P => {
                        var x, T;
                        return m(ye, null, [((x = n.label) == null ? void 0 : x.call(n, P)) ? ? (e.label ? m(Yr, {
                            id: P.id.value,
                            class: "v-slider__label",
                            text: e.label
                        }, null) : void 0), (T = n.prepend) == null ? void 0 : T.call(n, P)])
                    } : void 0,
                    default: P => {
                        let {
                            id: x,
                            messagesId: T
                        } = P;
                        return m("div", {
                            class: "v-slider__container",
                            onMousedown: S.value ? void 0 : f,
                            onTouchstartPassive: S.value ? void 0 : v
                        }, [m("input", {
                            id: x.value,
                            name: e.name || x.value,
                            disabled: !!e.disabled,
                            readonly: !!e.readonly,
                            tabindex: "-1",
                            value: i.value
                        }, null), m(ak, {
                            ref: g,
                            start: 0,
                            stop: w.value
                        }, {
                            "tick-label": n["tick-label"]
                        }), m(ef, {
                            ref: l,
                            "aria-describedby": T.value,
                            focused: b.value,
                            min: s.value,
                            max: u.value,
                            modelValue: i.value,
                            "onUpdate:modelValue": V => i.value = V,
                            position: w.value,
                            elevation: e.elevation,
                            onFocus: p,
                            onBlur: _,
                            ripple: e.ripple,
                            name: e.name
                        }, {
                            "thumb-label": n["thumb-label"]
                        })])
                    }
                })
            }), {}
        }
    }),
    PF = W({
        color: {
            type: Object
        },
        disabled: Boolean,
        hideAlpha: Boolean,
        ...Se()
    }, "VColorPickerPreview"),
    EF = pn({
        name: "VColorPickerPreview",
        props: PF(),
        emits: {
            "update:color": e => !0
        },
        setup(e, t) {
            let {
                emit: n
            } = t;
            const a = new AbortController;
            jr(() => a.abort());
            async function l() {
                if (!ty) return;
                const r = new window.EyeDropper;
                try {
                    const o = await r.open({
                            signal: a.signal
                        }),
                        i = fS(o.sRGBHex);
                    n("update:color", { ...e.color ? ? vr,
                        ...i
                    })
                } catch {}
            }
            return ne(() => {
                var r, o;
                return m("div", {
                    class: ["v-color-picker-preview", {
                        "v-color-picker-preview--hide-alpha": e.hideAlpha
                    }, e.class],
                    style: e.style
                }, [ty && m("div", {
                    class: "v-color-picker-preview__eye-dropper",
                    key: "eyeDropper"
                }, [m(Le, {
                    onClick: l,
                    icon: "$eyeDropper",
                    variant: "plain",
                    density: "comfortable"
                }, null)]), m("div", {
                    class: "v-color-picker-preview__dot"
                }, [m("div", {
                    style: {
                        background: uS(e.color ? ? vr)
                    }
                }, null)]), m("div", {
                    class: "v-color-picker-preview__sliders"
                }, [m(tf, {
                    class: "v-color-picker-preview__track v-color-picker-preview__hue",
                    modelValue: (r = e.color) == null ? void 0 : r.h,
                    "onUpdate:modelValue": i => n("update:color", { ...e.color ? ? vr,
                        h : i
                    }),
                    step: 0,
                    min: 0,
                    max: 360,
                    disabled: e.disabled,
                    thumbSize: 14,
                    trackSize: 8,
                    trackFillColor: "white",
                    hideDetails: !0
                }, null), !e.hideAlpha && m(tf, {
                    class: "v-color-picker-preview__track v-color-picker-preview__alpha",
                    modelValue: ((o = e.color) == null ? void 0 : o.a) ? ? 1,
                    "onUpdate:modelValue": i => n("update:color", { ...e.color ? ? vr,
                        a : i
                    }),
                    step: 1 / 256,
                    min: 0,
                    max: 1,
                    disabled: e.disabled,
                    thumbSize: 14,
                    trackSize: 8,
                    trackFillColor: "white",
                    hideDetails: !0
                }, null)])])
            }), {}
        }
    }),
    IF = {
        base: "#f44336",
        lighten5: "#ffebee",
        lighten4: "#ffcdd2",
        lighten3: "#ef9a9a",
        lighten2: "#e57373",
        lighten1: "#ef5350",
        darken1: "#e53935",
        darken2: "#d32f2f",
        darken3: "#c62828",
        darken4: "#b71c1c",
        accent1: "#ff8a80",
        accent2: "#ff5252",
        accent3: "#ff1744",
        accent4: "#d50000"
    },
    TF = {
        base: "#e91e63",
        lighten5: "#fce4ec",
        lighten4: "#f8bbd0",
        lighten3: "#f48fb1",
        lighten2: "#f06292",
        lighten1: "#ec407a",
        darken1: "#d81b60",
        darken2: "#c2185b",
        darken3: "#ad1457",
        darken4: "#880e4f",
        accent1: "#ff80ab",
        accent2: "#ff4081",
        accent3: "#f50057",
        accent4: "#c51162"
    },
    VF = {
        base: "#9c27b0",
        lighten5: "#f3e5f5",
        lighten4: "#e1bee7",
        lighten3: "#ce93d8",
        lighten2: "#ba68c8",
        lighten1: "#ab47bc",
        darken1: "#8e24aa",
        darken2: "#7b1fa2",
        darken3: "#6a1b9a",
        darken4: "#4a148c",
        accent1: "#ea80fc",
        accent2: "#e040fb",
        accent3: "#d500f9",
        accent4: "#aa00ff"
    },
    AF = {
        base: "#673ab7",
        lighten5: "#ede7f6",
        lighten4: "#d1c4e9",
        lighten3: "#b39ddb",
        lighten2: "#9575cd",
        lighten1: "#7e57c2",
        darken1: "#5e35b1",
        darken2: "#512da8",
        darken3: "#4527a0",
        darken4: "#311b92",
        accent1: "#b388ff",
        accent2: "#7c4dff",
        accent3: "#651fff",
        accent4: "#6200ea"
    },
    LF = {
        base: "#3f51b5",
        lighten5: "#e8eaf6",
        lighten4: "#c5cae9",
        lighten3: "#9fa8da",
        lighten2: "#7986cb",
        lighten1: "#5c6bc0",
        darken1: "#3949ab",
        darken2: "#303f9f",
        darken3: "#283593",
        darken4: "#1a237e",
        accent1: "#8c9eff",
        accent2: "#536dfe",
        accent3: "#3d5afe",
        accent4: "#304ffe"
    },
    OF = {
        base: "#2196f3",
        lighten5: "#e3f2fd",
        lighten4: "#bbdefb",
        lighten3: "#90caf9",
        lighten2: "#64b5f6",
        lighten1: "#42a5f5",
        darken1: "#1e88e5",
        darken2: "#1976d2",
        darken3: "#1565c0",
        darken4: "#0d47a1",
        accent1: "#82b1ff",
        accent2: "#448aff",
        accent3: "#2979ff",
        accent4: "#2962ff"
    },
    RF = {
        base: "#03a9f4",
        lighten5: "#e1f5fe",
        lighten4: "#b3e5fc",
        lighten3: "#81d4fa",
        lighten2: "#4fc3f7",
        lighten1: "#29b6f6",
        darken1: "#039be5",
        darken2: "#0288d1",
        darken3: "#0277bd",
        darken4: "#01579b",
        accent1: "#80d8ff",
        accent2: "#40c4ff",
        accent3: "#00b0ff",
        accent4: "#0091ea"
    },
    DF = {
        base: "#00bcd4",
        lighten5: "#e0f7fa",
        lighten4: "#b2ebf2",
        lighten3: "#80deea",
        lighten2: "#4dd0e1",
        lighten1: "#26c6da",
        darken1: "#00acc1",
        darken2: "#0097a7",
        darken3: "#00838f",
        darken4: "#006064",
        accent1: "#84ffff",
        accent2: "#18ffff",
        accent3: "#00e5ff",
        accent4: "#00b8d4"
    },
    MF = {
        base: "#009688",
        lighten5: "#e0f2f1",
        lighten4: "#b2dfdb",
        lighten3: "#80cbc4",
        lighten2: "#4db6ac",
        lighten1: "#26a69a",
        darken1: "#00897b",
        darken2: "#00796b",
        darken3: "#00695c",
        darken4: "#004d40",
        accent1: "#a7ffeb",
        accent2: "#64ffda",
        accent3: "#1de9b6",
        accent4: "#00bfa5"
    },
    NF = {
        base: "#4caf50",
        lighten5: "#e8f5e9",
        lighten4: "#c8e6c9",
        lighten3: "#a5d6a7",
        lighten2: "#81c784",
        lighten1: "#66bb6a",
        darken1: "#43a047",
        darken2: "#388e3c",
        darken3: "#2e7d32",
        darken4: "#1b5e20",
        accent1: "#b9f6ca",
        accent2: "#69f0ae",
        accent3: "#00e676",
        accent4: "#00c853"
    },
    $F = {
        base: "#8bc34a",
        lighten5: "#f1f8e9",
        lighten4: "#dcedc8",
        lighten3: "#c5e1a5",
        lighten2: "#aed581",
        lighten1: "#9ccc65",
        darken1: "#7cb342",
        darken2: "#689f38",
        darken3: "#558b2f",
        darken4: "#33691e",
        accent1: "#ccff90",
        accent2: "#b2ff59",
        accent3: "#76ff03",
        accent4: "#64dd17"
    },
    BF = {
        base: "#cddc39",
        lighten5: "#f9fbe7",
        lighten4: "#f0f4c3",
        lighten3: "#e6ee9c",
        lighten2: "#dce775",
        lighten1: "#d4e157",
        darken1: "#c0ca33",
        darken2: "#afb42b",
        darken3: "#9e9d24",
        darken4: "#827717",
        accent1: "#f4ff81",
        accent2: "#eeff41",
        accent3: "#c6ff00",
        accent4: "#aeea00"
    },
    FF = {
        base: "#ffeb3b",
        lighten5: "#fffde7",
        lighten4: "#fff9c4",
        lighten3: "#fff59d",
        lighten2: "#fff176",
        lighten1: "#ffee58",
        darken1: "#fdd835",
        darken2: "#fbc02d",
        darken3: "#f9a825",
        darken4: "#f57f17",
        accent1: "#ffff8d",
        accent2: "#ffff00",
        accent3: "#ffea00",
        accent4: "#ffd600"
    },
    HF = {
        base: "#ffc107",
        lighten5: "#fff8e1",
        lighten4: "#ffecb3",
        lighten3: "#ffe082",
        lighten2: "#ffd54f",
        lighten1: "#ffca28",
        darken1: "#ffb300",
        darken2: "#ffa000",
        darken3: "#ff8f00",
        darken4: "#ff6f00",
        accent1: "#ffe57f",
        accent2: "#ffd740",
        accent3: "#ffc400",
        accent4: "#ffab00"
    },
    jF = {
        base: "#ff9800",
        lighten5: "#fff3e0",
        lighten4: "#ffe0b2",
        lighten3: "#ffcc80",
        lighten2: "#ffb74d",
        lighten1: "#ffa726",
        darken1: "#fb8c00",
        darken2: "#f57c00",
        darken3: "#ef6c00",
        darken4: "#e65100",
        accent1: "#ffd180",
        accent2: "#ffab40",
        accent3: "#ff9100",
        accent4: "#ff6d00"
    },
    UF = {
        base: "#ff5722",
        lighten5: "#fbe9e7",
        lighten4: "#ffccbc",
        lighten3: "#ffab91",
        lighten2: "#ff8a65",
        lighten1: "#ff7043",
        darken1: "#f4511e",
        darken2: "#e64a19",
        darken3: "#d84315",
        darken4: "#bf360c",
        accent1: "#ff9e80",
        accent2: "#ff6e40",
        accent3: "#ff3d00",
        accent4: "#dd2c00"
    },
    WF = {
        base: "#795548",
        lighten5: "#efebe9",
        lighten4: "#d7ccc8",
        lighten3: "#bcaaa4",
        lighten2: "#a1887f",
        lighten1: "#8d6e63",
        darken1: "#6d4c41",
        darken2: "#5d4037",
        darken3: "#4e342e",
        darken4: "#3e2723"
    },
    zF = {
        base: "#607d8b",
        lighten5: "#eceff1",
        lighten4: "#cfd8dc",
        lighten3: "#b0bec5",
        lighten2: "#90a4ae",
        lighten1: "#78909c",
        darken1: "#546e7a",
        darken2: "#455a64",
        darken3: "#37474f",
        darken4: "#263238"
    },
    KF = {
        base: "#9e9e9e",
        lighten5: "#fafafa",
        lighten4: "#f5f5f5",
        lighten3: "#eeeeee",
        lighten2: "#e0e0e0",
        lighten1: "#bdbdbd",
        darken1: "#757575",
        darken2: "#616161",
        darken3: "#424242",
        darken4: "#212121"
    },
    GF = {
        black: "#000000",
        white: "#ffffff",
        transparent: "#ffffff00"
    },
    YF = {
        red: IF,
        pink: TF,
        purple: VF,
        deepPurple: AF,
        indigo: LF,
        blue: OF,
        lightBlue: RF,
        cyan: DF,
        teal: MF,
        green: NF,
        lightGreen: $F,
        lime: BF,
        yellow: FF,
        amber: HF,
        orange: jF,
        deepOrange: UF,
        brown: WF,
        blueGrey: zF,
        grey: KF,
        shades: GF
    },
    qF = W({
        swatches: {
            type: Array,
            default: () => XF(YF)
        },
        disabled: Boolean,
        color: Object,
        maxHeight: [Number, String],
        ...Se()
    }, "VColorPickerSwatches");

function XF(e) {
    return Object.keys(e).map(t => {
        const n = e[t];
        return n.base ? [n.base, n.darken4, n.darken3, n.darken2, n.darken1, n.lighten1, n.lighten2, n.lighten3, n.lighten4, n.lighten5] : [n.black, n.white, n.transparent]
    })
}
const JF = pn({
        name: "VColorPickerSwatches",
        props: qF(),
        emits: {
            "update:color": e => !0
        },
        setup(e, t) {
            let {
                emit: n
            } = t;
            return ne(() => m("div", {
                class: ["v-color-picker-swatches", e.class],
                style: [{
                    maxHeight: ge(e.maxHeight)
                }, e.style]
            }, [m("div", null, [e.swatches.map(a => m("div", {
                class: "v-color-picker-swatches__swatch"
            }, [a.map(l => {
                const r = En(l),
                    o = xu(r),
                    i = sS(r);
                return m("div", {
                    class: "v-color-picker-swatches__color",
                    onClick: () => o && n("update:color", o)
                }, [m("div", {
                    style: {
                        background: i
                    }
                }, [e.color && la(e.color, o) ? m(Be, {
                    size: "x-small",
                    icon: "$success",
                    color: sM(l, "#FFFFFF") > 2 ? "white" : "black"
                }, null) : void 0])])
            })]))])])), {}
        }
    }),
    Fu = W({
        color: String,
        ...an(),
        ...Se(),
        ...bt(),
        ...Pt(),
        ...Ea(),
        ...zr(),
        ...rt(),
        ...Ae(),
        ...Ne()
    }, "VSheet"),
    Qa = Z()({
        name: "VSheet",
        props: Fu(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                themeClasses: a
            } = je(e), {
                backgroundColorClasses: l,
                backgroundColorStyles: r
            } = Ke(Y(e, "color")), {
                borderClasses: o
            } = Sn(e), {
                dimensionStyles: i
            } = pt(e), {
                elevationClasses: s
            } = Dt(e), {
                locationStyles: u
            } = Jl(e), {
                positionClasses: c
            } = Kr(e), {
                roundedClasses: d
            } = ct(e);
            return ne(() => m(e.tag, {
                class: ["v-sheet", a.value, l.value, o.value, s.value, c.value, d.value, e.class],
                style: [r.value, i.value, u.value, e.style]
            }, n)), {}
        }
    }),
    ZF = W({
        canvasHeight: {
            type: [String, Number],
            default: 150
        },
        disabled: Boolean,
        dotSize: {
            type: [Number, String],
            default: 10
        },
        hideCanvas: Boolean,
        hideSliders: Boolean,
        hideInputs: Boolean,
        mode: {
            type: String,
            default: "rgba",
            validator: e => Object.keys(El).includes(e)
        },
        modes: {
            type: Array,
            default: () => Object.keys(El),
            validator: e => Array.isArray(e) && e.every(t => Object.keys(El).includes(t))
        },
        showSwatches: Boolean,
        swatches: Array,
        swatchesMaxHeight: {
            type: [Number, String],
            default: 150
        },
        modelValue: {
            type: [Object, String]
        },
        ...We(Fu({
            width: 300
        }), ["height", "location", "minHeight", "maxHeight", "minWidth", "maxWidth"])
    }, "VColorPicker"),
    QF = pn({
        name: "VColorPicker",
        props: ZF(),
        emits: {
            "update:modelValue": e => !0,
            "update:mode": e => !0
        },
        setup(e) {
            const t = Ce(e, "mode"),
                n = Q(null),
                a = Ce(e, "modelValue", void 0, s => {
                    if (s == null || s === "") return null;
                    let u;
                    try {
                        u = xu(En(s))
                    } catch {
                        return null
                    }
                    return u
                }, s => s ? hF(s, e.modelValue) : null),
                l = C(() => a.value ? { ...a.value,
                    h: n.value ? ? a.value.h
                } : null),
                {
                    rtlClasses: r
                } = xt();
            let o = !0;
            de(a, s => {
                if (!o) {
                    o = !0;
                    return
                }
                s && (n.value = s.h)
            }, {
                immediate: !0
            });
            const i = s => {
                o = !1, n.value = s.h, a.value = s
            };
            return it(() => {
                e.modes.includes(t.value) || (t.value = e.modes[0])
            }), lt({
                VSlider: {
                    color: void 0,
                    trackColor: void 0,
                    trackFillColor: void 0
                }
            }), ne(() => {
                const s = Qa.filterProps(e);
                return m(Qa, te({
                    rounded: e.rounded,
                    elevation: e.elevation,
                    theme: e.theme,
                    class: ["v-color-picker", r.value, e.class],
                    style: [{
                        "--v-color-picker-color-hsv": uS({ ...l.value ? ? vr,
                            a : 1
                        })
                    }, e.style]
                }, s, {
                    maxWidth: e.width
                }), {
                    default: () => [!e.hideCanvas && m(vF, {
                        key: "canvas",
                        color: l.value,
                        "onUpdate:color": i,
                        disabled: e.disabled,
                        dotSize: e.dotSize,
                        width: e.width,
                        height: e.canvasHeight
                    }, null), (!e.hideSliders || !e.hideInputs) && m("div", {
                        key: "controls",
                        class: "v-color-picker__controls"
                    }, [!e.hideSliders && m(EF, {
                        key: "preview",
                        color: l.value,
                        "onUpdate:color": i,
                        hideAlpha: !t.value.endsWith("a"),
                        disabled: e.disabled
                    }, null), !e.hideInputs && m(SF, {
                        key: "edit",
                        modes: e.modes,
                        mode: t.value,
                        "onUpdate:mode": u => t.value = u,
                        color: l.value,
                        "onUpdate:color": i,
                        disabled: e.disabled
                    }, null)]), e.showSwatches && m(JF, {
                        key: "swatches",
                        color: l.value,
                        "onUpdate:color": i,
                        maxHeight: e.swatchesMaxHeight,
                        swatches: e.swatches,
                        disabled: e.disabled
                    }, null)]
                })
            }), {}
        }
    });

function e2(e, t, n) {
    if (t == null) return e;
    if (Array.isArray(t)) throw new Error("Multiple matches is not implemented");
    return typeof t == "number" && ~t ? m(ye, null, [m("span", {
        class: "v-combobox__unmask"
    }, [e.substr(0, t)]), m("span", {
        class: "v-combobox__mask"
    }, [e.substr(t, n)]), m("span", {
        class: "v-combobox__unmask"
    }, [e.substr(t + n)])]) : e
}
const t2 = W({
        autoSelectFirst: {
            type: [Boolean, String]
        },
        clearOnSelect: {
            type: Boolean,
            default: !0
        },
        delimiters: Array,
        ...Zr({
            filterKeys: ["title"]
        }),
        ...om({
            hideNoData: !0,
            returnObject: !0
        }),
        ...We(Jr({
            modelValue: null,
            role: "combobox"
        }), ["validationValue", "dirty", "appendInnerIcon"]),
        ...Wn({
            transition: !1
        })
    }, "VCombobox"),
    n2 = Z()({
        name: "VCombobox",
        props: t2(),
        emits: {
            "update:focused": e => !0,
            "update:modelValue": e => !0,
            "update:search": e => !0,
            "update:menu": e => !0
        },
        setup(e, t) {
            var pe;
            let {
                emit: n,
                slots: a
            } = t;
            const {
                t: l
            } = Qe(), r = Q(), o = fe(!1), i = fe(!0), s = fe(!1), u = Q(), c = Q(), d = Ce(e, "menu"), f = C({
                get: () => d.value,
                set: A => {
                    var O;
                    d.value && !A && ((O = u.value) != null && O.ΨopenChildren.size) || (d.value = A)
                }
            }), v = fe(-1);
            let g = !1;
            const h = C(() => {
                    var A;
                    return (A = r.value) == null ? void 0 : A.color
                }),
                y = C(() => f.value ? e.closeText : e.openText),
                {
                    items: S,
                    transformIn: b,
                    transformOut: p
                } = Qv(e),
                {
                    textColorClasses: _,
                    textColorStyles: w
                } = Ot(h),
                k = Ce(e, "modelValue", [], A => b(nt(A)), A => {
                    const O = p(A);
                    return e.multiple ? O : O[0] ? ? null
                }),
                E = gi(),
                P = C(() => !!(e.chips || a.chip)),
                x = C(() => P.value || !!a.selection),
                T = fe(!e.multiple && !x.value ? ((pe = k.value[0]) == null ? void 0 : pe.title) ? ? "" : ""),
                V = C({
                    get: () => T.value,
                    set: A => {
                        var O;
                        if (T.value = A ? ? "", !e.multiple && !x.value && (k.value = [Wa(e, A)]), A && e.multiple && ((O = e.delimiters) != null && O.length)) {
                            const K = A.split(new RegExp(`(?:${e.delimiters.join("|")})+`));
                            K.length > 1 && (K.forEach(J => {
                                J = J.trim(), J && le(Wa(e, J))
                            }), T.value = "")
                        }
                        A || (v.value = -1), i.value = !A
                    }
                }),
                I = C(() => typeof e.counterValue == "function" ? e.counterValue(k.value) : typeof e.counterValue == "number" ? e.counterValue : e.multiple ? k.value.length : V.value.length);
            de(T, A => {
                g ? Re(() => g = !1) : o.value && !f.value && (f.value = !0), n("update:search", A)
            }), de(k, A => {
                var O;
                !e.multiple && !x.value && (T.value = ((O = A[0]) == null ? void 0 : O.title) ? ? "")
            });
            const {
                filteredItems: R,
                getMatches: B
            } = Qr(e, S, () => i.value ? "" : V.value), $ = C(() => e.hideSelected ? R.value.filter(A => !k.value.some(O => O.value === A.value)) : R.value), D = C(() => k.value.map(A => A.value)), z = C(() => {
                var O;
                return (e.autoSelectFirst === !0 || e.autoSelectFirst === "exact" && V.value === ((O = $.value[0]) == null ? void 0 : O.title)) && $.value.length > 0 && !i.value && !s.value
            }), N = C(() => e.hideNoData && !$.value.length || e.readonly || (E == null ? void 0 : E.isReadonly.value)), H = Q(), F = rm(H, r);

            function j(A) {
                g = !0, e.openOnClear && (f.value = !0)
            }

            function ae() {
                N.value || (f.value = !0)
            }

            function he(A) {
                N.value || (o.value && (A.preventDefault(), A.stopPropagation()), f.value = !f.value)
            }

            function ve(A) {
                var O;
                Ls(A) && ((O = r.value) == null || O.focus())
            }

            function we(A) {
                var J;
                if (LD(A) || e.readonly || E != null && E.isReadonly.value) return;
                const O = r.value.selectionStart,
                    K = k.value.length;
                if ((v.value > -1 || ["Enter", "ArrowDown", "ArrowUp"].includes(A.key)) && A.preventDefault(), ["Enter", "ArrowDown"].includes(A.key) && (f.value = !0), ["Escape"].includes(A.key) && (f.value = !1), ["Enter", "Escape", "Tab"].includes(A.key) && (z.value && ["Enter", "Tab"].includes(A.key) && !k.value.some(X => {
                        let {
                            value: ue
                        } = X;
                        return ue === $.value[0].value
                    }) && le(R.value[0]), i.value = !0), A.key === "ArrowDown" && z.value && ((J = H.value) == null || J.focus("next")), A.key === "Enter" && V.value && (le(Wa(e, V.value)), x.value && (T.value = "")), ["Backspace", "Delete"].includes(A.key)) {
                    if (!e.multiple && x.value && k.value.length > 0 && !V.value) return le(k.value[0], !1);
                    if (~v.value) {
                        const X = v.value;
                        le(k.value[v.value], !1), v.value = X >= K - 1 ? K - 2 : X
                    } else A.key === "Backspace" && !V.value && (v.value = K - 1)
                }
                if (e.multiple) {
                    if (A.key === "ArrowLeft") {
                        if (v.value < 0 && O > 0) return;
                        const X = v.value > -1 ? v.value - 1 : K - 1;
                        k.value[X] ? v.value = X : (v.value = -1, r.value.setSelectionRange(V.value.length, V.value.length))
                    }
                    if (A.key === "ArrowRight") {
                        if (v.value < 0) return;
                        const X = v.value + 1;
                        k.value[X] ? v.value = X : (v.value = -1, r.value.setSelectionRange(0, 0))
                    }
                }
            }

            function ee() {
                var A;
                e.eager && ((A = c.value) == null || A.calculateVisibleItems())
            }

            function G() {
                var A;
                o.value && (i.value = !0, (A = r.value) == null || A.focus())
            }

            function le(A) {
                let O = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
                if (!(!A || A.props.disabled))
                    if (e.multiple) {
                        const K = k.value.findIndex(X => e.valueComparator(X.value, A.value)),
                            J = O ? ? !~K;
                        if (~K) {
                            const X = J ? [...k.value, A] : [...k.value];
                            X.splice(K, 1), k.value = X
                        } else J && (k.value = [...k.value, A]);
                        e.clearOnSelect && (V.value = "")
                    } else {
                        const K = O !== !1;
                        k.value = K ? [A] : [], T.value = K && !x.value ? A.title : "", Re(() => {
                            f.value = !1, i.value = !0
                        })
                    }
            }

            function se(A) {
                o.value = !0, setTimeout(() => {
                    s.value = !0
                })
            }

            function ce(A) {
                s.value = !1
            }

            function re(A) {
                (A == null || A === "" && !e.multiple && !x.value) && (k.value = [])
            }
            return de(o, (A, O) => {
                if (!(A || A === O) && (v.value = -1, f.value = !1, V.value)) {
                    if (e.multiple) {
                        le(Wa(e, V.value));
                        return
                    }
                    if (!x.value) return;
                    k.value.some(K => {
                        let {
                            title: J
                        } = K;
                        return J === V.value
                    }) ? T.value = "" : le(Wa(e, V.value))
                }
            }), de(f, () => {
                if (!e.hideSelected && f.value && k.value.length) {
                    const A = $.value.findIndex(O => k.value.some(K => e.valueComparator(K.value, O.value)));
                    Ue && window.requestAnimationFrame(() => {
                        var O;
                        A >= 0 && ((O = c.value) == null || O.scrollToIndex(A))
                    })
                }
            }), de(() => e.items, (A, O) => {
                f.value || o.value && !O.length && A.length && (f.value = !0)
            }), ne(() => {
                const A = !!(!e.hideNoData || $.value.length || a["prepend-item"] || a["append-item"] || a["no-data"]),
                    O = k.value.length > 0,
                    K = Un.filterProps(e);
                return m(Un, te({
                    ref: r
                }, K, {
                    modelValue: V.value,
                    "onUpdate:modelValue": [J => V.value = J, re],
                    focused: o.value,
                    "onUpdate:focused": J => o.value = J,
                    validationValue: k.externalValue,
                    counterValue: I.value,
                    dirty: O,
                    class: ["v-combobox", {
                        "v-combobox--active-menu": f.value,
                        "v-combobox--chips": !!e.chips,
                        "v-combobox--selection-slot": !!x.value,
                        "v-combobox--selecting-index": v.value > -1,
                        [`v-combobox--${e.multiple?"multiple":"single"}`]: !0
                    }, e.class],
                    style: e.style,
                    readonly: e.readonly,
                    placeholder: O ? void 0 : e.placeholder,
                    "onClick:clear": j,
                    "onMousedown:control": ae,
                    onKeydown: we
                }), { ...a,
                    default: () => m(ye, null, [m(Ol, te({
                        ref: u,
                        modelValue: f.value,
                        "onUpdate:modelValue": J => f.value = J,
                        activator: "parent",
                        contentClass: "v-combobox__content",
                        disabled: N.value,
                        eager: e.eager,
                        maxHeight: 310,
                        openOnClick: !1,
                        closeOnContentClick: !1,
                        transition: e.transition,
                        onAfterEnter: ee,
                        onAfterLeave: G
                    }, e.menuProps), {
                        default: () => [A && m(Mr, te({
                            ref: H,
                            selected: D.value,
                            selectStrategy: e.multiple ? "independent" : "single-independent",
                            onMousedown: J => J.preventDefault(),
                            onKeydown: ve,
                            onFocusin: se,
                            onFocusout: ce,
                            tabindex: "-1",
                            "aria-live": "polite",
                            color: e.itemColor ? ? e.color
                        }, F, e.listProps), {
                            default: () => {
                                var J, X, ue;
                                return [(J = a["prepend-item"]) == null ? void 0 : J.call(a), !$.value.length && !e.hideNoData && (((X = a["no-data"]) == null ? void 0 : X.call(a)) ? ? m(jn, {
                                    title: l(e.noDataText)
                                }, null)), m(Nu, {
                                    ref: c,
                                    renderless: !0,
                                    items: $.value
                                }, {
                                    default: be => {
                                        var _e;
                                        let {
                                            item: L,
                                            index: M,
                                            itemRef: U
                                        } = be;
                                        const ie = te(L.props, {
                                            ref: U,
                                            key: M,
                                            active: z.value && M === 0 ? !0 : void 0,
                                            onClick: () => le(L, null)
                                        });
                                        return ((_e = a.item) == null ? void 0 : _e.call(a, {
                                            item: L,
                                            index: M,
                                            props: ie
                                        })) ? ? m(jn, te(ie, {
                                            role: "option"
                                        }), {
                                            prepend: me => {
                                                let {
                                                    isSelected: q
                                                } = me;
                                                return m(ye, null, [e.multiple && !e.hideSelected ? m(Qn, {
                                                    key: L.value,
                                                    modelValue: q,
                                                    ripple: !1,
                                                    tabindex: "-1"
                                                }, null) : void 0, L.props.prependAvatar && m(yn, {
                                                    image: L.props.prependAvatar
                                                }, null), L.props.prependIcon && m(Be, {
                                                    icon: L.props.prependIcon
                                                }, null)])
                                            },
                                            title: () => {
                                                var me, q;
                                                return i.value ? L.title : e2(L.title, (me = B(L)) == null ? void 0 : me.title, ((q = V.value) == null ? void 0 : q.length) ? ? 0)
                                            }
                                        })
                                    }
                                }), (ue = a["append-item"]) == null ? void 0 : ue.call(a)]
                            }
                        })]
                    }), k.value.map((J, X) => {
                        function ue(U) {
                            U.stopPropagation(), U.preventDefault(), le(J, !1)
                        }
                        const be = {
                                "onClick:close": ue,
                                onKeydown(U) {
                                    U.key !== "Enter" && U.key !== " " || (U.preventDefault(), U.stopPropagation(), ue(U))
                                },
                                onMousedown(U) {
                                    U.preventDefault(), U.stopPropagation()
                                },
                                modelValue: !0,
                                "onUpdate:modelValue": void 0
                            },
                            L = P.value ? !!a.chip : !!a.selection,
                            M = L ? Cu(P.value ? a.chip({
                                item: J,
                                index: X,
                                props: be
                            }) : a.selection({
                                item: J,
                                index: X
                            })) : void 0;
                        if (!(L && !M)) return m("div", {
                            key: J.value,
                            class: ["v-combobox__selection", X === v.value && ["v-combobox__selection--selected", _.value]],
                            style: X === v.value ? w.value : {}
                        }, [P.value ? a.chip ? m(Ve, {
                            key: "chip-defaults",
                            defaults: {
                                VChip: {
                                    closable: e.closableChips,
                                    size: "small",
                                    text: J.title
                                }
                            }
                        }, {
                            default: () => [M]
                        }) : m(Zl, te({
                            key: "chip",
                            closable: e.closableChips,
                            size: "small",
                            text: J.title,
                            disabled: J.props.disabled
                        }, be), null) : M ? ? m("span", {
                            class: "v-combobox__selection-text"
                        }, [J.title, e.multiple && X < k.value.length - 1 && m("span", {
                            class: "v-combobox__selection-comma"
                        }, [hn(",")])])])
                    })]),
                    "append-inner": function() {
                        var be;
                        for (var J = arguments.length, X = new Array(J), ue = 0; ue < J; ue++) X[ue] = arguments[ue];
                        return m(ye, null, [(be = a["append-inner"]) == null ? void 0 : be.call(a, ...X), (!e.hideNoData || e.items.length) && e.menuIcon ? m(Be, {
                            class: "v-combobox__menu-icon",
                            icon: e.menuIcon,
                            onMousedown: he,
                            onClick: tS,
                            "aria-label": l(y.value),
                            title: l(y.value),
                            tabindex: "-1"
                        }, null) : void 0])
                    }
                })
            }), wn({
                isFocused: o,
                isPristine: i,
                menu: f,
                search: V,
                selectionIndex: v,
                filteredItems: R,
                select: le
            }, r)
        }
    }),
    lk = W({
        modelValue: null,
        color: String,
        cancelText: {
            type: String,
            default: "$vuetify.confirmEdit.cancel"
        },
        okText: {
            type: String,
            default: "$vuetify.confirmEdit.ok"
        }
    }, "VConfirmEdit"),
    nf = Z()({
        name: "VConfirmEdit",
        props: lk(),
        emits: {
            cancel: () => !0,
            save: e => !0,
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                emit: n,
                slots: a
            } = t;
            const l = Ce(e, "modelValue"),
                r = Q();
            st(() => {
                r.value = structuredClone(xe(l.value))
            });
            const {
                t: o
            } = Qe(), i = C(() => la(l.value, r.value));

            function s() {
                l.value = r.value, n("save", r.value)
            }

            function u() {
                r.value = structuredClone(xe(l.value)), n("cancel")
            }
            let c = !1;
            return ne(() => {
                var f;
                const d = m(ye, null, [m(Le, {
                    disabled: i.value,
                    variant: "text",
                    color: e.color,
                    onClick: u,
                    text: o(e.cancelText)
                }, null), m(Le, {
                    disabled: i.value,
                    variant: "text",
                    color: e.color,
                    onClick: s,
                    text: o(e.okText)
                }, null)]);
                return m(ye, null, [(f = a.default) == null ? void 0 : f.call(a, {
                    model: r,
                    save: s,
                    cancel: u,
                    isPristine: i.value,
                    get actions() {
                        return c = !0, d
                    }
                }), !c && d])
            }), {
                save: s,
                cancel: u,
                isPristine: i
            }
        }
    }),
    rk = W({
        expandOnClick: Boolean,
        showExpand: Boolean,
        expanded: {
            type: Array,
            default: () => []
        }
    }, "DataTable-expand"),
    ok = Symbol.for("vuetify:datatable:expanded");

function Hu(e) {
    const t = Y(e, "expandOnClick"),
        n = Ce(e, "expanded", e.expanded, i => new Set(i), i => [...i.values()]);

    function a(i, s) {
        const u = new Set(n.value);
        s ? u.add(i.value) : u.delete(i.value), n.value = u
    }

    function l(i) {
        return n.value.has(i.value)
    }

    function r(i) {
        a(i, !l(i))
    }
    const o = {
        expand: a,
        expanded: n,
        expandOnClick: t,
        isExpanded: l,
        toggleExpand: r
    };
    return He(ok, o), o
}

function ik() {
    const e = Te(ok);
    if (!e) throw new Error("foo");
    return e
}
const cm = W({
        groupBy: {
            type: Array,
            default: () => []
        }
    }, "DataTable-group"),
    sk = Symbol.for("vuetify:data-table-group");

function dm(e) {
    return {
        groupBy: Ce(e, "groupBy")
    }
}

function ju(e) {
    const {
        disableSort: t,
        groupBy: n,
        sortBy: a
    } = e, l = Q(new Set), r = C(() => n.value.map(c => ({ ...c,
        order: c.order ? ? !1
    })).concat(t != null && t.value ? [] : a.value));

    function o(c) {
        return l.value.has(c.id)
    }

    function i(c) {
        const d = new Set(l.value);
        o(c) ? d.delete(c.id) : d.add(c.id), l.value = d
    }

    function s(c) {
        function d(f) {
            const v = [];
            for (const g of f.items) "type" in g && g.type === "group" ? v.push(...d(g)) : v.push(g);
            return v
        }
        return d({
            type: "group",
            items: c,
            id: "dummy",
            key: "dummy",
            value: "dummy",
            depth: 0
        })
    }
    const u = {
        sortByWithGroups: r,
        toggleGroup: i,
        opened: l,
        groupBy: n,
        extractRows: s,
        isGroupOpen: o
    };
    return He(sk, u), u
}

function uk() {
    const e = Te(sk);
    if (!e) throw new Error("Missing group!");
    return e
}

function a2(e, t) {
    if (!e.length) return [];
    const n = new Map;
    for (const a of e) {
        const l = Ll(a.raw, t);
        n.has(l) || n.set(l, []), n.get(l).push(a)
    }
    return n
}

function ck(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,
        a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "root";
    if (!t.length) return [];
    const l = a2(e, t[0]),
        r = [],
        o = t.slice(1);
    return l.forEach((i, s) => {
        const u = t[0],
            c = `${a}_${u}_${s}`;
        r.push({
            depth: n,
            id: c,
            key: u,
            value: s,
            items: o.length ? ck(i, o, n + 1, c) : i,
            type: "group"
        })
    }), r
}

function dk(e, t) {
    const n = [];
    for (const a of e) "type" in a && a.type === "group" ? (a.value != null && n.push(a), (t.has(a.id) || a.value == null) && n.push(...dk(a.items, t))) : n.push(a);
    return n
}

function Uu(e, t, n) {
    return {
        flatItems: C(() => {
            if (!t.value.length) return e.value;
            const l = ck(e.value, t.value.map(r => r.key));
            return dk(l, n.value)
        })
    }
}

function Wu(e) {
    let {
        page: t,
        itemsPerPage: n,
        sortBy: a,
        groupBy: l,
        search: r
    } = e;
    const o = ut("VDataTable"),
        i = C(() => ({
            page: t.value,
            itemsPerPage: n.value,
            sortBy: a.value,
            groupBy: l.value,
            search: r.value
        }));
    let s = null;
    de(i, () => {
        la(s, i.value) || (s && s.search !== i.value.search && (t.value = 1), o.emit("update:options", i.value), s = i.value)
    }, {
        deep: !0,
        immediate: !0
    })
}
const fm = W({
        page: {
            type: [Number, String],
            default: 1
        },
        itemsPerPage: {
            type: [Number, String],
            default: 10
        }
    }, "DataTable-paginate"),
    fk = Symbol.for("vuetify:data-table-pagination");

function vm(e) {
    const t = Ce(e, "page", void 0, a => +(a ? ? 1)),
        n = Ce(e, "itemsPerPage", void 0, a => +(a ? ? 10));
    return {
        page: t,
        itemsPerPage: n
    }
}

function mm(e) {
    const {
        page: t,
        itemsPerPage: n,
        itemsLength: a
    } = e, l = C(() => n.value === -1 ? 0 : n.value * (t.value - 1)), r = C(() => n.value === -1 ? a.value : Math.min(a.value, l.value + n.value)), o = C(() => n.value === -1 || a.value === 0 ? 1 : Math.ceil(a.value / n.value));
    st(() => {
        t.value > o.value && (t.value = o.value)
    });

    function i(f) {
        n.value = f, t.value = 1
    }

    function s() {
        t.value = ot(t.value + 1, 1, o.value)
    }

    function u() {
        t.value = ot(t.value - 1, 1, o.value)
    }

    function c(f) {
        t.value = ot(f, 1, o.value)
    }
    const d = {
        page: t,
        itemsPerPage: n,
        startIndex: l,
        stopIndex: r,
        pageCount: o,
        itemsLength: a,
        nextPage: s,
        prevPage: u,
        setPage: c,
        setItemsPerPage: i
    };
    return He(fk, d), d
}

function l2() {
    const e = Te(fk);
    if (!e) throw new Error("Missing pagination!");
    return e
}

function vk(e) {
    const t = ut("usePaginatedItems"),
        {
            items: n,
            startIndex: a,
            stopIndex: l,
            itemsPerPage: r
        } = e,
        o = C(() => r.value <= 0 ? n.value : n.value.slice(a.value, l.value));
    return de(o, i => {
        t.emit("update:currentItems", i)
    }), {
        paginatedItems: o
    }
}
const r2 = {
        showSelectAll: !1,
        allSelected: () => [],
        select: e => {
            var a;
            let {
                items: t,
                value: n
            } = e;
            return new Set(n ? [(a = t[0]) == null ? void 0 : a.value] : [])
        },
        selectAll: e => {
            let {
                selected: t
            } = e;
            return t
        }
    },
    mk = {
        showSelectAll: !0,
        allSelected: e => {
            let {
                currentPage: t
            } = e;
            return t
        },
        select: e => {
            let {
                items: t,
                value: n,
                selected: a
            } = e;
            for (const l of t) n ? a.add(l.value) : a.delete(l.value);
            return a
        },
        selectAll: e => {
            let {
                value: t,
                currentPage: n,
                selected: a
            } = e;
            return mk.select({
                items: n,
                value: t,
                selected: a
            })
        }
    },
    hk = {
        showSelectAll: !0,
        allSelected: e => {
            let {
                allItems: t
            } = e;
            return t
        },
        select: e => {
            let {
                items: t,
                value: n,
                selected: a
            } = e;
            for (const l of t) n ? a.add(l.value) : a.delete(l.value);
            return a
        },
        selectAll: e => {
            let {
                value: t,
                allItems: n,
                selected: a
            } = e;
            return hk.select({
                items: n,
                value: t,
                selected: a
            })
        }
    },
    gk = W({
        showSelect: Boolean,
        selectStrategy: {
            type: [String, Object],
            default: "page"
        },
        modelValue: {
            type: Array,
            default: () => []
        },
        valueComparator: {
            type: Function,
            default: la
        }
    }, "DataTable-select"),
    yk = Symbol.for("vuetify:data-table-selection");

function zu(e, t) {
    let {
        allItems: n,
        currentPage: a
    } = t;
    const l = Ce(e, "modelValue", e.modelValue, S => new Set(nt(S).map(b => {
            var p;
            return ((p = n.value.find(_ => e.valueComparator(b, _.value))) == null ? void 0 : p.value) ? ? b
        })), S => [...S.values()]),
        r = C(() => n.value.filter(S => S.selectable)),
        o = C(() => a.value.filter(S => S.selectable)),
        i = C(() => {
            if (typeof e.selectStrategy == "object") return e.selectStrategy;
            switch (e.selectStrategy) {
                case "single":
                    return r2;
                case "all":
                    return hk;
                case "page":
                default:
                    return mk
            }
        });

    function s(S) {
        return nt(S).every(b => l.value.has(b.value))
    }

    function u(S) {
        return nt(S).some(b => l.value.has(b.value))
    }

    function c(S, b) {
        const p = i.value.select({
            items: S,
            value: b,
            selected: new Set(l.value)
        });
        l.value = p
    }

    function d(S) {
        c([S], !s([S]))
    }

    function f(S) {
        const b = i.value.selectAll({
            value: S,
            allItems: r.value,
            currentPage: o.value,
            selected: new Set(l.value)
        });
        l.value = b
    }
    const v = C(() => l.value.size > 0),
        g = C(() => {
            const S = i.value.allSelected({
                allItems: r.value,
                currentPage: o.value
            });
            return !!S.length && s(S)
        }),
        h = C(() => i.value.showSelectAll),
        y = {
            toggleSelect: d,
            select: c,
            selectAll: f,
            isSelected: s,
            isSomeSelected: u,
            someSelected: v,
            allSelected: g,
            showSelectAll: h
        };
    return He(yk, y), y
}

function Ku() {
    const e = Te(yk);
    if (!e) throw new Error("Missing selection!");
    return e
}
const bk = W({
        sortBy: {
            type: Array,
            default: () => []
        },
        customKeySort: Object,
        multiSort: Boolean,
        mustSort: Boolean
    }, "DataTable-sort"),
    pk = Symbol.for("vuetify:data-table-sort");

function Gu(e) {
    const t = Ce(e, "sortBy"),
        n = Y(e, "mustSort"),
        a = Y(e, "multiSort");
    return {
        sortBy: t,
        mustSort: n,
        multiSort: a
    }
}

function Yu(e) {
    const {
        sortBy: t,
        mustSort: n,
        multiSort: a,
        page: l
    } = e, r = s => {
        if (s.key == null) return;
        let u = t.value.map(d => ({ ...d
        })) ? ? [];
        const c = u.find(d => d.key === s.key);
        c ? c.order === "desc" ? n.value ? c.order = "asc" : u = u.filter(d => d.key !== s.key) : c.order = "desc" : a.value ? u = [...u, {
            key: s.key,
            order: "asc"
        }] : u = [{
            key: s.key,
            order: "asc"
        }], t.value = u, l && (l.value = 1)
    };

    function o(s) {
        return !!t.value.find(u => u.key === s.key)
    }
    const i = {
        sortBy: t,
        toggleSort: r,
        isSorted: o
    };
    return He(pk, i), i
}

function _k() {
    const e = Te(pk);
    if (!e) throw new Error("Missing sort!");
    return e
}

function hm(e, t, n, a) {
    const l = Qe();
    return {
        sortedItems: C(() => {
            var o, i;
            return n.value.length ? o2(t.value, n.value, l.current.value, {
                transform: a == null ? void 0 : a.transform,
                sortFunctions: { ...e.customKeySort,
                    ...(o = a == null ? void 0 : a.sortFunctions) == null ? void 0 : o.value
                },
                sortRawFunctions: (i = a == null ? void 0 : a.sortRawFunctions) == null ? void 0 : i.value
            }) : t.value
        })
    }
}

function o2(e, t, n, a) {
    const l = new Intl.Collator(n, {
        sensitivity: "accent",
        usage: "sort"
    });
    return e.map(o => [o, a != null && a.transform ? a.transform(o) : o]).sort((o, i) => {
        var s, u;
        for (let c = 0; c < t.length; c++) {
            let d = !1;
            const f = t[c].key,
                v = t[c].order ? ? "asc";
            if (v === !1) continue;
            let g = Ll(o[1], f),
                h = Ll(i[1], f),
                y = o[0].raw,
                S = i[0].raw;
            if (v === "desc" && ([g, h] = [h, g], [y, S] = [S, y]), (s = a == null ? void 0 : a.sortRawFunctions) != null && s[f]) {
                const b = a.sortRawFunctions[f](y, S);
                if (b == null) continue;
                if (d = !0, b) return b
            }
            if ((u = a == null ? void 0 : a.sortFunctions) != null && u[f]) {
                const b = a.sortFunctions[f](g, h);
                if (b == null) continue;
                if (d = !0, b) return b
            }
            if (!d) {
                if (g instanceof Date && h instanceof Date) return g.getTime() - h.getTime();
                if ([g, h] = [g, h].map(b => b != null ? b.toString().toLocaleLowerCase() : b), g !== h) return Fi(g) && Fi(h) ? 0 : Fi(g) ? -1 : Fi(h) ? 1 : !isNaN(g) && !isNaN(h) ? Number(g) - Number(h) : l.compare(g, h)
            }
        }
        return 0
    }).map(o => {
        let [i] = o;
        return i
    })
}
const i2 = W({
    items: {
        type: Array,
        default: () => []
    },
    itemValue: {
        type: [String, Array, Function],
        default: "id"
    },
    itemSelectable: {
        type: [String, Array, Function],
        default: null
    },
    returnObject: Boolean
}, "DataIterator-items");

function s2(e, t) {
    const n = e.returnObject ? t : vt(t, e.itemValue),
        a = vt(t, e.itemSelectable, !0);
    return {
        type: "item",
        value: n,
        selectable: a,
        raw: t
    }
}

function u2(e, t) {
    const n = [];
    for (const a of t) n.push(s2(e, a));
    return n
}

function c2(e) {
    return {
        items: C(() => u2(e, e.items))
    }
}
const d2 = W({
        search: String,
        loading: Boolean,
        ...Se(),
        ...i2(),
        ...gk(),
        ...bk(),
        ...fm({
            itemsPerPage: 5
        }),
        ...rk(),
        ...cm(),
        ...Zr(),
        ...Ae(),
        ...Wn({
            transition: {
                component: jo,
                hideOnLeave: !0
            }
        })
    }, "VDataIterator"),
    f2 = Z()({
        name: "VDataIterator",
        props: d2(),
        emits: {
            "update:modelValue": e => !0,
            "update:groupBy": e => !0,
            "update:page": e => !0,
            "update:itemsPerPage": e => !0,
            "update:sortBy": e => !0,
            "update:options": e => !0,
            "update:expanded": e => !0,
            "update:currentItems": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Ce(e, "groupBy"),
                l = Y(e, "search"),
                {
                    items: r
                } = c2(e),
                {
                    filteredItems: o
                } = Qr(e, r, l, {
                    transform: j => j.raw
                }),
                {
                    sortBy: i,
                    multiSort: s,
                    mustSort: u
                } = Gu(e),
                {
                    page: c,
                    itemsPerPage: d
                } = vm(e),
                {
                    toggleSort: f
                } = Yu({
                    sortBy: i,
                    multiSort: s,
                    mustSort: u,
                    page: c
                }),
                {
                    sortByWithGroups: v,
                    opened: g,
                    extractRows: h,
                    isGroupOpen: y,
                    toggleGroup: S
                } = ju({
                    groupBy: a,
                    sortBy: i
                }),
                {
                    sortedItems: b
                } = hm(e, o, v, {
                    transform: j => j.raw
                }),
                {
                    flatItems: p
                } = Uu(b, a, g),
                _ = C(() => p.value.length),
                {
                    startIndex: w,
                    stopIndex: k,
                    pageCount: E,
                    prevPage: P,
                    nextPage: x,
                    setItemsPerPage: T,
                    setPage: V
                } = mm({
                    page: c,
                    itemsPerPage: d,
                    itemsLength: _
                }),
                {
                    paginatedItems: I
                } = vk({
                    items: p,
                    startIndex: w,
                    stopIndex: k,
                    itemsPerPage: d
                }),
                R = C(() => h(I.value)),
                {
                    isSelected: B,
                    select: $,
                    selectAll: D,
                    toggleSelect: z
                } = zu(e, {
                    allItems: r,
                    currentPage: R
                }),
                {
                    isExpanded: N,
                    toggleExpand: H
                } = Hu(e);
            Wu({
                page: c,
                itemsPerPage: d,
                sortBy: i,
                groupBy: a,
                search: l
            });
            const F = C(() => ({
                page: c.value,
                itemsPerPage: d.value,
                sortBy: i.value,
                pageCount: E.value,
                toggleSort: f,
                prevPage: P,
                nextPage: x,
                setPage: V,
                setItemsPerPage: T,
                isSelected: B,
                select: $,
                selectAll: D,
                toggleSelect: z,
                isExpanded: N,
                toggleExpand: H,
                isGroupOpen: y,
                toggleGroup: S,
                items: R.value,
                groupedItems: I.value
            }));
            return ne(() => m(e.tag, {
                class: ["v-data-iterator", {
                    "v-data-iterator--loading": e.loading
                }, e.class],
                style: e.style
            }, {
                default: () => {
                    var j, ae;
                    return [(j = n.header) == null ? void 0 : j.call(n, F.value), m(jt, {
                        transition: e.transition
                    }, {
                        default: () => {
                            var he, ve;
                            return [e.loading ? m(mi, {
                                key: "loader",
                                name: "v-data-iterator",
                                active: !0
                            }, {
                                default: we => {
                                    var ee;
                                    return (ee = n.loader) == null ? void 0 : ee.call(n, we)
                                }
                            }) : m("div", {
                                key: "items"
                            }, [I.value.length ? (ve = n.default) == null ? void 0 : ve.call(n, F.value) : (he = n["no-data"]) == null ? void 0 : he.call(n)])]
                        }
                    }), (ae = n.footer) == null ? void 0 : ae.call(n, F.value)]
                }
            })), {}
        }
    });

function v2() {
    const e = Q([]);
    Gf(() => e.value = []);

    function t(n, a) {
        e.value[a] = n
    }
    return {
        refs: e,
        updateRef: t
    }
}
const m2 = W({
        activeColor: String,
        start: {
            type: [Number, String],
            default: 1
        },
        modelValue: {
            type: Number,
            default: e => e.start
        },
        disabled: Boolean,
        length: {
            type: [Number, String],
            default: 1,
            validator: e => e % 1 === 0
        },
        totalVisible: [Number, String],
        firstIcon: {
            type: Pe,
            default: "$first"
        },
        prevIcon: {
            type: Pe,
            default: "$prev"
        },
        nextIcon: {
            type: Pe,
            default: "$next"
        },
        lastIcon: {
            type: Pe,
            default: "$last"
        },
        ariaLabel: {
            type: String,
            default: "$vuetify.pagination.ariaLabel.root"
        },
        pageAriaLabel: {
            type: String,
            default: "$vuetify.pagination.ariaLabel.page"
        },
        currentPageAriaLabel: {
            type: String,
            default: "$vuetify.pagination.ariaLabel.currentPage"
        },
        firstAriaLabel: {
            type: String,
            default: "$vuetify.pagination.ariaLabel.first"
        },
        previousAriaLabel: {
            type: String,
            default: "$vuetify.pagination.ariaLabel.previous"
        },
        nextAriaLabel: {
            type: String,
            default: "$vuetify.pagination.ariaLabel.next"
        },
        lastAriaLabel: {
            type: String,
            default: "$vuetify.pagination.ariaLabel.last"
        },
        ellipsis: {
            type: String,
            default: "..."
        },
        showFirstLastPage: Boolean,
        ...an(),
        ...Se(),
        ...Vt(),
        ...Pt(),
        ...rt(),
        ...sa(),
        ...Ae({
            tag: "nav"
        }),
        ...Ne(),
        ...Rn({
            variant: "text"
        })
    }, "VPagination"),
    af = Z()({
        name: "VPagination",
        props: m2(),
        emits: {
            "update:modelValue": e => !0,
            first: e => !0,
            prev: e => !0,
            next: e => !0,
            last: e => !0
        },
        setup(e, t) {
            let {
                slots: n,
                emit: a
            } = t;
            const l = Ce(e, "modelValue"),
                {
                    t: r,
                    n: o
                } = Qe(),
                {
                    isRtl: i
                } = xt(),
                {
                    themeClasses: s
                } = je(e),
                {
                    width: u
                } = On(),
                c = fe(-1);
            lt(void 0, {
                scoped: !0
            });
            const {
                resizeRef: d
            } = Hn(P => {
                if (!P.length) return;
                const {
                    target: x,
                    contentRect: T
                } = P[0], V = x.querySelector(".v-pagination__list > *");
                if (!V) return;
                const I = T.width,
                    R = V.offsetWidth + parseFloat(getComputedStyle(V).marginRight) * 2;
                c.value = h(I, R)
            }), f = C(() => parseInt(e.length, 10)), v = C(() => parseInt(e.start, 10)), g = C(() => e.totalVisible != null ? parseInt(e.totalVisible, 10) : c.value >= 0 ? c.value : h(u.value, 58));

            function h(P, x) {
                const T = e.showFirstLastPage ? 5 : 3;
                return Math.max(0, Math.floor(+((P - x * T) / x).toFixed(2)))
            }
            const y = C(() => {
                if (f.value <= 0 || isNaN(f.value) || f.value > Number.MAX_SAFE_INTEGER) return [];
                if (g.value <= 0) return [];
                if (g.value === 1) return [l.value];
                if (f.value <= g.value) return fn(f.value, v.value);
                const P = g.value % 2 === 0,
                    x = P ? g.value / 2 : Math.floor(g.value / 2),
                    T = P ? x : x + 1,
                    V = f.value - x;
                if (T - l.value >= 0) return [...fn(Math.max(1, g.value - 1), v.value), e.ellipsis, f.value];
                if (l.value - V >= (P ? 1 : 0)) {
                    const I = g.value - 1,
                        R = f.value - I + v.value;
                    return [v.value, e.ellipsis, ...fn(I, R)]
                } else {
                    const I = Math.max(1, g.value - 3),
                        R = I === 1 ? l.value : l.value - Math.ceil(I / 2) + v.value;
                    return [v.value, e.ellipsis, ...fn(I, R), e.ellipsis, f.value]
                }
            });

            function S(P, x, T) {
                P.preventDefault(), l.value = x, T && a(T, x)
            }
            const {
                refs: b,
                updateRef: p
            } = v2();
            lt({
                VPaginationBtn: {
                    color: Y(e, "color"),
                    border: Y(e, "border"),
                    density: Y(e, "density"),
                    size: Y(e, "size"),
                    variant: Y(e, "variant"),
                    rounded: Y(e, "rounded"),
                    elevation: Y(e, "elevation")
                }
            });
            const _ = C(() => y.value.map((P, x) => {
                    const T = V => p(V, x);
                    if (typeof P == "string") return {
                        isActive: !1,
                        key: `ellipsis-${x}`,
                        page: P,
                        props: {
                            ref: T,
                            ellipsis: !0,
                            icon: !0,
                            disabled: !0
                        }
                    }; {
                        const V = P === l.value;
                        return {
                            isActive: V,
                            key: P,
                            page: o(P),
                            props: {
                                ref: T,
                                ellipsis: !1,
                                icon: !0,
                                disabled: !!e.disabled || +e.length < 2,
                                color: V ? e.activeColor : e.color,
                                "aria-current": V,
                                "aria-label": r(V ? e.currentPageAriaLabel : e.pageAriaLabel, P),
                                onClick: I => S(I, P)
                            }
                        }
                    }
                })),
                w = C(() => {
                    const P = !!e.disabled || l.value <= v.value,
                        x = !!e.disabled || l.value >= v.value + f.value - 1;
                    return {
                        first: e.showFirstLastPage ? {
                            icon: i.value ? e.lastIcon : e.firstIcon,
                            onClick: T => S(T, v.value, "first"),
                            disabled: P,
                            "aria-label": r(e.firstAriaLabel),
                            "aria-disabled": P
                        } : void 0,
                        prev: {
                            icon: i.value ? e.nextIcon : e.prevIcon,
                            onClick: T => S(T, l.value - 1, "prev"),
                            disabled: P,
                            "aria-label": r(e.previousAriaLabel),
                            "aria-disabled": P
                        },
                        next: {
                            icon: i.value ? e.prevIcon : e.nextIcon,
                            onClick: T => S(T, l.value + 1, "next"),
                            disabled: x,
                            "aria-label": r(e.nextAriaLabel),
                            "aria-disabled": x
                        },
                        last: e.showFirstLastPage ? {
                            icon: i.value ? e.firstIcon : e.lastIcon,
                            onClick: T => S(T, v.value + f.value - 1, "last"),
                            disabled: x,
                            "aria-label": r(e.lastAriaLabel),
                            "aria-disabled": x
                        } : void 0
                    }
                });

            function k() {
                var x;
                const P = l.value - v.value;
                (x = b.value[P]) == null || x.$el.focus()
            }

            function E(P) {
                P.key === Ad.left && !e.disabled && l.value > +e.start ? (l.value = l.value - 1, Re(k)) : P.key === Ad.right && !e.disabled && l.value < v.value + f.value - 1 && (l.value = l.value + 1, Re(k))
            }
            return ne(() => m(e.tag, {
                ref: d,
                class: ["v-pagination", s.value, e.class],
                style: e.style,
                role: "navigation",
                "aria-label": r(e.ariaLabel),
                onKeydown: E,
                "data-test": "v-pagination-root"
            }, {
                default: () => [m("ul", {
                    class: "v-pagination__list"
                }, [e.showFirstLastPage && m("li", {
                    key: "first",
                    class: "v-pagination__first",
                    "data-test": "v-pagination-first"
                }, [n.first ? n.first(w.value.first) : m(Le, te({
                    _as: "VPaginationBtn"
                }, w.value.first), null)]), m("li", {
                    key: "prev",
                    class: "v-pagination__prev",
                    "data-test": "v-pagination-prev"
                }, [n.prev ? n.prev(w.value.prev) : m(Le, te({
                    _as: "VPaginationBtn"
                }, w.value.prev), null)]), _.value.map((P, x) => m("li", {
                    key: P.key,
                    class: ["v-pagination__item", {
                        "v-pagination__item--is-active": P.isActive
                    }],
                    "data-test": "v-pagination-item"
                }, [n.item ? n.item(P) : m(Le, te({
                    _as: "VPaginationBtn"
                }, P.props), {
                    default: () => [P.page]
                })])), m("li", {
                    key: "next",
                    class: "v-pagination__next",
                    "data-test": "v-pagination-next"
                }, [n.next ? n.next(w.value.next) : m(Le, te({
                    _as: "VPaginationBtn"
                }, w.value.next), null)]), e.showFirstLastPage && m("li", {
                    key: "last",
                    class: "v-pagination__last",
                    "data-test": "v-pagination-last"
                }, [n.last ? n.last(w.value.last) : m(Le, te({
                    _as: "VPaginationBtn"
                }, w.value.last), null)])])]
            })), {}
        }
    }),
    gm = W({
        prevIcon: {
            type: Pe,
            default: "$prev"
        },
        nextIcon: {
            type: Pe,
            default: "$next"
        },
        firstIcon: {
            type: Pe,
            default: "$first"
        },
        lastIcon: {
            type: Pe,
            default: "$last"
        },
        itemsPerPageText: {
            type: String,
            default: "$vuetify.dataFooter.itemsPerPageText"
        },
        pageText: {
            type: String,
            default: "$vuetify.dataFooter.pageText"
        },
        firstPageLabel: {
            type: String,
            default: "$vuetify.dataFooter.firstPage"
        },
        prevPageLabel: {
            type: String,
            default: "$vuetify.dataFooter.prevPage"
        },
        nextPageLabel: {
            type: String,
            default: "$vuetify.dataFooter.nextPage"
        },
        lastPageLabel: {
            type: String,
            default: "$vuetify.dataFooter.lastPage"
        },
        itemsPerPageOptions: {
            type: Array,
            default: () => [{
                value: 10,
                title: "10"
            }, {
                value: 25,
                title: "25"
            }, {
                value: 50,
                title: "50"
            }, {
                value: 100,
                title: "100"
            }, {
                value: -1,
                title: "$vuetify.dataFooter.itemsPerPageAll"
            }]
        },
        showCurrentPage: Boolean
    }, "VDataTableFooter"),
    qo = Z()({
        name: "VDataTableFooter",
        props: gm(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                t: a
            } = Qe(), {
                page: l,
                pageCount: r,
                startIndex: o,
                stopIndex: i,
                itemsLength: s,
                itemsPerPage: u,
                setItemsPerPage: c
            } = l2(), d = C(() => e.itemsPerPageOptions.map(f => typeof f == "number" ? {
                value: f,
                title: f === -1 ? a("$vuetify.dataFooter.itemsPerPageAll") : String(f)
            } : { ...f,
                title: isNaN(Number(f.title)) ? a(f.title) : f.title
            }));
            return ne(() => {
                var v;
                const f = af.filterProps(e);
                return m("div", {
                    class: "v-data-table-footer"
                }, [(v = n.prepend) == null ? void 0 : v.call(n), m("div", {
                    class: "v-data-table-footer__items-per-page"
                }, [m("span", null, [a(e.itemsPerPageText)]), m(im, {
                    items: d.value,
                    modelValue: u.value,
                    "onUpdate:modelValue": g => c(Number(g)),
                    density: "compact",
                    variant: "outlined",
                    "hide-details": !0
                }, null)]), m("div", {
                    class: "v-data-table-footer__info"
                }, [m("div", null, [a(e.pageText, s.value ? o.value + 1 : 0, i.value, s.value)])]), m("div", {
                    class: "v-data-table-footer__pagination"
                }, [m(af, te({
                    modelValue: l.value,
                    "onUpdate:modelValue": g => l.value = g,
                    density: "comfortable",
                    "first-aria-label": e.firstPageLabel,
                    "last-aria-label": e.lastPageLabel,
                    length: r.value,
                    "next-aria-label": e.nextPageLabel,
                    "previous-aria-label": e.prevPageLabel,
                    rounded: !0,
                    "show-first-last-page": !0,
                    "total-visible": e.showCurrentPage ? 1 : 0,
                    variant: "plain"
                }, f), null)])])
            }), {}
        }
    }),
    Ns = vM({
        align: {
            type: String,
            default: "start"
        },
        fixed: Boolean,
        fixedOffset: [Number, String],
        height: [Number, String],
        lastFixed: Boolean,
        noPadding: Boolean,
        tag: String,
        width: [Number, String],
        maxWidth: [Number, String],
        nowrap: Boolean
    }, (e, t) => {
        let {
            slots: n
        } = t;
        const a = e.tag ? ? "td";
        return m(a, {
            class: ["v-data-table__td", {
                "v-data-table-column--fixed": e.fixed,
                "v-data-table-column--last-fixed": e.lastFixed,
                "v-data-table-column--no-padding": e.noPadding,
                "v-data-table-column--nowrap": e.nowrap
            }, `v-data-table-column--align-${e.align}`],
            style: {
                height: ge(e.height),
                width: ge(e.width),
                maxWidth: ge(e.maxWidth),
                left: ge(e.fixedOffset || null)
            }
        }, {
            default: () => {
                var l;
                return [(l = n.default) == null ? void 0 : l.call(n)]
            }
        })
    }),
    h2 = W({
        headers: Array
    }, "DataTable-header"),
    Sk = Symbol.for("vuetify:data-table-headers"),
    wk = {
        title: "",
        sortable: !1
    },
    g2 = { ...wk,
        width: 48
    };

function y2() {
    const t = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).map(n => ({
        element: n,
        priority: 0
    }));
    return {
        enqueue: (n, a) => {
            let l = !1;
            for (let r = 0; r < t.length; r++)
                if (t[r].priority > a) {
                    t.splice(r, 0, {
                        element: n,
                        priority: a
                    }), l = !0;
                    break
                }
            l || t.push({
                element: n,
                priority: a
            })
        },
        size: () => t.length,
        count: () => {
            let n = 0;
            if (!t.length) return 0;
            const a = Math.floor(t[0].priority);
            for (let l = 0; l < t.length; l++) Math.floor(t[l].priority) === a && (n += 1);
            return n
        },
        dequeue: () => t.shift()
    }
}

function lf(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    if (!e.children) t.push(e);
    else
        for (const n of e.children) lf(n, t);
    return t
}

function kk(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Set;
    for (const n of e) n.key && t.add(n.key), n.children && kk(n.children, t);
    return t
}

function b2(e) {
    if (e.key) {
        if (e.key === "data-table-group") return wk;
        if (["data-table-expand", "data-table-select"].includes(e.key)) return g2
    }
}

function ym(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return e.children ? Math.max(t, ...e.children.map(n => ym(n, t + 1))) : t
}

function p2(e) {
    let t = !1;

    function n(r) {
        let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
        if (r)
            if (o && (r.fixed = !0), r.fixed)
                if (r.children)
                    for (let i = r.children.length - 1; i >= 0; i--) n(r.children[i], !0);
                else t ? isNaN(+r.width) && (`${r.key}`, void 0) : r.lastFixed = !0, t = !0;
        else if (r.children)
            for (let i = r.children.length - 1; i >= 0; i--) n(r.children[i]);
        else t = !1
    }
    for (let r = e.length - 1; r >= 0; r--) n(e[r]);

    function a(r) {
        let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        if (!r) return o;
        if (r.children) {
            r.fixedOffset = o;
            for (const i of r.children) o = a(i, o)
        } else r.fixed && (r.fixedOffset = o, o += parseFloat(r.width || "0") || 0);
        return o
    }
    let l = 0;
    for (const r of e) l = a(r, l)
}

function _2(e, t) {
    const n = [];
    let a = 0;
    const l = y2(e);
    for (; l.size() > 0;) {
        let o = l.count();
        const i = [];
        let s = 1;
        for (; o > 0;) {
            const {
                element: u,
                priority: c
            } = l.dequeue(), d = t - a - ym(u);
            if (i.push({ ...u,
                    rowspan: d ? ? 1,
                    colspan: u.children ? lf(u).length : 1
                }), u.children)
                for (const f of u.children) {
                    const v = c % 1 + s / Math.pow(10, a + 2);
                    l.enqueue(f, a + d + v)
                }
            s += 1, o -= 1
        }
        a += 1, n.push(i)
    }
    return {
        columns: e.map(o => lf(o)).flat(),
        headers: n
    }
}

function Ck(e) {
    const t = [];
    for (const n of e) {
        const a = { ...b2(n),
                ...n
            },
            l = a.key ? ? (typeof a.value == "string" ? a.value : null),
            r = a.value ? ? l ? ? null,
            o = { ...a,
                key: l,
                value: r,
                sortable: a.sortable ? ? (a.key != null || !!a.sort),
                children: a.children ? Ck(a.children) : void 0
            };
        t.push(o)
    }
    return t
}

function bm(e, t) {
    const n = Q([]),
        a = Q([]),
        l = Q({}),
        r = Q({}),
        o = Q({});
    st(() => {
        var h, y, S;
        const u = (e.headers || Object.keys(e.items[0] ? ? {}).map(b => ({
                key: b,
                title: na(b)
            }))).slice(),
            c = kk(u);
        (h = t == null ? void 0 : t.groupBy) != null && h.value.length && !c.has("data-table-group") && u.unshift({
            key: "data-table-group",
            title: "Group"
        }), (y = t == null ? void 0 : t.showSelect) != null && y.value && !c.has("data-table-select") && u.unshift({
            key: "data-table-select"
        }), (S = t == null ? void 0 : t.showExpand) != null && S.value && !c.has("data-table-expand") && u.push({
            key: "data-table-expand"
        });
        const d = Ck(u);
        p2(d);
        const f = Math.max(...d.map(b => ym(b))) + 1,
            v = _2(d, f);
        n.value = v.headers, a.value = v.columns;
        const g = v.headers.flat(1);
        for (const b of g) b.key && (b.sortable && (b.sort && (l.value[b.key] = b.sort), b.sortRaw && (r.value[b.key] = b.sortRaw)), b.filter && (o.value[b.key] = b.filter))
    });
    const i = {
        headers: n,
        columns: a,
        sortFunctions: l,
        sortRawFunctions: r,
        filterFunctions: o
    };
    return He(Sk, i), i
}

function qu() {
    const e = Te(Sk);
    if (!e) throw new Error("Missing headers!");
    return e
}
const xk = W({
        color: String,
        sticky: Boolean,
        disableSort: Boolean,
        multiSort: Boolean,
        sortAscIcon: {
            type: Pe,
            default: "$sortAsc"
        },
        sortDescIcon: {
            type: Pe,
            default: "$sortDesc"
        },
        headerProps: {
            type: Object
        },
        ...Ul(),
        ...Ou()
    }, "VDataTableHeaders"),
    Ml = Z()({
        name: "VDataTableHeaders",
        props: xk(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                t: a
            } = Qe(), {
                toggleSort: l,
                sortBy: r,
                isSorted: o
            } = _k(), {
                someSelected: i,
                allSelected: s,
                selectAll: u,
                showSelectAll: c
            } = Ku(), {
                columns: d,
                headers: f
            } = qu(), {
                loaderClasses: v
            } = vi(e);

            function g(P, x) {
                if (!(!e.sticky && !P.fixed)) return {
                    position: "sticky",
                    left: P.fixed ? ge(P.fixedOffset) : void 0,
                    top: e.sticky ? `calc(var(--v-table-header-height) * ${x})` : void 0
                }
            }

            function h(P) {
                const x = r.value.find(T => T.key === P.key);
                return x ? x.order === "asc" ? e.sortAscIcon : e.sortDescIcon : e.sortAscIcon
            }
            const {
                backgroundColorClasses: y,
                backgroundColorStyles: S
            } = Ke(e, "color"), {
                displayClasses: b,
                mobile: p
            } = On(e), _ = C(() => ({
                headers: f.value,
                columns: d.value,
                toggleSort: l,
                isSorted: o,
                sortBy: r.value,
                someSelected: i.value,
                allSelected: s.value,
                selectAll: u,
                getSortIcon: h
            })), w = C(() => ["v-data-table__th", {
                "v-data-table__th--sticky": e.sticky
            }, b.value, v.value]), k = P => {
                let {
                    column: x,
                    x: T,
                    y: V
                } = P;
                const I = x.key === "data-table-select" || x.key === "data-table-expand",
                    R = te(e.headerProps ? ? {}, x.headerProps ? ? {});
                return m(Ns, te({
                    tag: "th",
                    align: x.align,
                    class: [{
                        "v-data-table__th--sortable": x.sortable && !e.disableSort,
                        "v-data-table__th--sorted": o(x),
                        "v-data-table__th--fixed": x.fixed
                    }, ...w.value],
                    style: {
                        width: ge(x.width),
                        minWidth: ge(x.minWidth),
                        maxWidth: ge(x.maxWidth),
                        ...g(x, V)
                    },
                    colspan: x.colspan,
                    rowspan: x.rowspan,
                    onClick: x.sortable ? () => l(x) : void 0,
                    fixed: x.fixed,
                    nowrap: x.nowrap,
                    lastFixed: x.lastFixed,
                    noPadding: I
                }, R), {
                    default: () => {
                        var D;
                        const B = `header.${x.key}`,
                            $ = {
                                column: x,
                                selectAll: u,
                                isSorted: o,
                                toggleSort: l,
                                sortBy: r.value,
                                someSelected: i.value,
                                allSelected: s.value,
                                getSortIcon: h
                            };
                        return n[B] ? n[B]($) : x.key === "data-table-select" ? ((D = n["header.data-table-select"]) == null ? void 0 : D.call(n, $)) ? ? (c.value && m(Qn, {
                            modelValue: s.value,
                            indeterminate: i.value && !s.value,
                            "onUpdate:modelValue": u
                        }, null)) : m("div", {
                            class: "v-data-table-header__content"
                        }, [m("span", null, [x.title]), x.sortable && !e.disableSort && m(Be, {
                            key: "icon",
                            class: "v-data-table-header__sort-icon",
                            icon: h(x)
                        }, null), e.multiSort && o(x) && m("div", {
                            key: "badge",
                            class: ["v-data-table-header__sort-badge", ...y.value],
                            style: S.value
                        }, [r.value.findIndex(z => z.key === x.key) + 1])])
                    }
                })
            }, E = () => {
                const P = te(e.headerProps ? ? {} ? ? {}),
                    x = C(() => d.value.filter(V => (V == null ? void 0 : V.sortable) && !e.disableSort)),
                    T = C(() => {
                        if (d.value.find(I => I.key === "data-table-select") != null) return s.value ? "$checkboxOn" : i.value ? "$checkboxIndeterminate" : "$checkboxOff"
                    });
                return m(Ns, te({
                    tag: "th",
                    class: [...w.value],
                    colspan: f.value.length + 1
                }, P), {
                    default: () => [m("div", {
                        class: "v-data-table-header__content"
                    }, [m(im, {
                        chips: !0,
                        class: "v-data-table__td-sort-select",
                        clearable: !0,
                        density: "default",
                        items: x.value,
                        label: a("$vuetify.dataTable.sortBy"),
                        multiple: e.multiSort,
                        variant: "underlined",
                        "onClick:clear": () => r.value = [],
                        appendIcon: T.value,
                        "onClick:append": () => u(!s.value)
                    }, { ...n,
                        chip: V => {
                            var I;
                            return m(Zl, {
                                onClick: (I = V.item.raw) != null && I.sortable ? () => l(V.item.raw) : void 0,
                                onMousedown: R => {
                                    R.preventDefault(), R.stopPropagation()
                                }
                            }, {
                                default: () => [V.item.title, m(Be, {
                                    class: ["v-data-table__td-sort-icon", o(V.item.raw) && "v-data-table__td-sort-icon-active"],
                                    icon: h(V.item.raw),
                                    size: "small"
                                }, null)]
                            })
                        }
                    })])]
                })
            };
            ne(() => p.value ? m("tr", null, [m(E, null, null)]) : m(ye, null, [n.headers ? n.headers(_.value) : f.value.map((P, x) => m("tr", null, [P.map((T, V) => m(k, {
                column: T,
                x: V,
                y: x
            }, null))])), e.loading && m("tr", {
                class: "v-data-table-progress"
            }, [m("th", {
                colspan: d.value.length
            }, [m(mi, {
                name: "v-data-table-progress",
                absolute: !0,
                active: !0,
                color: typeof e.loading == "boolean" ? void 0 : e.loading,
                indeterminate: !0
            }, {
                default: n.loader
            })])])]))
        }
    }),
    S2 = W({
        item: {
            type: Object,
            required: !0
        }
    }, "VDataTableGroupHeaderRow"),
    w2 = Z()({
        name: "VDataTableGroupHeaderRow",
        props: S2(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                isGroupOpen: a,
                toggleGroup: l,
                extractRows: r
            } = uk(), {
                isSelected: o,
                isSomeSelected: i,
                select: s
            } = Ku(), {
                columns: u
            } = qu(), c = C(() => r([e.item]));
            return () => m("tr", {
                class: "v-data-table-group-header-row",
                style: {
                    "--v-data-table-group-header-row-depth": e.item.depth
                }
            }, [u.value.map(d => {
                var f, v;
                if (d.key === "data-table-group") {
                    const g = a(e.item) ? "$expand" : "$next",
                        h = () => l(e.item);
                    return ((f = n["data-table-group"]) == null ? void 0 : f.call(n, {
                        item: e.item,
                        count: c.value.length,
                        props: {
                            icon: g,
                            onClick: h
                        }
                    })) ? ? m(Ns, {
                        class: "v-data-table-group-header-row__column"
                    }, {
                        default: () => [m(Le, {
                            size: "small",
                            variant: "text",
                            icon: g,
                            onClick: h
                        }, null), m("span", null, [e.item.value]), m("span", null, [hn("("), c.value.length, hn(")")])]
                    })
                }
                if (d.key === "data-table-select") {
                    const g = o(c.value),
                        h = i(c.value) && !g,
                        y = S => s(c.value, S);
                    return ((v = n["data-table-select"]) == null ? void 0 : v.call(n, {
                        props: {
                            modelValue: g,
                            indeterminate: h,
                            "onUpdate:modelValue": y
                        }
                    })) ? ? m("td", null, [m(Qn, {
                        modelValue: g,
                        indeterminate: h,
                        "onUpdate:modelValue": y
                    }, null)])
                }
                return m("td", null, null)
            })])
        }
    }),
    k2 = W({
        index: Number,
        item: Object,
        cellProps: [Object, Function],
        onClick: It(),
        onContextmenu: It(),
        onDblclick: It(),
        ...Ul()
    }, "VDataTableRow"),
    pm = Z()({
        name: "VDataTableRow",
        props: k2(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                displayClasses: a,
                mobile: l
            } = On(e, "v-data-table__tr"), {
                isSelected: r,
                toggleSelect: o,
                someSelected: i,
                allSelected: s,
                selectAll: u
            } = Ku(), {
                isExpanded: c,
                toggleExpand: d
            } = ik(), {
                toggleSort: f,
                sortBy: v,
                isSorted: g
            } = _k(), {
                columns: h
            } = qu();
            ne(() => m("tr", {
                class: ["v-data-table__tr", {
                    "v-data-table__tr--clickable": !!(e.onClick || e.onContextmenu || e.onDblclick)
                }, a.value],
                onClick: e.onClick,
                onContextmenu: e.onContextmenu,
                onDblclick: e.onDblclick
            }, [e.item && h.value.map((y, S) => {
                const b = e.item,
                    p = `item.${y.key}`,
                    _ = `header.${y.key}`,
                    w = {
                        index: e.index,
                        item: b.raw,
                        internalItem: b,
                        value: Ll(b.columns, y.key),
                        column: y,
                        isSelected: r,
                        toggleSelect: o,
                        isExpanded: c,
                        toggleExpand: d
                    },
                    k = {
                        column: y,
                        selectAll: u,
                        isSorted: g,
                        toggleSort: f,
                        sortBy: v.value,
                        someSelected: i.value,
                        allSelected: s.value,
                        getSortIcon: () => ""
                    },
                    E = typeof e.cellProps == "function" ? e.cellProps({
                        index: w.index,
                        item: w.item,
                        internalItem: w.internalItem,
                        value: w.value,
                        column: y
                    }) : e.cellProps,
                    P = typeof y.cellProps == "function" ? y.cellProps({
                        index: w.index,
                        item: w.item,
                        internalItem: w.internalItem,
                        value: w.value
                    }) : y.cellProps;
                return m(Ns, te({
                    align: y.align,
                    class: {
                        "v-data-table__td--expanded-row": y.key === "data-table-expand", "v-data-table__td--select-row": y.key === "data-table-select"
                    },
                    fixed: y.fixed,
                    fixedOffset: y.fixedOffset,
                    lastFixed: y.lastFixed,
                    maxWidth: l.value ? void 0 : y.maxWidth,
                    noPadding: y.key === "data-table-select" || y.key === "data-table-expand",
                    nowrap: y.nowrap,
                    width: l.value ? void 0 : y.width
                }, E, P), {
                    default: () => {
                        var T, V, I, R, B;
                        if (n[p] && !l.value) return (T = n[p]) == null ? void 0 : T.call(n, w);
                        if (y.key === "data-table-select") return ((V = n["item.data-table-select"]) == null ? void 0 : V.call(n, w)) ? ? m(Qn, {
                            disabled: !b.selectable,
                            modelValue: r([b]),
                            onClick: ms(() => o(b), ["stop"])
                        }, null);
                        if (y.key === "data-table-expand") return ((I = n["item.data-table-expand"]) == null ? void 0 : I.call(n, w)) ? ? m(Le, {
                            icon: c(b) ? "$collapse" : "$expand",
                            size: "small",
                            variant: "text",
                            onClick: ms(() => d(b), ["stop"])
                        }, null);
                        const x = Mb(w.value);
                        return l.value ? m(ye, null, [m("div", {
                            class: "v-data-table__td-title"
                        }, [((R = n[_]) == null ? void 0 : R.call(n, k)) ? ? y.title]), m("div", {
                            class: "v-data-table__td-value"
                        }, [((B = n[p]) == null ? void 0 : B.call(n, w)) ? ? x])]) : x
                    }
                })
            })]))
        }
    }),
    Pk = W({
        loading: [Boolean, String],
        loadingText: {
            type: String,
            default: "$vuetify.dataIterator.loadingText"
        },
        hideNoData: Boolean,
        items: {
            type: Array,
            default: () => []
        },
        noDataText: {
            type: String,
            default: "$vuetify.noDataText"
        },
        rowProps: [Object, Function],
        cellProps: [Object, Function],
        ...Ul()
    }, "VDataTableRows"),
    Nl = Z()({
        name: "VDataTableRows",
        inheritAttrs: !1,
        props: Pk(),
        setup(e, t) {
            let {
                attrs: n,
                slots: a
            } = t;
            const {
                columns: l
            } = qu(), {
                expandOnClick: r,
                toggleExpand: o,
                isExpanded: i
            } = ik(), {
                isSelected: s,
                toggleSelect: u
            } = Ku(), {
                toggleGroup: c,
                isGroupOpen: d
            } = uk(), {
                t: f
            } = Qe(), {
                mobile: v
            } = On(e);
            return ne(() => {
                var g, h;
                return e.loading && (!e.items.length || a.loading) ? m("tr", {
                    class: "v-data-table-rows-loading",
                    key: "loading"
                }, [m("td", {
                    colspan: l.value.length
                }, [((g = a.loading) == null ? void 0 : g.call(a)) ? ? f(e.loadingText)])]) : !e.loading && !e.items.length && !e.hideNoData ? m("tr", {
                    class: "v-data-table-rows-no-data",
                    key: "no-data"
                }, [m("td", {
                    colspan: l.value.length
                }, [((h = a["no-data"]) == null ? void 0 : h.call(a)) ? ? f(e.noDataText)])]) : m(ye, null, [e.items.map((y, S) => {
                    var _;
                    if (y.type === "group") {
                        const w = {
                            index: S,
                            item: y,
                            columns: l.value,
                            isExpanded: i,
                            toggleExpand: o,
                            isSelected: s,
                            toggleSelect: u,
                            toggleGroup: c,
                            isGroupOpen: d
                        };
                        return a["group-header"] ? a["group-header"](w) : m(w2, te({
                            key: `group-header_${y.id}`,
                            item: y
                        }, wy(n, ":group-header", () => w)), a)
                    }
                    const b = {
                            index: S,
                            item: y.raw,
                            internalItem: y,
                            columns: l.value,
                            isExpanded: i,
                            toggleExpand: o,
                            isSelected: s,
                            toggleSelect: u
                        },
                        p = { ...b,
                            props: te({
                                key: `item_${y.key??y.index}`,
                                onClick: r.value ? () => {
                                    o(y)
                                } : void 0,
                                index: S,
                                item: y,
                                cellProps: e.cellProps,
                                mobile: v.value
                            }, wy(n, ":row", () => b), typeof e.rowProps == "function" ? e.rowProps({
                                item: b.item,
                                index: b.index,
                                internalItem: b.internalItem
                            }) : e.rowProps)
                        };
                    return m(ye, {
                        key: p.props.key
                    }, [a.item ? a.item(p) : m(pm, p.props, a), i(y) && ((_ = a["expanded-row"]) == null ? void 0 : _.call(a, b))])
                })])
            }), {}
        }
    }),
    Ek = W({
        fixedHeader: Boolean,
        fixedFooter: Boolean,
        height: [Number, String],
        hover: Boolean,
        ...Se(),
        ...Vt(),
        ...Ae(),
        ...Ne()
    }, "VTable"),
    $l = Z()({
        name: "VTable",
        props: Ek(),
        setup(e, t) {
            let {
                slots: n,
                emit: a
            } = t;
            const {
                themeClasses: l
            } = je(e), {
                densityClasses: r
            } = zt(e);
            return ne(() => m(e.tag, {
                class: ["v-table", {
                    "v-table--fixed-height": !!e.height,
                    "v-table--fixed-header": e.fixedHeader,
                    "v-table--fixed-footer": e.fixedFooter,
                    "v-table--has-top": !!n.top,
                    "v-table--has-bottom": !!n.bottom,
                    "v-table--hover": e.hover
                }, l.value, r.value, e.class],
                style: e.style
            }, {
                default: () => {
                    var o, i, s;
                    return [(o = n.top) == null ? void 0 : o.call(n), n.default ? m("div", {
                        class: "v-table__wrapper",
                        style: {
                            height: ge(e.height)
                        }
                    }, [m("table", null, [n.default()])]) : (i = n.wrapper) == null ? void 0 : i.call(n), (s = n.bottom) == null ? void 0 : s.call(n)]
                }
            })), {}
        }
    }),
    C2 = W({
        items: {
            type: Array,
            default: () => []
        },
        itemValue: {
            type: [String, Array, Function],
            default: "id"
        },
        itemSelectable: {
            type: [String, Array, Function],
            default: null
        },
        rowProps: [Object, Function],
        cellProps: [Object, Function],
        returnObject: Boolean
    }, "DataTable-items");

function x2(e, t, n, a) {
    const l = e.returnObject ? t : vt(t, e.itemValue),
        r = vt(t, e.itemSelectable, !0),
        o = a.reduce((i, s) => (s.key != null && (i[s.key] = vt(t, s.value)), i), {});
    return {
        type: "item",
        key: e.returnObject ? vt(t, e.itemValue) : l,
        index: n,
        value: l,
        selectable: r,
        columns: o,
        raw: t
    }
}

function P2(e, t, n) {
    return t.map((a, l) => x2(e, a, l, n))
}

function _m(e, t) {
    return {
        items: C(() => P2(e, e.items, t.value))
    }
}
const Sm = W({ ...Pk(),
        hideDefaultBody: Boolean,
        hideDefaultFooter: Boolean,
        hideDefaultHeader: Boolean,
        width: [String, Number],
        search: String,
        ...rk(),
        ...cm(),
        ...h2(),
        ...C2(),
        ...gk(),
        ...bk(),
        ...xk(),
        ...Ek()
    }, "DataTable"),
    E2 = W({ ...fm(),
        ...Sm(),
        ...Zr(),
        ...gm()
    }, "VDataTable"),
    I2 = Z()({
        name: "VDataTable",
        props: E2(),
        emits: {
            "update:modelValue": e => !0,
            "update:page": e => !0,
            "update:itemsPerPage": e => !0,
            "update:sortBy": e => !0,
            "update:options": e => !0,
            "update:groupBy": e => !0,
            "update:expanded": e => !0,
            "update:currentItems": e => !0
        },
        setup(e, t) {
            let {
                attrs: n,
                slots: a
            } = t;
            const {
                groupBy: l
            } = dm(e), {
                sortBy: r,
                multiSort: o,
                mustSort: i
            } = Gu(e), {
                page: s,
                itemsPerPage: u
            } = vm(e), {
                disableSort: c
            } = ta(e), {
                columns: d,
                headers: f,
                sortFunctions: v,
                sortRawFunctions: g,
                filterFunctions: h
            } = bm(e, {
                groupBy: l,
                showSelect: Y(e, "showSelect"),
                showExpand: Y(e, "showExpand")
            }), {
                items: y
            } = _m(e, d), S = Y(e, "search"), {
                filteredItems: b
            } = Qr(e, y, S, {
                transform: G => G.columns,
                customKeyFilter: h
            }), {
                toggleSort: p
            } = Yu({
                sortBy: r,
                multiSort: o,
                mustSort: i,
                page: s
            }), {
                sortByWithGroups: _,
                opened: w,
                extractRows: k,
                isGroupOpen: E,
                toggleGroup: P
            } = ju({
                groupBy: l,
                sortBy: r,
                disableSort: c
            }), {
                sortedItems: x
            } = hm(e, b, _, {
                transform: G => ({ ...G.raw,
                    ...G.columns
                }),
                sortFunctions: v,
                sortRawFunctions: g
            }), {
                flatItems: T
            } = Uu(x, l, w), V = C(() => T.value.length), {
                startIndex: I,
                stopIndex: R,
                pageCount: B,
                setItemsPerPage: $
            } = mm({
                page: s,
                itemsPerPage: u,
                itemsLength: V
            }), {
                paginatedItems: D
            } = vk({
                items: T,
                startIndex: I,
                stopIndex: R,
                itemsPerPage: u
            }), z = C(() => k(D.value)), {
                isSelected: N,
                select: H,
                selectAll: F,
                toggleSelect: j,
                someSelected: ae,
                allSelected: he
            } = zu(e, {
                allItems: y,
                currentPage: z
            }), {
                isExpanded: ve,
                toggleExpand: we
            } = Hu(e);
            Wu({
                page: s,
                itemsPerPage: u,
                sortBy: r,
                groupBy: l,
                search: S
            }), lt({
                VDataTableRows: {
                    hideNoData: Y(e, "hideNoData"),
                    noDataText: Y(e, "noDataText"),
                    loading: Y(e, "loading"),
                    loadingText: Y(e, "loadingText")
                }
            });
            const ee = C(() => ({
                page: s.value,
                itemsPerPage: u.value,
                sortBy: r.value,
                pageCount: B.value,
                toggleSort: p,
                setItemsPerPage: $,
                someSelected: ae.value,
                allSelected: he.value,
                isSelected: N,
                select: H,
                selectAll: F,
                toggleSelect: j,
                isExpanded: ve,
                toggleExpand: we,
                isGroupOpen: E,
                toggleGroup: P,
                items: z.value.map(G => G.raw),
                internalItems: z.value,
                groupedItems: D.value,
                columns: d.value,
                headers: f.value
            }));
            return ne(() => {
                const G = qo.filterProps(e),
                    le = Ml.filterProps(e),
                    se = Nl.filterProps(e),
                    ce = $l.filterProps(e);
                return m($l, te({
                    class: ["v-data-table", {
                        "v-data-table--show-select": e.showSelect,
                        "v-data-table--loading": e.loading
                    }, e.class],
                    style: e.style
                }, ce), {
                    top: () => {
                        var re;
                        return (re = a.top) == null ? void 0 : re.call(a, ee.value)
                    },
                    default: () => {
                        var re, pe, A, O, K, J;
                        return a.default ? a.default(ee.value) : m(ye, null, [(re = a.colgroup) == null ? void 0 : re.call(a, ee.value), !e.hideDefaultHeader && m("thead", {
                            key: "thead"
                        }, [m(Ml, le, a)]), (pe = a.thead) == null ? void 0 : pe.call(a, ee.value), !e.hideDefaultBody && m("tbody", null, [(A = a["body.prepend"]) == null ? void 0 : A.call(a, ee.value), a.body ? a.body(ee.value) : m(Nl, te(n, se, {
                            items: D.value
                        }), a), (O = a["body.append"]) == null ? void 0 : O.call(a, ee.value)]), (K = a.tbody) == null ? void 0 : K.call(a, ee.value), (J = a.tfoot) == null ? void 0 : J.call(a, ee.value)])
                    },
                    bottom: () => a.bottom ? a.bottom(ee.value) : !e.hideDefaultFooter && m(ye, null, [m(ya, null, null), m(qo, G, {
                        prepend: a["footer.prepend"]
                    })])
                })
            }), {}
        }
    }),
    T2 = W({ ...Sm(),
        ...cm(),
        ...$w(),
        ...Zr()
    }, "VDataTableVirtual"),
    V2 = Z()({
        name: "VDataTableVirtual",
        props: T2(),
        emits: {
            "update:modelValue": e => !0,
            "update:sortBy": e => !0,
            "update:options": e => !0,
            "update:groupBy": e => !0,
            "update:expanded": e => !0
        },
        setup(e, t) {
            let {
                attrs: n,
                slots: a
            } = t;
            const {
                groupBy: l
            } = dm(e), {
                sortBy: r,
                multiSort: o,
                mustSort: i
            } = Gu(e), {
                disableSort: s
            } = ta(e), {
                columns: u,
                headers: c,
                filterFunctions: d,
                sortFunctions: f,
                sortRawFunctions: v
            } = bm(e, {
                groupBy: l,
                showSelect: Y(e, "showSelect"),
                showExpand: Y(e, "showExpand")
            }), {
                items: g
            } = _m(e, u), h = Y(e, "search"), {
                filteredItems: y
            } = Qr(e, g, h, {
                transform: le => le.columns,
                customKeyFilter: d
            }), {
                toggleSort: S
            } = Yu({
                sortBy: r,
                multiSort: o,
                mustSort: i
            }), {
                sortByWithGroups: b,
                opened: p,
                extractRows: _,
                isGroupOpen: w,
                toggleGroup: k
            } = ju({
                groupBy: l,
                sortBy: r,
                disableSort: s
            }), {
                sortedItems: E
            } = hm(e, y, b, {
                transform: le => ({ ...le.raw,
                    ...le.columns
                }),
                sortFunctions: f,
                sortRawFunctions: v
            }), {
                flatItems: P
            } = Uu(E, l, p), x = C(() => _(P.value)), {
                isSelected: T,
                select: V,
                selectAll: I,
                toggleSelect: R,
                someSelected: B,
                allSelected: $
            } = zu(e, {
                allItems: x,
                currentPage: x
            }), {
                isExpanded: D,
                toggleExpand: z
            } = Hu(e), {
                containerRef: N,
                markerRef: H,
                paddingTop: F,
                paddingBottom: j,
                computedItems: ae,
                handleItemResize: he,
                handleScroll: ve,
                handleScrollend: we
            } = Bw(e, P), ee = C(() => ae.value.map(le => le.raw));
            Wu({
                sortBy: r,
                page: fe(1),
                itemsPerPage: fe(-1),
                groupBy: l,
                search: h
            }), lt({
                VDataTableRows: {
                    hideNoData: Y(e, "hideNoData"),
                    noDataText: Y(e, "noDataText"),
                    loading: Y(e, "loading"),
                    loadingText: Y(e, "loadingText")
                }
            });
            const G = C(() => ({
                sortBy: r.value,
                toggleSort: S,
                someSelected: B.value,
                allSelected: $.value,
                isSelected: T,
                select: V,
                selectAll: I,
                toggleSelect: R,
                isExpanded: D,
                toggleExpand: z,
                isGroupOpen: w,
                toggleGroup: k,
                items: x.value.map(le => le.raw),
                internalItems: x.value,
                groupedItems: P.value,
                columns: u.value,
                headers: c.value
            }));
            ne(() => {
                const le = Ml.filterProps(e),
                    se = Nl.filterProps(e),
                    ce = $l.filterProps(e);
                return m($l, te({
                    class: ["v-data-table", {
                        "v-data-table--loading": e.loading
                    }, e.class],
                    style: e.style
                }, ce), {
                    top: () => {
                        var re;
                        return (re = a.top) == null ? void 0 : re.call(a, G.value)
                    },
                    wrapper: () => {
                        var re, pe, A;
                        return m("div", {
                            ref: N,
                            onScrollPassive: ve,
                            onScrollend: we,
                            class: "v-table__wrapper",
                            style: {
                                height: ge(e.height)
                            }
                        }, [m("table", null, [(re = a.colgroup) == null ? void 0 : re.call(a, G.value), !e.hideDefaultHeader && m("thead", {
                            key: "thead"
                        }, [m(Ml, te(le, {
                            sticky: e.fixedHeader
                        }), a)]), !e.hideDefaultBody && m("tbody", null, [m("tr", {
                            ref: H,
                            style: {
                                height: ge(F.value),
                                border: 0
                            }
                        }, [m("td", {
                            colspan: u.value.length,
                            style: {
                                height: 0,
                                border: 0
                            }
                        }, null)]), (pe = a["body.prepend"]) == null ? void 0 : pe.call(a, G.value), m(Nl, te(n, se, {
                            items: ee.value
                        }), { ...a,
                            item: O => m(Nw, {
                                key: O.internalItem.index,
                                renderless: !0,
                                "onUpdate:height": K => he(O.internalItem.index, K)
                            }, {
                                default: K => {
                                    var X;
                                    let {
                                        itemRef: J
                                    } = K;
                                    return ((X = a.item) == null ? void 0 : X.call(a, { ...O,
                                        itemRef: J
                                    })) ? ? m(pm, te(O.props, {
                                        ref: J,
                                        key: O.internalItem.index,
                                        index: O.internalItem.index
                                    }), a)
                                }
                            })
                        }), (A = a["body.append"]) == null ? void 0 : A.call(a, G.value), m("tr", {
                            style: {
                                height: ge(j.value),
                                border: 0
                            }
                        }, [m("td", {
                            colspan: u.value.length,
                            style: {
                                height: 0,
                                border: 0
                            }
                        }, null)])])])])
                    },
                    bottom: () => {
                        var re;
                        return (re = a.bottom) == null ? void 0 : re.call(a, G.value)
                    }
                })
            })
        }
    }),
    A2 = W({
        itemsLength: {
            type: [Number, String],
            required: !0
        },
        ...fm(),
        ...Sm(),
        ...gm()
    }, "VDataTableServer"),
    L2 = Z()({
        name: "VDataTableServer",
        props: A2(),
        emits: {
            "update:modelValue": e => !0,
            "update:page": e => !0,
            "update:itemsPerPage": e => !0,
            "update:sortBy": e => !0,
            "update:options": e => !0,
            "update:expanded": e => !0,
            "update:groupBy": e => !0
        },
        setup(e, t) {
            let {
                attrs: n,
                slots: a
            } = t;
            const {
                groupBy: l
            } = dm(e), {
                sortBy: r,
                multiSort: o,
                mustSort: i
            } = Gu(e), {
                page: s,
                itemsPerPage: u
            } = vm(e), {
                disableSort: c
            } = ta(e), d = C(() => parseInt(e.itemsLength, 10)), {
                columns: f,
                headers: v
            } = bm(e, {
                groupBy: l,
                showSelect: Y(e, "showSelect"),
                showExpand: Y(e, "showExpand")
            }), {
                items: g
            } = _m(e, f), {
                toggleSort: h
            } = Yu({
                sortBy: r,
                multiSort: o,
                mustSort: i,
                page: s
            }), {
                opened: y,
                isGroupOpen: S,
                toggleGroup: b,
                extractRows: p
            } = ju({
                groupBy: l,
                sortBy: r,
                disableSort: c
            }), {
                pageCount: _,
                setItemsPerPage: w
            } = mm({
                page: s,
                itemsPerPage: u,
                itemsLength: d
            }), {
                flatItems: k
            } = Uu(g, l, y), {
                isSelected: E,
                select: P,
                selectAll: x,
                toggleSelect: T,
                someSelected: V,
                allSelected: I
            } = zu(e, {
                allItems: g,
                currentPage: g
            }), {
                isExpanded: R,
                toggleExpand: B
            } = Hu(e), $ = C(() => p(g.value));
            Wu({
                page: s,
                itemsPerPage: u,
                sortBy: r,
                groupBy: l,
                search: Y(e, "search")
            }), He("v-data-table", {
                toggleSort: h,
                sortBy: r
            }), lt({
                VDataTableRows: {
                    hideNoData: Y(e, "hideNoData"),
                    noDataText: Y(e, "noDataText"),
                    loading: Y(e, "loading"),
                    loadingText: Y(e, "loadingText")
                }
            });
            const D = C(() => ({
                page: s.value,
                itemsPerPage: u.value,
                sortBy: r.value,
                pageCount: _.value,
                toggleSort: h,
                setItemsPerPage: w,
                someSelected: V.value,
                allSelected: I.value,
                isSelected: E,
                select: P,
                selectAll: x,
                toggleSelect: T,
                isExpanded: R,
                toggleExpand: B,
                isGroupOpen: S,
                toggleGroup: b,
                items: $.value.map(z => z.raw),
                internalItems: $.value,
                groupedItems: k.value,
                columns: f.value,
                headers: v.value
            }));
            ne(() => {
                const z = qo.filterProps(e),
                    N = Ml.filterProps(e),
                    H = Nl.filterProps(e),
                    F = $l.filterProps(e);
                return m($l, te({
                    class: ["v-data-table", {
                        "v-data-table--loading": e.loading
                    }, e.class],
                    style: e.style
                }, F), {
                    top: () => {
                        var j;
                        return (j = a.top) == null ? void 0 : j.call(a, D.value)
                    },
                    default: () => {
                        var j, ae, he, ve, we, ee;
                        return a.default ? a.default(D.value) : m(ye, null, [(j = a.colgroup) == null ? void 0 : j.call(a, D.value), !e.hideDefaultHeader && m("thead", {
                            key: "thead",
                            class: "v-data-table__thead",
                            role: "rowgroup"
                        }, [m(Ml, te(N, {
                            sticky: e.fixedHeader
                        }), a)]), (ae = a.thead) == null ? void 0 : ae.call(a, D.value), !e.hideDefaultBody && m("tbody", {
                            class: "v-data-table__tbody",
                            role: "rowgroup"
                        }, [(he = a["body.prepend"]) == null ? void 0 : he.call(a, D.value), a.body ? a.body(D.value) : m(Nl, te(n, H, {
                            items: k.value
                        }), a), (ve = a["body.append"]) == null ? void 0 : ve.call(a, D.value)]), (we = a.tbody) == null ? void 0 : we.call(a, D.value), (ee = a.tfoot) == null ? void 0 : ee.call(a, D.value)])
                    },
                    bottom: () => a.bottom ? a.bottom(D.value) : !e.hideDefaultFooter && m(ye, null, [m(ya, null, null), m(qo, z, {
                        prepend: a["footer.prepend"]
                    })])
                })
            })
        }
    }),
    O2 = W({
        fluid: {
            type: Boolean,
            default: !1
        },
        ...Se(),
        ...bt(),
        ...Ae()
    }, "VContainer"),
    R2 = Z()({
        name: "VContainer",
        props: O2(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                rtlClasses: a
            } = xt(), {
                dimensionStyles: l
            } = pt(e);
            return ne(() => m(e.tag, {
                class: ["v-container", {
                    "v-container--fluid": e.fluid
                }, a.value, e.class],
                style: [l.value, e.style]
            }, n)), {}
        }
    }),
    Ik = Eu.reduce((e, t) => (e[t] = {
        type: [Boolean, String, Number],
        default: !1
    }, e), {}),
    Tk = Eu.reduce((e, t) => {
        const n = "offset" + na(t);
        return e[n] = {
            type: [String, Number],
            default: null
        }, e
    }, {}),
    Vk = Eu.reduce((e, t) => {
        const n = "order" + na(t);
        return e[n] = {
            type: [String, Number],
            default: null
        }, e
    }, {}),
    Gy = {
        col: Object.keys(Ik),
        offset: Object.keys(Tk),
        order: Object.keys(Vk)
    };

function D2(e, t, n) {
    let a = e;
    if (!(n == null || n === !1)) {
        if (t) {
            const l = t.replace(e, "");
            a += `-${l}`
        }
        return e === "col" && (a = "v-" + a), e === "col" && (n === "" || n === !0) || (a += `-${n}`), a.toLowerCase()
    }
}
const M2 = ["auto", "start", "end", "center", "baseline", "stretch"],
    N2 = W({
        cols: {
            type: [Boolean, String, Number],
            default: !1
        },
        ...Ik,
        offset: {
            type: [String, Number],
            default: null
        },
        ...Tk,
        order: {
            type: [String, Number],
            default: null
        },
        ...Vk,
        alignSelf: {
            type: String,
            default: null,
            validator: e => M2.includes(e)
        },
        ...Se(),
        ...Ae()
    }, "VCol"),
    $2 = Z()({
        name: "VCol",
        props: N2(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = C(() => {
                const l = [];
                let r;
                for (r in Gy) Gy[r].forEach(i => {
                    const s = e[i],
                        u = D2(r, i, s);
                    u && l.push(u)
                });
                const o = l.some(i => i.startsWith("v-col-"));
                return l.push({
                    "v-col": !o || !e.cols,
                    [`v-col-${e.cols}`]: e.cols,
                    [`offset-${e.offset}`]: e.offset,
                    [`order-${e.order}`]: e.order,
                    [`align-self-${e.alignSelf}`]: e.alignSelf
                }), l
            });
            return () => {
                var l;
                return ht(e.tag, {
                    class: [a.value, e.class],
                    style: e.style
                }, (l = n.default) == null ? void 0 : l.call(n))
            }
        }
    }),
    wm = ["start", "end", "center"],
    Ak = ["space-between", "space-around", "space-evenly"];

function km(e, t) {
    return Eu.reduce((n, a) => {
        const l = e + na(a);
        return n[l] = t(), n
    }, {})
}
const B2 = [...wm, "baseline", "stretch"],
    Lk = e => B2.includes(e),
    Ok = km("align", () => ({
        type: String,
        default: null,
        validator: Lk
    })),
    F2 = [...wm, ...Ak],
    Rk = e => F2.includes(e),
    Dk = km("justify", () => ({
        type: String,
        default: null,
        validator: Rk
    })),
    H2 = [...wm, ...Ak, "stretch"],
    Mk = e => H2.includes(e),
    Nk = km("alignContent", () => ({
        type: String,
        default: null,
        validator: Mk
    })),
    Yy = {
        align: Object.keys(Ok),
        justify: Object.keys(Dk),
        alignContent: Object.keys(Nk)
    },
    j2 = {
        align: "align",
        justify: "justify",
        alignContent: "align-content"
    };

function U2(e, t, n) {
    let a = j2[e];
    if (n != null) {
        if (t) {
            const l = t.replace(e, "");
            a += `-${l}`
        }
        return a += `-${n}`, a.toLowerCase()
    }
}
const W2 = W({
        dense: Boolean,
        noGutters: Boolean,
        align: {
            type: String,
            default: null,
            validator: Lk
        },
        ...Ok,
        justify: {
            type: String,
            default: null,
            validator: Rk
        },
        ...Dk,
        alignContent: {
            type: String,
            default: null,
            validator: Mk
        },
        ...Nk,
        ...Se(),
        ...Ae()
    }, "VRow"),
    z2 = Z()({
        name: "VRow",
        props: W2(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = C(() => {
                const l = [];
                let r;
                for (r in Yy) Yy[r].forEach(o => {
                    const i = e[o],
                        s = U2(r, o, i);
                    s && l.push(s)
                });
                return l.push({
                    "v-row--no-gutters": e.noGutters,
                    "v-row--dense": e.dense,
                    [`align-${e.align}`]: e.align,
                    [`justify-${e.justify}`]: e.justify,
                    [`align-content-${e.alignContent}`]: e.alignContent
                }), l
            });
            return () => {
                var l;
                return ht(e.tag, {
                    class: ["v-row", a.value, e.class],
                    style: e.style
                }, (l = n.default) == null ? void 0 : l.call(n))
            }
        }
    }),
    $k = oa("v-spacer", "div", "VSpacer"),
    Bk = W({
        active: {
            type: [String, Array],
            default: void 0
        },
        disabled: {
            type: [Boolean, String, Array],
            default: !1
        },
        nextIcon: {
            type: Pe,
            default: "$next"
        },
        prevIcon: {
            type: Pe,
            default: "$prev"
        },
        modeIcon: {
            type: Pe,
            default: "$subgroup"
        },
        text: String,
        viewMode: {
            type: String,
            default: "month"
        }
    }, "VDatePickerControls"),
    rf = Z()({
        name: "VDatePickerControls",
        props: Bk(),
        emits: {
            "click:year": () => !0,
            "click:month": () => !0,
            "click:prev": () => !0,
            "click:next": () => !0,
            "click:text": () => !0
        },
        setup(e, t) {
            let {
                emit: n
            } = t;
            const a = C(() => Array.isArray(e.disabled) ? e.disabled.includes("text") : !!e.disabled),
                l = C(() => Array.isArray(e.disabled) ? e.disabled.includes("mode") : !!e.disabled),
                r = C(() => Array.isArray(e.disabled) ? e.disabled.includes("prev") : !!e.disabled),
                o = C(() => Array.isArray(e.disabled) ? e.disabled.includes("next") : !!e.disabled);

            function i() {
                n("click:prev")
            }

            function s() {
                n("click:next")
            }

            function u() {
                n("click:year")
            }

            function c() {
                n("click:month")
            }
            return ne(() => m("div", {
                class: ["v-date-picker-controls"]
            }, [m(Le, {
                class: "v-date-picker-controls__month-btn",
                disabled: a.value,
                text: e.text,
                variant: "text",
                rounded: !0,
                onClick: c
            }, null), m(Le, {
                key: "mode-btn",
                class: "v-date-picker-controls__mode-btn",
                disabled: l.value,
                density: "comfortable",
                icon: e.modeIcon,
                variant: "text",
                onClick: u
            }, null), m($k, {
                key: "mode-spacer"
            }, null), m("div", {
                key: "month-buttons",
                class: "v-date-picker-controls__month"
            }, [m(Le, {
                disabled: r.value,
                icon: e.prevIcon,
                variant: "text",
                onClick: i
            }, null), m(Le, {
                disabled: o.value,
                icon: e.nextIcon,
                variant: "text",
                onClick: s
            }, null)])])), {}
        }
    }),
    K2 = W({
        appendIcon: String,
        color: String,
        header: String,
        transition: String,
        onClick: It()
    }, "VDatePickerHeader"),
    of = Z()({
        name: "VDatePickerHeader",
        props: K2(),
        emits: {
            click: () => !0,
            "click:append": () => !0
        },
        setup(e, t) {
            let {
                emit: n,
                slots: a
            } = t;
            const {
                backgroundColorClasses: l,
                backgroundColorStyles: r
            } = Ke(e, "color");

            function o() {
                n("click")
            }

            function i() {
                n("click:append")
            }
            return ne(() => {
                const s = !!(a.default || e.header),
                    u = !!(a.append || e.appendIcon);
                return m("div", {
                    class: ["v-date-picker-header", {
                        "v-date-picker-header--clickable": !!e.onClick
                    }, l.value],
                    style: r.value,
                    onClick: o
                }, [a.prepend && m("div", {
                    key: "prepend",
                    class: "v-date-picker-header__prepend"
                }, [a.prepend()]), s && m(jt, {
                    key: "content",
                    name: e.transition
                }, {
                    default: () => {
                        var c;
                        return [m("div", {
                            key: e.header,
                            class: "v-date-picker-header__content"
                        }, [((c = a.default) == null ? void 0 : c.call(a)) ? ? e.header])]
                    }
                }), u && m("div", {
                    class: "v-date-picker-header__append"
                }, [a.append ? m(Ve, {
                    key: "append-defaults",
                    disabled: !e.appendIcon,
                    defaults: {
                        VBtn: {
                            icon: e.appendIcon,
                            variant: "text"
                        }
                    }
                }, {
                    default: () => {
                        var c;
                        return [(c = a.append) == null ? void 0 : c.call(a)]
                    }
                }) : m(Le, {
                    key: "append-btn",
                    icon: e.appendIcon,
                    variant: "text",
                    onClick: i
                }, null)])])
            }), {}
        }
    }),
    Fk = W({
        allowedDates: [Array, Function],
        disabled: Boolean,
        displayValue: null,
        modelValue: Array,
        month: [Number, String],
        max: null,
        min: null,
        showAdjacentMonths: Boolean,
        year: [Number, String],
        weekdays: {
            type: Array,
            default: () => [0, 1, 2, 3, 4, 5, 6]
        },
        weeksInMonth: {
            type: String,
            default: "dynamic"
        },
        firstDayOfWeek: [Number, String]
    }, "calendar");

function Hk(e) {
    const t = ia(),
        n = Ce(e, "modelValue", [], v => nt(v)),
        a = C(() => e.displayValue ? t.date(e.displayValue) : n.value.length > 0 ? t.date(n.value[0]) : e.min ? t.date(e.min) : Array.isArray(e.allowedDates) ? t.date(e.allowedDates[0]) : t.date()),
        l = Ce(e, "year", void 0, v => {
            const g = v != null ? Number(v) : t.getYear(a.value);
            return t.startOfYear(t.setYear(t.date(), g))
        }, v => t.getYear(v)),
        r = Ce(e, "month", void 0, v => {
            const g = v != null ? Number(v) : t.getMonth(a.value),
                h = t.setYear(t.startOfMonth(t.date()), t.getYear(l.value));
            return t.setMonth(h, g)
        }, v => t.getMonth(v)),
        o = C(() => {
            const v = Number(e.firstDayOfWeek ? ? 0);
            return e.weekdays.map(g => (g + v) % 7)
        }),
        i = C(() => {
            const v = t.getWeekArray(r.value, e.firstDayOfWeek),
                g = v.flat(),
                h = 6 * 7;
            if (e.weeksInMonth === "static" && g.length < h) {
                const y = g[g.length - 1];
                let S = [];
                for (let b = 1; b <= h - g.length; b++) S.push(t.addDays(y, b)), b % 7 === 0 && (v.push(S), S = [])
            }
            return v
        });

    function s(v, g) {
        return v.filter(h => o.value.includes(t.toJsDate(h).getDay())).map((h, y) => {
            const S = t.toISO(h),
                b = !t.isSameMonth(h, r.value),
                p = t.isSameDay(h, t.startOfMonth(r.value)),
                _ = t.isSameDay(h, t.endOfMonth(r.value)),
                w = t.isSameDay(h, r.value);
            return {
                date: h,
                isoDate: S,
                formatted: t.format(h, "keyboardDate"),
                year: t.getYear(h),
                month: t.getMonth(h),
                isDisabled: f(h),
                isWeekStart: y % 7 === 0,
                isWeekEnd: y % 7 === 6,
                isToday: t.isSameDay(h, g),
                isAdjacent: b,
                isHidden: b && !e.showAdjacentMonths,
                isStart: p,
                isSelected: n.value.some(k => t.isSameDay(h, k)),
                isEnd: _,
                isSame: w,
                localized: t.format(h, "dayOfMonth")
            }
        })
    }
    const u = C(() => {
            const v = t.startOfWeek(a.value, e.firstDayOfWeek),
                g = [];
            for (let y = 0; y <= 6; y++) g.push(t.addDays(v, y));
            const h = t.date();
            return s(g, h)
        }),
        c = C(() => {
            const v = i.value.flat(),
                g = t.date();
            return s(v, g)
        }),
        d = C(() => i.value.map(v => v.length ? cN(t, v[0]) : null));

    function f(v) {
        if (e.disabled) return !0;
        const g = t.date(v);
        return e.min && t.isAfter(t.date(e.min), g) || e.max && t.isAfter(g, t.date(e.max)) ? !0 : Array.isArray(e.allowedDates) && e.allowedDates.length > 0 ? !e.allowedDates.some(h => t.isSameDay(t.date(h), g)) : typeof e.allowedDates == "function" ? !e.allowedDates(g) : !1
    }
    return {
        displayValue: a,
        daysInMonth: c,
        daysInWeek: u,
        genDays: s,
        model: n,
        weeksInMonth: i,
        weekDays: o,
        weekNumbers: d
    }
}
const jk = W({
        color: String,
        hideWeekdays: Boolean,
        multiple: [Boolean, Number, String],
        showWeek: Boolean,
        transition: {
            type: String,
            default: "picker-transition"
        },
        reverseTransition: {
            type: String,
            default: "picker-reverse-transition"
        },
        ...Fk()
    }, "VDatePickerMonth"),
    sf = Z()({
        name: "VDatePickerMonth",
        props: jk(),
        emits: {
            "update:modelValue": e => !0,
            "update:month": e => !0,
            "update:year": e => !0
        },
        setup(e, t) {
            let {
                emit: n,
                slots: a
            } = t;
            const l = Q(),
                {
                    daysInMonth: r,
                    model: o,
                    weekNumbers: i
                } = Hk(e),
                s = ia(),
                u = fe(),
                c = fe(),
                d = fe(!1),
                f = C(() => d.value ? e.reverseTransition : e.transition);
            e.multiple === "range" && o.value.length > 0 && (u.value = o.value[0], o.value.length > 1 && (c.value = o.value[o.value.length - 1]));
            const v = C(() => {
                const S = ["number", "string"].includes(typeof e.multiple) ? Number(e.multiple) : 1 / 0;
                return o.value.length >= S
            });
            de(r, (S, b) => {
                b && (d.value = s.isBefore(S[0].date, b[0].date))
            });

            function g(S) {
                const b = s.startOfDay(S);
                if (o.value.length === 0 ? u.value = void 0 : o.value.length === 1 && (u.value = o.value[0], c.value = void 0), !u.value) u.value = b, o.value = [u.value];
                else if (c.value) u.value = S, c.value = void 0, o.value = [u.value];
                else {
                    if (s.isSameDay(b, u.value)) {
                        u.value = void 0, o.value = [];
                        return
                    } else s.isBefore(b, u.value) ? (c.value = s.endOfDay(u.value), u.value = b) : c.value = s.endOfDay(b);
                    const p = s.getDiff(c.value, u.value, "days"),
                        _ = [u.value];
                    for (let w = 1; w < p; w++) {
                        const k = s.addDays(u.value, w);
                        _.push(k)
                    }
                    _.push(c.value), o.value = _
                }
            }

            function h(S) {
                const b = o.value.findIndex(p => s.isSameDay(p, S));
                if (b === -1) o.value = [...o.value, S];
                else {
                    const p = [...o.value];
                    p.splice(b, 1), o.value = p
                }
            }

            function y(S) {
                e.multiple === "range" ? g(S) : e.multiple ? h(S) : o.value = [S]
            }
            return () => m("div", {
                class: "v-date-picker-month"
            }, [e.showWeek && m("div", {
                key: "weeks",
                class: "v-date-picker-month__weeks"
            }, [!e.hideWeekdays && m("div", {
                key: "hide-week-days",
                class: "v-date-picker-month__day"
            }, [hn(" ")]), i.value.map(S => m("div", {
                class: ["v-date-picker-month__day", "v-date-picker-month__day--adjacent"]
            }, [S]))]), m(jt, {
                name: f.value
            }, {
                default: () => {
                    var S;
                    return [m("div", {
                        ref: l,
                        key: (S = r.value[0].date) == null ? void 0 : S.toString(),
                        class: "v-date-picker-month__days"
                    }, [!e.hideWeekdays && s.getWeekdays(e.firstDayOfWeek).map(b => m("div", {
                        class: ["v-date-picker-month__day", "v-date-picker-month__weekday"]
                    }, [b])), r.value.map((b, p) => {
                        const _ = {
                            props: {
                                onClick: () => y(b.date)
                            },
                            item: b,
                            i: p
                        };
                        return v.value && !b.isSelected && (b.isDisabled = !0), m("div", {
                            class: ["v-date-picker-month__day", {
                                "v-date-picker-month__day--adjacent": b.isAdjacent,
                                "v-date-picker-month__day--hide-adjacent": b.isHidden,
                                "v-date-picker-month__day--selected": b.isSelected,
                                "v-date-picker-month__day--week-end": b.isWeekEnd,
                                "v-date-picker-month__day--week-start": b.isWeekStart
                            }],
                            "data-v-date": b.isDisabled ? void 0 : b.isoDate
                        }, [(e.showAdjacentMonths || !b.isAdjacent) && m(Ve, {
                            defaults: {
                                VBtn: {
                                    class: "v-date-picker-month__day-btn",
                                    color: (b.isSelected || b.isToday) && !b.isDisabled ? e.color : void 0,
                                    disabled: b.isDisabled,
                                    icon: !0,
                                    ripple: !1,
                                    text: b.localized,
                                    variant: b.isDisabled ? b.isToday ? "outlined" : "text" : b.isToday && !b.isSelected ? "outlined" : "flat",
                                    onClick: () => y(b.date)
                                }
                            }
                        }, {
                            default: () => {
                                var w;
                                return [((w = a.day) == null ? void 0 : w.call(a, _)) ? ? m(Le, _.props, null)]
                            }
                        })])
                    })])]
                }
            })])
        }
    }),
    Uk = W({
        color: String,
        height: [String, Number],
        min: null,
        max: null,
        modelValue: Number,
        year: Number
    }, "VDatePickerMonths"),
    uf = Z()({
        name: "VDatePickerMonths",
        props: Uk(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                emit: n,
                slots: a
            } = t;
            const l = ia(),
                r = Ce(e, "modelValue"),
                o = C(() => {
                    let i = l.startOfYear(l.date());
                    return e.year && (i = l.setYear(i, e.year)), fn(12).map(s => {
                        const u = l.format(i, "monthShort"),
                            c = !!(e.min && l.isAfter(l.startOfMonth(l.date(e.min)), i) || e.max && l.isAfter(i, l.startOfMonth(l.date(e.max))));
                        return i = l.getNextMonth(i), {
                            isDisabled: c,
                            text: u,
                            value: s
                        }
                    })
                });
            return st(() => {
                r.value = r.value ? ? l.getMonth(l.date())
            }), ne(() => m("div", {
                class: "v-date-picker-months",
                style: {
                    height: ge(e.height)
                }
            }, [m("div", {
                class: "v-date-picker-months__content"
            }, [o.value.map((i, s) => {
                var d;
                const u = {
                    active: r.value === s,
                    color: r.value === s ? e.color : void 0,
                    disabled: i.isDisabled,
                    rounded: !0,
                    text: i.text,
                    variant: r.value === i.value ? "flat" : "text",
                    onClick: () => c(s)
                };

                function c(f) {
                    if (r.value === f) {
                        n("update:modelValue", r.value);
                        return
                    }
                    r.value = f
                }
                return ((d = a.month) == null ? void 0 : d.call(a, {
                    month: i,
                    i: s,
                    props: u
                })) ? ? m(Le, te({
                    key: "month"
                }, u), null)
            })])])), {}
        }
    }),
    Wk = W({
        color: String,
        height: [String, Number],
        min: null,
        max: null,
        modelValue: Number
    }, "VDatePickerYears"),
    cf = Z()({
        name: "VDatePickerYears",
        props: Wk(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                emit: n,
                slots: a
            } = t;
            const l = ia(),
                r = Ce(e, "modelValue"),
                o = C(() => {
                    const s = l.getYear(l.date());
                    let u = s - 100,
                        c = s + 52;
                    e.min && (u = l.getYear(l.date(e.min))), e.max && (c = l.getYear(l.date(e.max)));
                    let d = l.startOfYear(l.date());
                    return d = l.setYear(d, u), fn(c - u + 1, u).map(f => {
                        const v = l.format(d, "year");
                        return d = l.setYear(d, l.getYear(d) + 1), {
                            text: v,
                            value: f
                        }
                    })
                });
            st(() => {
                r.value = r.value ? ? l.getYear(l.date())
            });
            const i = As();
            return it(async () => {
                var s;
                await Re(), (s = i.el) == null || s.scrollIntoView({
                    block: "center"
                })
            }), ne(() => m("div", {
                class: "v-date-picker-years",
                style: {
                    height: ge(e.height)
                }
            }, [m("div", {
                class: "v-date-picker-years__content"
            }, [o.value.map((s, u) => {
                var d;
                const c = {
                    ref: r.value === s.value ? i : void 0,
                    active: r.value === s.value,
                    color: r.value === s.value ? e.color : void 0,
                    rounded: !0,
                    text: s.text,
                    variant: r.value === s.value ? "flat" : "text",
                    onClick: () => {
                        if (r.value === s.value) {
                            n("update:modelValue", r.value);
                            return
                        }
                        r.value = s.value
                    }
                };
                return ((d = a.year) == null ? void 0 : d.call(a, {
                    year: s,
                    i: u,
                    props: c
                })) ? ? m(Le, te({
                    key: "month"
                }, c), null)
            })])])), {}
        }
    }),
    zk = oa("v-picker-title"),
    Cm = W({
        bgColor: String,
        landscape: Boolean,
        title: String,
        hideHeader: Boolean,
        ...Fu()
    }, "VPicker"),
    Xo = Z()({
        name: "VPicker",
        props: Cm(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                backgroundColorClasses: a,
                backgroundColorStyles: l
            } = Ke(Y(e, "color"));
            return ne(() => {
                const r = Qa.filterProps(e),
                    o = !!(e.title || n.title);
                return m(Qa, te(r, {
                    color: e.bgColor,
                    class: ["v-picker", {
                        "v-picker--landscape": e.landscape,
                        "v-picker--with-actions": !!n.actions
                    }, e.class],
                    style: e.style
                }), {
                    default: () => {
                        var i;
                        return [!e.hideHeader && m("div", {
                            key: "header",
                            class: [a.value],
                            style: [l.value]
                        }, [o && m(zk, {
                            key: "picker-title"
                        }, {
                            default: () => {
                                var s;
                                return [((s = n.title) == null ? void 0 : s.call(n)) ? ? e.title]
                            }
                        }), n.header && m("div", {
                            class: "v-picker__header"
                        }, [n.header()])]), m("div", {
                            class: "v-picker__body"
                        }, [(i = n.default) == null ? void 0 : i.call(n)]), n.actions && m(Ve, {
                            defaults: {
                                VBtn: {
                                    slim: !0,
                                    variant: "text"
                                }
                            }
                        }, {
                            default: () => [m("div", {
                                class: "v-picker__actions"
                            }, [n.actions()])]
                        })]
                    }
                })
            }), {}
        }
    }),
    Kk = W({
        header: {
            type: String,
            default: "$vuetify.datePicker.header"
        },
        ...Bk(),
        ...jk({
            weeksInMonth: "static"
        }),
        ...We(Uk(), ["modelValue"]),
        ...We(Wk(), ["modelValue"]),
        ...Cm({
            title: "$vuetify.datePicker.title"
        }),
        modelValue: null
    }, "VDatePicker"),
    df = Z()({
        name: "VDatePicker",
        props: Kk(),
        emits: {
            "update:modelValue": e => !0,
            "update:month": e => !0,
            "update:year": e => !0,
            "update:viewMode": e => !0
        },
        setup(e, t) {
            let {
                emit: n,
                slots: a
            } = t;
            const l = ia(),
                {
                    t: r
                } = Qe(),
                o = Ce(e, "modelValue", void 0, x => nt(x), x => e.multiple ? x : x[0]),
                i = Ce(e, "viewMode"),
                s = C(() => {
                    var T;
                    const x = l.date((T = o.value) == null ? void 0 : T[0]);
                    return x && l.isValid(x) ? x : l.date()
                }),
                u = Q(Number(e.month ? ? l.getMonth(l.startOfMonth(s.value)))),
                c = Q(Number(e.year ? ? l.getYear(l.startOfYear(l.setMonth(s.value, u.value))))),
                d = fe(!1),
                f = C(() => e.multiple && o.value.length > 1 ? r("$vuetify.datePicker.itemsSelected", o.value.length) : o.value[0] && l.isValid(o.value[0]) ? l.format(l.date(o.value[0]), "normalDateWithWeekday") : r(e.header)),
                v = C(() => {
                    let x = l.date();
                    return x = l.setDate(x, 1), x = l.setMonth(x, u.value), x = l.setYear(x, c.value), l.format(x, "monthAndYear")
                }),
                g = C(() => `date-picker-header${d.value?"-reverse":""}-transition`),
                h = C(() => {
                    const x = l.date(e.min);
                    return e.min && l.isValid(x) ? x : null
                }),
                y = C(() => {
                    const x = l.date(e.max);
                    return e.max && l.isValid(x) ? x : null
                }),
                S = C(() => {
                    if (e.disabled) return !0;
                    const x = [];
                    if (i.value !== "month") x.push("prev", "next");
                    else {
                        let T = l.date();
                        if (T = l.setYear(T, c.value), T = l.setMonth(T, u.value), h.value) {
                            const V = l.addDays(l.startOfMonth(T), -1);
                            l.isAfter(h.value, V) && x.push("prev")
                        }
                        if (y.value) {
                            const V = l.addDays(l.endOfMonth(T), 1);
                            l.isAfter(V, y.value) && x.push("next")
                        }
                    }
                    return x
                });

            function b() {
                u.value < 11 ? u.value++ : (c.value++, u.value = 0, P(c.value)), E(u.value)
            }

            function p() {
                u.value > 0 ? u.value-- : (c.value--, u.value = 11, P(c.value)), E(u.value)
            }

            function _() {
                i.value = "month"
            }

            function w() {
                i.value = i.value === "months" ? "month" : "months"
            }

            function k() {
                i.value = i.value === "year" ? "month" : "year"
            }

            function E(x) {
                i.value === "months" && w(), n("update:month", x)
            }

            function P(x) {
                i.value === "year" && k(), n("update:year", x)
            }
            return de(o, (x, T) => {
                const V = nt(T),
                    I = nt(x);
                if (!I.length) return;
                const R = l.date(V[V.length - 1]),
                    B = l.date(I[I.length - 1]),
                    $ = l.getMonth(B),
                    D = l.getYear(B);
                $ !== u.value && (u.value = $, E(u.value)), D !== c.value && (c.value = D, P(c.value)), d.value = l.isBefore(R, B)
            }), ne(() => {
                const x = Xo.filterProps(e),
                    T = rf.filterProps(e),
                    V = of .filterProps(e),
                    I = sf.filterProps(e),
                    R = We(uf.filterProps(e), ["modelValue"]),
                    B = We(cf.filterProps(e), ["modelValue"]),
                    $ = {
                        header: f.value,
                        transition: g.value
                    };
                return m(Xo, te(x, {
                    class: ["v-date-picker", `v-date-picker--${i.value}`, {
                        "v-date-picker--show-week": e.showWeek
                    }, e.class],
                    style: e.style
                }), {
                    title: () => {
                        var D;
                        return ((D = a.title) == null ? void 0 : D.call(a)) ? ? m("div", {
                            class: "v-date-picker__title"
                        }, [r(e.title)])
                    },
                    header: () => a.header ? m(Ve, {
                        defaults: {
                            VDatePickerHeader: { ...$
                            }
                        }
                    }, {
                        default: () => {
                            var D;
                            return [(D = a.header) == null ? void 0 : D.call(a, $)]
                        }
                    }) : m( of , te({
                        key: "header"
                    }, V, $, {
                        onClick: i.value !== "month" ? _ : void 0
                    }), { ...a,
                        default: void 0
                    }),
                    default: () => m(ye, null, [m(rf, te(T, {
                        disabled: S.value,
                        text: v.value,
                        "onClick:next": b,
                        "onClick:prev": p,
                        "onClick:month": w,
                        "onClick:year": k
                    }), null), m(jo, {
                        hideOnLeave: !0
                    }, {
                        default: () => [i.value === "months" ? m(uf, te({
                            key: "date-picker-months"
                        }, R, {
                            modelValue: u.value,
                            "onUpdate:modelValue": [D => u.value = D, E],
                            min: h.value,
                            max: y.value,
                            year: c.value
                        }), null) : i.value === "year" ? m(cf, te({
                            key: "date-picker-years"
                        }, B, {
                            modelValue: c.value,
                            "onUpdate:modelValue": [D => c.value = D, P],
                            min: h.value,
                            max: y.value
                        }), null) : m(sf, te({
                            key: "date-picker-month"
                        }, I, {
                            modelValue: o.value,
                            "onUpdate:modelValue": D => o.value = D,
                            month: u.value,
                            "onUpdate:month": [D => u.value = D, E],
                            year: c.value,
                            "onUpdate:year": [D => c.value = D, P],
                            min: h.value,
                            max: y.value
                        }), null)]
                    })]),
                    actions: a.actions
                })
            }), {}
        }
    }),
    G2 = W({
        actionText: String,
        bgColor: String,
        color: String,
        icon: Pe,
        image: String,
        justify: {
            type: String,
            default: "center"
        },
        headline: String,
        title: String,
        text: String,
        textWidth: {
            type: [Number, String],
            default: 500
        },
        href: String,
        to: String,
        ...Se(),
        ...bt(),
        ...sa({
            size: void 0
        }),
        ...Ne()
    }, "VEmptyState"),
    Y2 = Z()({
        name: "VEmptyState",
        props: G2(),
        emits: {
            "click:action": e => !0
        },
        setup(e, t) {
            let {
                emit: n,
                slots: a
            } = t;
            const {
                themeClasses: l
            } = je(e), {
                backgroundColorClasses: r,
                backgroundColorStyles: o
            } = Ke(Y(e, "bgColor")), {
                dimensionStyles: i
            } = pt(e), {
                displayClasses: s
            } = On();

            function u(c) {
                n("click:action", c)
            }
            return ne(() => {
                var y, S, b;
                const c = !!(a.actions || e.actionText),
                    d = !!(a.headline || e.headline),
                    f = !!(a.title || e.title),
                    v = !!(a.text || e.text),
                    g = !!(a.media || e.image || e.icon),
                    h = e.size || (e.image ? 200 : 96);
                return m("div", {
                    class: ["v-empty-state", {
                        [`v-empty-state--${e.justify}`]: !0
                    }, l.value, r.value, s.value, e.class],
                    style: [o.value, i.value, e.style]
                }, [g && m("div", {
                    key: "media",
                    class: "v-empty-state__media"
                }, [a.media ? m(Ve, {
                    key: "media-defaults",
                    defaults: {
                        VImg: {
                            src: e.image,
                            height: h
                        },
                        VIcon: {
                            size: h,
                            icon: e.icon
                        }
                    }
                }, {
                    default: () => [a.media()]
                }) : m(ye, null, [e.image ? m(Ca, {
                    key: "image",
                    src: e.image,
                    height: h
                }, null) : e.icon ? m(Be, {
                    key: "icon",
                    color: e.color,
                    size: h,
                    icon: e.icon
                }, null) : void 0])]), d && m("div", {
                    key: "headline",
                    class: "v-empty-state__headline"
                }, [((y = a.headline) == null ? void 0 : y.call(a)) ? ? e.headline]), f && m("div", {
                    key: "title",
                    class: "v-empty-state__title"
                }, [((S = a.title) == null ? void 0 : S.call(a)) ? ? e.title]), v && m("div", {
                    key: "text",
                    class: "v-empty-state__text",
                    style: {
                        maxWidth: ge(e.textWidth)
                    }
                }, [((b = a.text) == null ? void 0 : b.call(a)) ? ? e.text]), a.default && m("div", {
                    key: "content",
                    class: "v-empty-state__content"
                }, [a.default()]), c && m("div", {
                    key: "actions",
                    class: "v-empty-state__actions"
                }, [m(Ve, {
                    defaults: {
                        VBtn: {
                            class: "v-empty-state__action-btn",
                            color: e.color ? ? "surface-variant",
                            text: e.actionText
                        }
                    }
                }, {
                    default: () => {
                        var p;
                        return [((p = a.actions) == null ? void 0 : p.call(a, {
                            props: {
                                onClick: u
                            }
                        })) ? ? m(Le, {
                            onClick: u
                        }, null)]
                    }
                })])])
            }), {}
        }
    }),
    Jo = Symbol.for("vuetify:v-expansion-panel"),
    Gk = W({ ...Se(),
        ...nm()
    }, "VExpansionPanelText"),
    ff = Z()({
        name: "VExpansionPanelText",
        props: Gk(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Te(Jo);
            if (!a) throw new Error("[Vuetify] v-expansion-panel-text needs to be placed inside v-expansion-panel");
            const {
                hasContent: l,
                onAfterLeave: r
            } = am(e, a.isSelected);
            return ne(() => m(Vu, {
                onAfterLeave: r
            }, {
                default: () => {
                    var o;
                    return [at(m("div", {
                        class: ["v-expansion-panel-text", e.class],
                        style: e.style
                    }, [n.default && l.value && m("div", {
                        class: "v-expansion-panel-text__wrapper"
                    }, [(o = n.default) == null ? void 0 : o.call(n)])]), [
                        [bn, a.isSelected.value]
                    ])]
                }
            })), {}
        }
    }),
    Yk = W({
        color: String,
        expandIcon: {
            type: Pe,
            default: "$expand"
        },
        collapseIcon: {
            type: Pe,
            default: "$collapse"
        },
        hideActions: Boolean,
        focusable: Boolean,
        static: Boolean,
        ripple: {
            type: [Boolean, Object],
            default: !1
        },
        readonly: Boolean,
        ...Se(),
        ...bt()
    }, "VExpansionPanelTitle"),
    vf = Z()({
        name: "VExpansionPanelTitle",
        directives: {
            Ripple: Ia
        },
        props: Yk(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Te(Jo);
            if (!a) throw new Error("[Vuetify] v-expansion-panel-title needs to be placed inside v-expansion-panel");
            const {
                backgroundColorClasses: l,
                backgroundColorStyles: r
            } = Ke(e, "color"), {
                dimensionStyles: o
            } = pt(e), i = C(() => ({
                collapseIcon: e.collapseIcon,
                disabled: a.disabled.value,
                expanded: a.isSelected.value,
                expandIcon: e.expandIcon,
                readonly: e.readonly
            })), s = C(() => a.isSelected.value ? e.collapseIcon : e.expandIcon);
            return ne(() => {
                var u;
                return at(m("button", {
                    class: ["v-expansion-panel-title", {
                        "v-expansion-panel-title--active": a.isSelected.value,
                        "v-expansion-panel-title--focusable": e.focusable,
                        "v-expansion-panel-title--static": e.static
                    }, l.value, e.class],
                    style: [r.value, o.value, e.style],
                    type: "button",
                    tabindex: a.disabled.value ? -1 : void 0,
                    disabled: a.disabled.value,
                    "aria-expanded": a.isSelected.value,
                    onClick: e.readonly ? void 0 : a.toggle
                }, [m("span", {
                    class: "v-expansion-panel-title__overlay"
                }, null), (u = n.default) == null ? void 0 : u.call(n, i.value), !e.hideActions && m(Ve, {
                    defaults: {
                        VIcon: {
                            icon: s.value
                        }
                    }
                }, {
                    default: () => {
                        var c;
                        return [m("span", {
                            class: "v-expansion-panel-title__icon"
                        }, [((c = n.actions) == null ? void 0 : c.call(n, i.value)) ? ? m(Be, null, null)])]
                    }
                })]), [
                    [tn("ripple"), e.ripple]
                ])
            }), {}
        }
    }),
    xm = W({
        title: String,
        text: String,
        bgColor: String,
        ...Pt(),
        ...ql(),
        ...rt(),
        ...Ae(),
        ...Yk(),
        ...Gk()
    }, "VExpansionPanel"),
    mf = Z()({
        name: "VExpansionPanel",
        props: xm(),
        emits: {
            "group:selected": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Xl(e, Jo),
                {
                    backgroundColorClasses: l,
                    backgroundColorStyles: r
                } = Ke(e, "bgColor"),
                {
                    elevationClasses: o
                } = Dt(e),
                {
                    roundedClasses: i
                } = ct(e),
                s = C(() => (a == null ? void 0 : a.disabled.value) || e.disabled),
                u = C(() => a.group.items.value.reduce((f, v, g) => (a.group.selected.value.includes(v.id) && f.push(g), f), [])),
                c = C(() => {
                    const f = a.group.items.value.findIndex(v => v.id === a.id);
                    return !a.isSelected.value && u.value.some(v => v - f === 1)
                }),
                d = C(() => {
                    const f = a.group.items.value.findIndex(v => v.id === a.id);
                    return !a.isSelected.value && u.value.some(v => v - f === -1)
                });
            return He(Jo, a), ne(() => {
                const f = !!(n.text || e.text),
                    v = !!(n.title || e.title),
                    g = vf.filterProps(e),
                    h = ff.filterProps(e);
                return m(e.tag, {
                    class: ["v-expansion-panel", {
                        "v-expansion-panel--active": a.isSelected.value,
                        "v-expansion-panel--before-active": c.value,
                        "v-expansion-panel--after-active": d.value,
                        "v-expansion-panel--disabled": s.value
                    }, i.value, l.value, e.class],
                    style: [r.value, e.style]
                }, {
                    default: () => [m("div", {
                        class: ["v-expansion-panel__shadow", ...o.value]
                    }, null), m(Ve, {
                        defaults: {
                            VExpansionPanelTitle: { ...g
                            },
                            VExpansionPanelText: { ...h
                            }
                        }
                    }, {
                        default: () => {
                            var y;
                            return [v && m(vf, {
                                key: "title"
                            }, {
                                default: () => [n.title ? n.title() : e.title]
                            }), f && m(ff, {
                                key: "text"
                            }, {
                                default: () => [n.text ? n.text() : e.text]
                            }), (y = n.default) == null ? void 0 : y.call(n)]
                        }
                    })]
                })
            }), {
                groupItem: a
            }
        }
    }),
    q2 = ["default", "accordion", "inset", "popout"],
    qk = W({
        flat: Boolean,
        ...Yl(),
        ...Vv(xm(), ["bgColor", "collapseIcon", "color", "eager", "elevation", "expandIcon", "focusable", "hideActions", "readonly", "ripple", "rounded", "tile", "static"]),
        ...Ne(),
        ...Se(),
        ...Ae(),
        variant: {
            type: String,
            default: "default",
            validator: e => q2.includes(e)
        }
    }, "VExpansionPanels"),
    hf = Z()({
        name: "VExpansionPanels",
        props: qk(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                next: a,
                prev: l
            } = rl(e, Jo), {
                themeClasses: r
            } = je(e), o = C(() => e.variant && `v-expansion-panels--variant-${e.variant}`);
            return lt({
                VExpansionPanel: {
                    bgColor: Y(e, "bgColor"),
                    collapseIcon: Y(e, "collapseIcon"),
                    color: Y(e, "color"),
                    eager: Y(e, "eager"),
                    elevation: Y(e, "elevation"),
                    expandIcon: Y(e, "expandIcon"),
                    focusable: Y(e, "focusable"),
                    hideActions: Y(e, "hideActions"),
                    readonly: Y(e, "readonly"),
                    ripple: Y(e, "ripple"),
                    rounded: Y(e, "rounded"),
                    static: Y(e, "static")
                }
            }), ne(() => m(e.tag, {
                class: ["v-expansion-panels", {
                    "v-expansion-panels--flat": e.flat,
                    "v-expansion-panels--tile": e.tile
                }, r.value, o.value, e.class],
                style: e.style
            }, {
                default: () => {
                    var i;
                    return [(i = n.default) == null ? void 0 : i.call(n, {
                        prev: l,
                        next: a
                    })]
                }
            })), {
                next: a,
                prev: l
            }
        }
    }),
    X2 = W({
        app: Boolean,
        appear: Boolean,
        extended: Boolean,
        layout: Boolean,
        offset: Boolean,
        modelValue: {
            type: Boolean,
            default: !0
        },
        ...We(Ru({
            active: !0
        }), ["location"]),
        ...Wl(),
        ...Ea(),
        ...Wn({
            transition: "fab-transition"
        })
    }, "VFab"),
    J2 = Z()({
        name: "VFab",
        props: X2(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Ce(e, "modelValue"),
                l = fe(56),
                r = Q(),
                {
                    resizeRef: o
                } = Hn(d => {
                    d.length && (l.value = d[0].target.clientHeight)
                }),
                i = C(() => e.app || e.absolute),
                s = C(() => {
                    var d;
                    return i.value ? ((d = e.location) == null ? void 0 : d.split(" ").shift()) ? ? "bottom" : !1
                }),
                u = C(() => {
                    var d;
                    return i.value ? ((d = e.location) == null ? void 0 : d.split(" ")[1]) ? ? "end" : !1
                });
            Yt(() => e.app, () => {
                const d = zl({
                    id: e.name,
                    order: C(() => parseInt(e.order, 10)),
                    position: s,
                    layoutSize: C(() => e.layout ? l.value + 24 : 0),
                    elementSize: C(() => l.value + 24),
                    active: C(() => e.app && a.value),
                    absolute: Y(e, "absolute")
                });
                st(() => {
                    r.value = d.layoutItemStyles.value
                })
            });
            const c = Q();
            return ne(() => {
                const d = Le.filterProps(e);
                return m("div", {
                    ref: c,
                    class: ["v-fab", {
                        "v-fab--absolute": e.absolute,
                        "v-fab--app": !!e.app,
                        "v-fab--extended": e.extended,
                        "v-fab--offset": e.offset,
                        [`v-fab--${s.value}`]: i.value,
                        [`v-fab--${u.value}`]: i.value
                    }, e.class],
                    style: [e.app ? { ...r.value
                    } : {
                        height: "inherit",
                        width: void 0
                    }, e.style]
                }, [m("div", {
                    class: "v-fab__container"
                }, [m(jt, {
                    appear: e.appear,
                    transition: e.transition
                }, {
                    default: () => [at(m(Le, te({
                        ref: o
                    }, d, {
                        active: void 0,
                        location: void 0
                    }), n), [
                        [bn, e.active]
                    ])]
                })])])
            }), {}
        }
    }),
    Z2 = W({
        chips: Boolean,
        counter: Boolean,
        counterSizeString: {
            type: String,
            default: "$vuetify.fileInput.counterSize"
        },
        counterString: {
            type: String,
            default: "$vuetify.fileInput.counter"
        },
        hideInput: Boolean,
        multiple: Boolean,
        showSize: {
            type: [Boolean, Number, String],
            default: !1,
            validator: e => typeof e == "boolean" || [1e3, 1024].includes(Number(e))
        },
        ...Ta({
            prependIcon: "$file"
        }),
        modelValue: {
            type: [Array, Object],
            default: e => e.multiple ? [] : null,
            validator: e => nt(e).every(t => t != null && typeof t == "object")
        },
        ...bi({
            clearable: !0
        })
    }, "VFileInput"),
    Q2 = Z()({
        name: "VFileInput",
        inheritAttrs: !1,
        props: Z2(),
        emits: {
            "click:control": e => !0,
            "mousedown:control": e => !0,
            "update:focused": e => !0,
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                attrs: n,
                emit: a,
                slots: l
            } = t;
            const {
                t: r
            } = Qe(), o = Ce(e, "modelValue", e.modelValue, x => nt(x), x => !e.multiple && Array.isArray(x) ? x[0] : x), {
                isFocused: i,
                focus: s,
                blur: u
            } = ua(e), c = C(() => typeof e.showSize != "boolean" ? e.showSize : void 0), d = C(() => (o.value ? ? []).reduce((x, T) => {
                let {
                    size: V = 0
                } = T;
                return x + V
            }, 0)), f = C(() => iy(d.value, c.value)), v = C(() => (o.value ? ? []).map(x => {
                const {
                    name: T = "",
                    size: V = 0
                } = x;
                return e.showSize ? `${T} (${iy(V,c.value)})` : T
            })), g = C(() => {
                var T;
                const x = ((T = o.value) == null ? void 0 : T.length) ? ? 0;
                return e.showSize ? r(e.counterSizeString, x, f.value) : r(e.counterString, x)
            }), h = Q(), y = Q(), S = Q(), b = C(() => i.value || e.active), p = C(() => ["plain", "underlined"].includes(e.variant));

            function _() {
                var x;
                S.value !== document.activeElement && ((x = S.value) == null || x.focus()), i.value || s()
            }

            function w(x) {
                var T;
                (T = S.value) == null || T.click()
            }

            function k(x) {
                a("mousedown:control", x)
            }

            function E(x) {
                var T;
                (T = S.value) == null || T.click(), a("click:control", x)
            }

            function P(x) {
                x.stopPropagation(), _(), Re(() => {
                    o.value = [], Lv(e["onClick:clear"], x)
                })
            }
            return de(o, x => {
                (!Array.isArray(x) || !x.length) && S.value && (S.value.value = "")
            }), ne(() => {
                const x = !!(l.counter || e.counter),
                    T = !!(x || l.details),
                    [V, I] = al(n),
                    {
                        modelValue: R,
                        ...B
                    } = $t.filterProps(e),
                    $ = lm(e);
                return m($t, te({
                    ref: h,
                    modelValue: o.value,
                    "onUpdate:modelValue": D => o.value = D,
                    class: ["v-file-input", {
                        "v-file-input--chips": !!e.chips,
                        "v-file-input--hide": e.hideInput,
                        "v-input--plain-underlined": p.value
                    }, e.class],
                    style: e.style,
                    "onClick:prepend": w
                }, V, B, {
                    centerAffix: !p.value,
                    focused: i.value
                }), { ...l,
                    default: D => {
                        let {
                            id: z,
                            isDisabled: N,
                            isDirty: H,
                            isReadonly: F,
                            isValid: j
                        } = D;
                        return m(Xr, te({
                            ref: y,
                            "prepend-icon": e.prependIcon,
                            onMousedown: k,
                            onClick: E,
                            "onClick:clear": P,
                            "onClick:prependInner": e["onClick:prependInner"],
                            "onClick:appendInner": e["onClick:appendInner"]
                        }, $, {
                            id: z.value,
                            active: b.value || H.value,
                            dirty: H.value || e.dirty,
                            disabled: N.value,
                            focused: i.value,
                            error: j.value === !1
                        }), { ...l,
                            default: ae => {
                                var we;
                                let {
                                    props: {
                                        class: he,
                                        ...ve
                                    }
                                } = ae;
                                return m(ye, null, [m("input", te({
                                    ref: S,
                                    type: "file",
                                    readonly: F.value,
                                    disabled: N.value,
                                    multiple: e.multiple,
                                    name: e.name,
                                    onClick: ee => {
                                        ee.stopPropagation(), F.value && ee.preventDefault(), _()
                                    },
                                    onChange: ee => {
                                        if (!ee.target) return;
                                        const G = ee.target;
                                        o.value = [...G.files ? ? []]
                                    },
                                    onFocus: _,
                                    onBlur: u
                                }, ve, I), null), m("div", {
                                    class: he
                                }, [!!((we = o.value) != null && we.length) && !e.hideInput && (l.selection ? l.selection({
                                    fileNames: v.value,
                                    totalBytes: d.value,
                                    totalBytesReadable: f.value
                                }) : e.chips ? v.value.map(ee => m(Zl, {
                                    key: ee,
                                    size: "small",
                                    text: ee
                                }, null)) : v.value.join(", "))])])
                            }
                        })
                    },
                    details: T ? D => {
                        var z, N;
                        return m(ye, null, [(z = l.details) == null ? void 0 : z.call(l, D), x && m(ye, null, [m("span", null, null), m(Mu, {
                            active: !!((N = o.value) != null && N.length),
                            value: g.value,
                            disabled: e.disabled
                        }, l.counter)])])
                    } : void 0
                })
            }), wn({}, h, y, S)
        }
    }),
    eH = W({
        app: Boolean,
        color: String,
        height: {
            type: [Number, String],
            default: "auto"
        },
        ...an(),
        ...Se(),
        ...Pt(),
        ...Wl(),
        ...rt(),
        ...Ae({
            tag: "footer"
        }),
        ...Ne()
    }, "VFooter"),
    tH = Z()({
        name: "VFooter",
        props: eH(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Q(),
                {
                    themeClasses: l
                } = je(e),
                {
                    backgroundColorClasses: r,
                    backgroundColorStyles: o
                } = Ke(Y(e, "color")),
                {
                    borderClasses: i
                } = Sn(e),
                {
                    elevationClasses: s
                } = Dt(e),
                {
                    roundedClasses: u
                } = ct(e),
                c = fe(32),
                {
                    resizeRef: d
                } = Hn(v => {
                    v.length && (c.value = v[0].target.clientHeight)
                }),
                f = C(() => e.height === "auto" ? c.value : parseInt(e.height, 10));
            return Yt(() => e.app, () => {
                const v = zl({
                    id: e.name,
                    order: C(() => parseInt(e.order, 10)),
                    position: C(() => "bottom"),
                    layoutSize: f,
                    elementSize: C(() => e.height === "auto" ? void 0 : f.value),
                    active: C(() => e.app),
                    absolute: Y(e, "absolute")
                });
                st(() => {
                    a.value = v.layoutItemStyles.value
                })
            }), ne(() => m(e.tag, {
                ref: d,
                class: ["v-footer", l.value, r.value, i.value, s.value, u.value, e.class],
                style: [o.value, e.app ? a.value : {
                    height: ge(e.height)
                }, e.style]
            }, n)), {}
        }
    }),
    nH = W({ ...Se(),
        ...x$()
    }, "VForm"),
    aH = Z()({
        name: "VForm",
        props: nH(),
        emits: {
            "update:modelValue": e => !0,
            submit: e => !0
        },
        setup(e, t) {
            let {
                slots: n,
                emit: a
            } = t;
            const l = P$(e),
                r = Q();

            function o(s) {
                s.preventDefault(), l.reset()
            }

            function i(s) {
                const u = s,
                    c = l.validate();
                u.then = c.then.bind(c), u.catch = c.catch.bind(c), u.finally = c.finally.bind(c), a("submit", u), u.defaultPrevented || c.then(d => {
                    var v;
                    let {
                        valid: f
                    } = d;
                    f && ((v = r.value) == null || v.submit())
                }), u.preventDefault()
            }
            return ne(() => {
                var s;
                return m("form", {
                    ref: r,
                    class: ["v-form", e.class],
                    style: e.style,
                    novalidate: !0,
                    onReset: o,
                    onSubmit: i
                }, [(s = n.default) == null ? void 0 : s.call(n, l)])
            }), wn(l, r)
        }
    }),
    lH = W({
        disabled: Boolean,
        modelValue: {
            type: Boolean,
            default: null
        },
        ...em()
    }, "VHover"),
    rH = Z()({
        name: "VHover",
        props: lH(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Ce(e, "modelValue"),
                {
                    runOpenDelay: l,
                    runCloseDelay: r
                } = tm(e, o => !e.disabled && (a.value = o));
            return () => {
                var o;
                return (o = n.default) == null ? void 0 : o.call(n, {
                    isHovering: a.value,
                    props: {
                        onMouseenter: l,
                        onMouseleave: r
                    }
                })
            }
        }
    }),
    oH = W({
        color: String,
        direction: {
            type: String,
            default: "vertical",
            validator: e => ["vertical", "horizontal"].includes(e)
        },
        side: {
            type: String,
            default: "end",
            validator: e => ["start", "end", "both"].includes(e)
        },
        mode: {
            type: String,
            default: "intersect",
            validator: e => ["intersect", "manual"].includes(e)
        },
        margin: [Number, String],
        loadMoreText: {
            type: String,
            default: "$vuetify.infiniteScroll.loadMore"
        },
        emptyText: {
            type: String,
            default: "$vuetify.infiniteScroll.empty"
        },
        ...bt(),
        ...Ae()
    }, "VInfiniteScroll"),
    qy = pn({
        name: "VInfiniteScrollIntersect",
        props: {
            side: {
                type: String,
                required: !0
            },
            rootMargin: String
        },
        emits: {
            intersect: (e, t) => !0
        },
        setup(e, t) {
            let {
                emit: n
            } = t;
            const {
                intersectionRef: a,
                isIntersecting: l
            } = Au();
            return de(l, async r => {
                n("intersect", e.side, r)
            }), ne(() => m("div", {
                class: "v-infinite-scroll-intersect",
                style: {
                    "--v-infinite-margin-size": e.rootMargin
                },
                ref: a
            }, [hn(" ")])), {}
        }
    }),
    iH = Z()({
        name: "VInfiniteScroll",
        props: oH(),
        emits: {
            load: e => !0
        },
        setup(e, t) {
            let {
                slots: n,
                emit: a
            } = t;
            const l = Q(),
                r = fe("ok"),
                o = fe("ok"),
                i = C(() => ge(e.margin)),
                s = fe(!1);

            function u(w) {
                if (!l.value) return;
                const k = e.direction === "vertical" ? "scrollTop" : "scrollLeft";
                l.value[k] = w
            }

            function c() {
                if (!l.value) return 0;
                const w = e.direction === "vertical" ? "scrollTop" : "scrollLeft";
                return l.value[w]
            }

            function d() {
                if (!l.value) return 0;
                const w = e.direction === "vertical" ? "scrollHeight" : "scrollWidth";
                return l.value[w]
            }

            function f() {
                if (!l.value) return 0;
                const w = e.direction === "vertical" ? "clientHeight" : "clientWidth";
                return l.value[w]
            }
            it(() => {
                l.value && (e.side === "start" ? u(d()) : e.side === "both" && u(d() / 2 - f() / 2))
            });

            function v(w, k) {
                w === "start" ? r.value = k : w === "end" && (o.value = k)
            }

            function g(w) {
                return w === "start" ? r.value : o.value
            }
            let h = 0;

            function y(w, k) {
                s.value = k, s.value && S(w)
            }

            function S(w) {
                if (e.mode !== "manual" && !s.value) return;
                const k = g(w);
                if (!l.value || ["empty", "loading"].includes(k)) return;
                h = d(), v(w, "loading");

                function E(P) {
                    v(w, P), Re(() => {
                        P === "empty" || P === "error" || (P === "ok" && w === "start" && u(d() - h + c()), e.mode !== "manual" && Re(() => {
                            window.requestAnimationFrame(() => {
                                window.requestAnimationFrame(() => {
                                    window.requestAnimationFrame(() => {
                                        S(w)
                                    })
                                })
                            })
                        }))
                    })
                }
                a("load", {
                    side: w,
                    done: E
                })
            }
            const {
                t: b
            } = Qe();

            function p(w, k) {
                var x, T, V, I, R;
                if (e.side !== w && e.side !== "both") return;
                const E = () => S(w),
                    P = {
                        side: w,
                        props: {
                            onClick: E,
                            color: e.color
                        }
                    };
                return k === "error" ? (x = n.error) == null ? void 0 : x.call(n, P) : k === "empty" ? ((T = n.empty) == null ? void 0 : T.call(n, P)) ? ? m("div", null, [b(e.emptyText)]) : e.mode === "manual" ? k === "loading" ? ((V = n.loading) == null ? void 0 : V.call(n, P)) ? ? m(Ja, {
                    indeterminate: !0,
                    color: e.color
                }, null) : ((I = n["load-more"]) == null ? void 0 : I.call(n, P)) ? ? m(Le, {
                    variant: "outlined",
                    color: e.color,
                    onClick: E
                }, {
                    default: () => [b(e.loadMoreText)]
                }) : ((R = n.loading) == null ? void 0 : R.call(n, P)) ? ? m(Ja, {
                    indeterminate: !0,
                    color: e.color
                }, null)
            }
            const {
                dimensionStyles: _
            } = pt(e);
            ne(() => {
                const w = e.tag,
                    k = e.side === "start" || e.side === "both",
                    E = e.side === "end" || e.side === "both",
                    P = e.mode === "intersect";
                return m(w, {
                    ref: l,
                    class: ["v-infinite-scroll", `v-infinite-scroll--${e.direction}`, {
                        "v-infinite-scroll--start": k,
                        "v-infinite-scroll--end": E
                    }],
                    style: _.value
                }, {
                    default: () => {
                        var x;
                        return [m("div", {
                            class: "v-infinite-scroll__side"
                        }, [p("start", r.value)]), k && P && m(qy, {
                            key: "start",
                            side: "start",
                            onIntersect: y,
                            rootMargin: i.value
                        }, null), (x = n.default) == null ? void 0 : x.call(n), E && P && m(qy, {
                            key: "end",
                            side: "end",
                            onIntersect: y,
                            rootMargin: i.value
                        }, null), m("div", {
                            class: "v-infinite-scroll__side"
                        }, [p("end", o.value)])]
                    }
                })
            })
        }
    }),
    Xk = Symbol.for("vuetify:v-item-group"),
    sH = W({ ...Se(),
        ...Yl({
            selectedClass: "v-item--selected"
        }),
        ...Ae(),
        ...Ne()
    }, "VItemGroup"),
    uH = Z()({
        name: "VItemGroup",
        props: sH(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                themeClasses: a
            } = je(e), {
                isSelected: l,
                select: r,
                next: o,
                prev: i,
                selected: s
            } = rl(e, Xk);
            return () => m(e.tag, {
                class: ["v-item-group", a.value, e.class],
                style: e.style
            }, {
                default: () => {
                    var u;
                    return [(u = n.default) == null ? void 0 : u.call(n, {
                        isSelected: l,
                        select: r,
                        next: o,
                        prev: i,
                        selected: s.value
                    })]
                }
            })
        }
    }),
    cH = Z()({
        name: "VItem",
        props: ql(),
        emits: {
            "group:selected": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                isSelected: a,
                select: l,
                toggle: r,
                selectedClass: o,
                value: i,
                disabled: s
            } = Xl(e, Xk);
            return () => {
                var u;
                return (u = n.default) == null ? void 0 : u.call(n, {
                    isSelected: a.value,
                    selectedClass: o.value,
                    select: l,
                    toggle: r,
                    value: i.value,
                    disabled: s.value
                })
            }
        }
    }),
    dH = oa("v-kbd"),
    fH = W({ ...Se(),
        ...bt(),
        ...VS()
    }, "VLayout"),
    vH = Z()({
        name: "VLayout",
        props: fH(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                layoutClasses: a,
                layoutStyles: l,
                getLayoutItem: r,
                items: o,
                layoutRef: i
            } = LS(e), {
                dimensionStyles: s
            } = pt(e);
            return ne(() => {
                var u;
                return m("div", {
                    ref: i,
                    class: [a.value, e.class],
                    style: [s.value, l.value, e.style]
                }, [(u = n.default) == null ? void 0 : u.call(n)])
            }), {
                getLayoutItem: r,
                items: o
            }
        }
    }),
    mH = W({
        position: {
            type: String,
            required: !0
        },
        size: {
            type: [Number, String],
            default: 300
        },
        modelValue: Boolean,
        ...Se(),
        ...Wl()
    }, "VLayoutItem"),
    hH = Z()({
        name: "VLayoutItem",
        props: mH(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                layoutItemStyles: a
            } = zl({
                id: e.name,
                order: C(() => parseInt(e.order, 10)),
                position: Y(e, "position"),
                elementSize: Y(e, "size"),
                layoutSize: Y(e, "size"),
                active: Y(e, "modelValue"),
                absolute: Y(e, "absolute")
            });
            return () => {
                var l;
                return m("div", {
                    class: ["v-layout-item", e.class],
                    style: [a.value, e.style]
                }, [(l = n.default) == null ? void 0 : l.call(n)])
            }
        }
    }),
    gH = W({
        modelValue: Boolean,
        options: {
            type: Object,
            default: () => ({
                root: void 0,
                rootMargin: void 0,
                threshold: void 0
            })
        },
        ...Se(),
        ...bt(),
        ...Ae(),
        ...Wn({
            transition: "fade-transition"
        })
    }, "VLazy"),
    yH = Z()({
        name: "VLazy",
        directives: {
            intersect: fi
        },
        props: gH(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                dimensionStyles: a
            } = pt(e), l = Ce(e, "modelValue");

            function r(o) {
                l.value || (l.value = o)
            }
            return ne(() => at(m(e.tag, {
                class: ["v-lazy", e.class],
                style: [a.value, e.style]
            }, {
                default: () => [l.value && m(jt, {
                    transition: e.transition,
                    appear: !0
                }, {
                    default: () => {
                        var o;
                        return [(o = n.default) == null ? void 0 : o.call(n)]
                    }
                })]
            }), [
                [tn("intersect"), {
                    handler: r,
                    options: e.options
                }, null]
            ])), {}
        }
    }),
    bH = W({
        locale: String,
        fallbackLocale: String,
        messages: Object,
        rtl: {
            type: Boolean,
            default: void 0
        },
        ...Se()
    }, "VLocaleProvider"),
    pH = Z()({
        name: "VLocaleProvider",
        props: bH(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                rtlClasses: a
            } = SM(e);
            return ne(() => {
                var l;
                return m("div", {
                    class: ["v-locale-provider", a.value, e.class],
                    style: e.style
                }, [(l = n.default) == null ? void 0 : l.call(n)])
            }), {}
        }
    }),
    _H = W({
        scrollable: Boolean,
        ...Se(),
        ...bt(),
        ...Ae({
            tag: "main"
        })
    }, "VMain"),
    SH = Z()({
        name: "VMain",
        props: _H(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                dimensionStyles: a
            } = pt(e), {
                mainStyles: l
            } = AS(), {
                ssrBootStyles: r
            } = Kl();
            return ne(() => m(e.tag, {
                class: ["v-main", {
                    "v-main--scrollable": e.scrollable
                }, e.class],
                style: [l.value, r.value, a.value, e.style]
            }, {
                default: () => {
                    var o, i;
                    return [e.scrollable ? m("div", {
                        class: "v-main__scroller"
                    }, [(o = n.default) == null ? void 0 : o.call(n)]) : (i = n.default) == null ? void 0 : i.call(n)]
                }
            })), {}
        }
    });

function wH(e) {
    let {
        rootEl: t,
        isSticky: n,
        layoutItemStyles: a
    } = e;
    const l = fe(!1),
        r = fe(0),
        o = C(() => {
            const u = typeof l.value == "boolean" ? "top" : l.value;
            return [n.value ? {
                top: "auto",
                bottom: "auto",
                height: void 0
            } : void 0, l.value ? {
                [u]: ge(r.value)
            } : {
                top: a.value.top
            }]
        });
    it(() => {
        de(n, u => {
            u ? window.addEventListener("scroll", s, {
                passive: !0
            }) : window.removeEventListener("scroll", s)
        }, {
            immediate: !0
        })
    }), Ct(() => {
        window.removeEventListener("scroll", s)
    });
    let i = 0;

    function s() {
        const u = i > window.scrollY ? "up" : "down",
            c = t.value.getBoundingClientRect(),
            d = parseFloat(a.value.top ? ? 0),
            f = window.scrollY - Math.max(0, r.value - d),
            v = c.height + Math.max(r.value, d) - window.scrollY - window.innerHeight,
            g = parseFloat(getComputedStyle(t.value).getPropertyValue("--v-body-scroll-y")) || 0;
        c.height < window.innerHeight - d ? (l.value = "top", r.value = d) : u === "up" && l.value === "bottom" || u === "down" && l.value === "top" ? (r.value = window.scrollY + c.top - g, l.value = !0) : u === "down" && v <= 0 ? (r.value = 0, l.value = "bottom") : u === "up" && f <= 0 && (g ? l.value !== "top" && (r.value = -f + g + d, l.value = "top") : (r.value = c.top + f, l.value = "top")), i = window.scrollY
    }
    return {
        isStuck: l,
        stickyStyles: o
    }
}
const kH = 100,
    CH = 20;

function Xy(e) {
    return (e < 0 ? -1 : 1) * Math.sqrt(Math.abs(e)) * 1.41421356237
}

function Jy(e) {
    if (e.length < 2) return 0;
    if (e.length === 2) return e[1].t === e[0].t ? 0 : (e[1].d - e[0].d) / (e[1].t - e[0].t);
    let t = 0;
    for (let n = e.length - 1; n > 0; n--) {
        if (e[n].t === e[n - 1].t) continue;
        const a = Xy(t),
            l = (e[n].d - e[n - 1].d) / (e[n].t - e[n - 1].t);
        t += (l - a) * Math.abs(l), n === e.length - 1 && (t *= .5)
    }
    return Xy(t) * 1e3
}

function xH() {
    const e = {};

    function t(l) {
        Array.from(l.changedTouches).forEach(r => {
            (e[r.identifier] ? ? (e[r.identifier] = new MD(CH))).push([l.timeStamp, r])
        })
    }

    function n(l) {
        Array.from(l.changedTouches).forEach(r => {
            delete e[r.identifier]
        })
    }

    function a(l) {
        var u;
        const r = (u = e[l]) == null ? void 0 : u.values().reverse();
        if (!r) throw new Error(`No samples for touch id ${l}`);
        const o = r[0],
            i = [],
            s = [];
        for (const c of r) {
            if (o[0] - c[0] > kH) break;
            i.push({
                t: c[0],
                d: c[1].clientX
            }), s.push({
                t: c[0],
                d: c[1].clientY
            })
        }
        return {
            x: Jy(i),
            y: Jy(s),
            get direction() {
                const {
                    x: c,
                    y: d
                } = this, [f, v] = [Math.abs(c), Math.abs(d)];
                return f > v && c >= 0 ? "right" : f > v && c <= 0 ? "left" : v > f && d >= 0 ? "down" : v > f && d <= 0 ? "up" : PH()
            }
        }
    }
    return {
        addMovement: t,
        endTouch: n,
        getVelocity: a
    }
}

function PH() {
    throw new Error
}

function EH(e) {
    let {
        el: t,
        isActive: n,
        isTemporary: a,
        width: l,
        touchless: r,
        position: o
    } = e;
    it(() => {
        window.addEventListener("touchstart", b, {
            passive: !0
        }), window.addEventListener("touchmove", p, {
            passive: !1
        }), window.addEventListener("touchend", _, {
            passive: !0
        })
    }), Ct(() => {
        window.removeEventListener("touchstart", b), window.removeEventListener("touchmove", p), window.removeEventListener("touchend", _)
    });
    const i = C(() => ["left", "right"].includes(o.value)),
        {
            addMovement: s,
            endTouch: u,
            getVelocity: c
        } = xH();
    let d = !1;
    const f = fe(!1),
        v = fe(0),
        g = fe(0);
    let h;

    function y(k, E) {
        return (o.value === "left" ? k : o.value === "right" ? document.documentElement.clientWidth - k : o.value === "top" ? k : o.value === "bottom" ? document.documentElement.clientHeight - k : or()) - (E ? l.value : 0)
    }

    function S(k) {
        let E = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
        const P = o.value === "left" ? (k - g.value) / l.value : o.value === "right" ? (document.documentElement.clientWidth - k - g.value) / l.value : o.value === "top" ? (k - g.value) / l.value : o.value === "bottom" ? (document.documentElement.clientHeight - k - g.value) / l.value : or();
        return E ? Math.max(0, Math.min(1, P)) : P
    }

    function b(k) {
        if (r.value) return;
        const E = k.changedTouches[0].clientX,
            P = k.changedTouches[0].clientY,
            x = 25,
            T = o.value === "left" ? E < x : o.value === "right" ? E > document.documentElement.clientWidth - x : o.value === "top" ? P < x : o.value === "bottom" ? P > document.documentElement.clientHeight - x : or(),
            V = n.value && (o.value === "left" ? E < l.value : o.value === "right" ? E > document.documentElement.clientWidth - l.value : o.value === "top" ? P < l.value : o.value === "bottom" ? P > document.documentElement.clientHeight - l.value : or());
        (T || V || n.value && a.value) && (h = [E, P], g.value = y(i.value ? E : P, n.value), v.value = S(i.value ? E : P), d = g.value > -20 && g.value < 80, u(k), s(k))
    }

    function p(k) {
        const E = k.changedTouches[0].clientX,
            P = k.changedTouches[0].clientY;
        if (d) {
            if (!k.cancelable) {
                d = !1;
                return
            }
            const T = Math.abs(E - h[0]),
                V = Math.abs(P - h[1]);
            (i.value ? T > V && T > 3 : V > T && V > 3) ? (f.value = !0, d = !1) : (i.value ? V : T) > 3 && (d = !1)
        }
        if (!f.value) return;
        k.preventDefault(), s(k);
        const x = S(i.value ? E : P, !1);
        v.value = Math.max(0, Math.min(1, x)), x > 1 ? g.value = y(i.value ? E : P, !0) : x < 0 && (g.value = y(i.value ? E : P, !1))
    }

    function _(k) {
        if (d = !1, !f.value) return;
        s(k), f.value = !1;
        const E = c(k.changedTouches[0].identifier),
            P = Math.abs(E.x),
            x = Math.abs(E.y);
        (i.value ? P > x && P > 400 : x > P && x > 3) ? n.value = E.direction === ({
            left: "right",
            right: "left",
            top: "down",
            bottom: "up"
        }[o.value] || or()): n.value = v.value > .5
    }
    const w = C(() => f.value ? {
        transform: o.value === "left" ? `translateX(calc(-100% + ${v.value*l.value}px))` : o.value === "right" ? `translateX(calc(100% - ${v.value*l.value}px))` : o.value === "top" ? `translateY(calc(-100% + ${v.value*l.value}px))` : o.value === "bottom" ? `translateY(calc(100% - ${v.value*l.value}px))` : or(),
        transition: "none"
    } : void 0);
    return Yt(f, () => {
        var P, x;
        const k = ((P = t.value) == null ? void 0 : P.style.transform) ? ? null,
            E = ((x = t.value) == null ? void 0 : x.style.transition) ? ? null;
        st(() => {
            var T, V, I, R;
            (V = t.value) == null || V.style.setProperty("transform", ((T = w.value) == null ? void 0 : T.transform) || "none"), (R = t.value) == null || R.style.setProperty("transition", ((I = w.value) == null ? void 0 : I.transition) || null)
        }), kt(() => {
            var T, V;
            (T = t.value) == null || T.style.setProperty("transform", k), (V = t.value) == null || V.style.setProperty("transition", E)
        })
    }), {
        isDragging: f,
        dragProgress: v,
        dragStyles: w
    }
}

function or() {
    throw new Error
}
const IH = ["start", "end", "left", "right", "top", "bottom"],
    TH = W({
        color: String,
        disableResizeWatcher: Boolean,
        disableRouteWatcher: Boolean,
        expandOnHover: Boolean,
        floating: Boolean,
        modelValue: {
            type: Boolean,
            default: null
        },
        permanent: Boolean,
        rail: {
            type: Boolean,
            default: null
        },
        railWidth: {
            type: [Number, String],
            default: 56
        },
        scrim: {
            type: [Boolean, String],
            default: !0
        },
        image: String,
        temporary: Boolean,
        persistent: Boolean,
        touchless: Boolean,
        width: {
            type: [Number, String],
            default: 256
        },
        location: {
            type: String,
            default: "start",
            validator: e => IH.includes(e)
        },
        sticky: Boolean,
        ...an(),
        ...Se(),
        ...em(),
        ...Ul({
            mobile: null
        }),
        ...Pt(),
        ...Wl(),
        ...rt(),
        ...Ae({
            tag: "nav"
        }),
        ...Ne()
    }, "VNavigationDrawer"),
    VH = Z()({
        name: "VNavigationDrawer",
        props: TH(),
        emits: {
            "update:modelValue": e => !0,
            "update:rail": e => !0
        },
        setup(e, t) {
            let {
                attrs: n,
                emit: a,
                slots: l
            } = t;
            const {
                isRtl: r
            } = xt(), {
                themeClasses: o
            } = je(e), {
                borderClasses: i
            } = Sn(e), {
                backgroundColorClasses: s,
                backgroundColorStyles: u
            } = Ke(Y(e, "color")), {
                elevationClasses: c
            } = Dt(e), {
                displayClasses: d,
                mobile: f
            } = On(e), {
                roundedClasses: v
            } = ct(e), g = US(), h = Ce(e, "modelValue", null, j => !!j), {
                ssrBootStyles: y
            } = Kl(), {
                scopeId: S
            } = Ql(), b = Q(), p = fe(!1), {
                runOpenDelay: _,
                runCloseDelay: w
            } = tm(e, j => {
                p.value = j
            }), k = C(() => e.rail && e.expandOnHover && p.value ? Number(e.width) : Number(e.rail ? e.railWidth : e.width)), E = C(() => Rd(e.location, r.value)), P = C(() => e.persistent), x = C(() => !e.permanent && (f.value || e.temporary)), T = C(() => e.sticky && !x.value && E.value !== "bottom");
            Yt(() => e.expandOnHover && e.rail != null, () => {
                de(p, j => a("update:rail", !j))
            }), Yt(() => !e.disableResizeWatcher, () => {
                de(x, j => !e.permanent && Re(() => h.value = !j))
            }), Yt(() => !e.disableRouteWatcher && !!g, () => {
                de(g.currentRoute, () => x.value && (h.value = !1))
            }), de(() => e.permanent, j => {
                j && (h.value = !0)
            }), e.modelValue == null && !x.value && (h.value = e.permanent || !f.value);
            const {
                isDragging: V,
                dragProgress: I
            } = EH({
                el: b,
                isActive: h,
                isTemporary: x,
                width: k,
                touchless: Y(e, "touchless"),
                position: E
            }), R = C(() => {
                const j = x.value ? 0 : e.rail && e.expandOnHover ? Number(e.railWidth) : k.value;
                return V.value ? j * I.value : j
            }), B = C(() => ["top", "bottom"].includes(e.location) ? 0 : k.value), {
                layoutItemStyles: $,
                layoutItemScrimStyles: D
            } = zl({
                id: e.name,
                order: C(() => parseInt(e.order, 10)),
                position: E,
                layoutSize: R,
                elementSize: B,
                active: C(() => h.value || V.value),
                disableTransitions: C(() => V.value),
                absolute: C(() => e.absolute || T.value && typeof z.value != "string")
            }), {
                isStuck: z,
                stickyStyles: N
            } = wH({
                rootEl: b,
                isSticky: T,
                layoutItemStyles: $
            }), H = Ke(C(() => typeof e.scrim == "string" ? e.scrim : null)), F = C(() => ({ ...V.value ? {
                    opacity: I.value * .2,
                    transition: "none"
                } : void 0,
                ...D.value
            }));
            return lt({
                VList: {
                    bgColor: "transparent"
                }
            }), ne(() => {
                const j = l.image || e.image;
                return m(ye, null, [m(e.tag, te({
                    ref: b,
                    onMouseenter: _,
                    onMouseleave: w,
                    class: ["v-navigation-drawer", `v-navigation-drawer--${E.value}`, {
                        "v-navigation-drawer--expand-on-hover": e.expandOnHover,
                        "v-navigation-drawer--floating": e.floating,
                        "v-navigation-drawer--is-hovering": p.value,
                        "v-navigation-drawer--rail": e.rail,
                        "v-navigation-drawer--temporary": x.value,
                        "v-navigation-drawer--persistent": P.value,
                        "v-navigation-drawer--active": h.value,
                        "v-navigation-drawer--sticky": T.value
                    }, o.value, s.value, i.value, d.value, c.value, v.value, e.class],
                    style: [u.value, $.value, y.value, N.value, e.style, ["top", "bottom"].includes(E.value) ? {
                        height: "auto"
                    } : {}]
                }, S, n), {
                    default: () => {
                        var ae, he, ve;
                        return [j && m("div", {
                            key: "image",
                            class: "v-navigation-drawer__img"
                        }, [l.image ? m(Ve, {
                            key: "image-defaults",
                            disabled: !e.image,
                            defaults: {
                                VImg: {
                                    alt: "",
                                    cover: !0,
                                    height: "inherit",
                                    src: e.image
                                }
                            }
                        }, l.image) : m(Ca, {
                            key: "image-img",
                            alt: "",
                            cover: !0,
                            height: "inherit",
                            src: e.image
                        }, null)]), l.prepend && m("div", {
                            class: "v-navigation-drawer__prepend"
                        }, [(ae = l.prepend) == null ? void 0 : ae.call(l)]), m("div", {
                            class: "v-navigation-drawer__content"
                        }, [(he = l.default) == null ? void 0 : he.call(l)]), l.append && m("div", {
                            class: "v-navigation-drawer__append"
                        }, [(ve = l.append) == null ? void 0 : ve.call(l)])]
                    }
                }), m(Tn, {
                    name: "fade-transition"
                }, {
                    default: () => [x.value && (V.value || h.value) && !!e.scrim && m("div", te({
                        class: ["v-navigation-drawer__scrim", H.backgroundColorClasses.value],
                        style: [F.value, H.backgroundColorStyles.value],
                        onClick: () => {
                            P.value || (h.value = !1)
                        }
                    }, S), null)]
                })])
            }), {
                isStuck: z
            }
        }
    }),
    AH = pn({
        name: "VNoSsr",
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Lw();
            return () => {
                var l;
                return a.value && ((l = n.default) == null ? void 0 : l.call(n))
            }
        }
    }),
    LH = W({
        autofocus: Boolean,
        divider: String,
        focusAll: Boolean,
        label: {
            type: String,
            default: "$vuetify.input.otp"
        },
        length: {
            type: [Number, String],
            default: 6
        },
        modelValue: {
            type: [Number, String],
            default: void 0
        },
        placeholder: String,
        type: {
            type: String,
            default: "number"
        },
        ...bt(),
        ...qr(),
        ...wu(bi({
            variant: "outlined"
        }), ["baseColor", "bgColor", "class", "color", "disabled", "error", "loading", "rounded", "style", "theme", "variant"])
    }, "VOtpInput"),
    OH = Z()({
        name: "VOtpInput",
        props: LH(),
        emits: {
            finish: e => !0,
            "update:focused": e => !0,
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                attrs: n,
                emit: a,
                slots: l
            } = t;
            const {
                dimensionStyles: r
            } = pt(e), {
                isFocused: o,
                focus: i,
                blur: s
            } = ua(e), u = Ce(e, "modelValue", "", P => P == null ? [] : String(P).split(""), P => P.join("")), {
                t: c
            } = Qe(), d = C(() => Number(e.length)), f = C(() => Array(d.value).fill(0)), v = Q(-1), g = Q(), h = Q([]), y = C(() => h.value[v.value]);

            function S() {
                if (E(y.value.value)) {
                    y.value.value = "";
                    return
                }
                const P = u.value.slice(),
                    x = y.value.value;
                P[v.value] = x;
                let T = null;
                v.value > u.value.length ? T = u.value.length + 1 : v.value + 1 !== d.value && (T = "next"), u.value = P, T && xl(g.value, T)
            }

            function b(P) {
                const x = u.value.slice(),
                    T = v.value;
                let V = null;
                ["ArrowLeft", "ArrowRight", "Backspace", "Delete"].includes(P.key) && (P.preventDefault(), P.key === "ArrowLeft" ? V = "prev" : P.key === "ArrowRight" ? V = "next" : ["Backspace", "Delete"].includes(P.key) && (x[v.value] = "", u.value = x, v.value > 0 && P.key === "Backspace" ? V = "prev" : requestAnimationFrame(() => {
                    var I;
                    (I = h.value[T]) == null || I.select()
                })), requestAnimationFrame(() => {
                    V != null && xl(g.value, V)
                }))
            }

            function p(P, x) {
                var V, I;
                x.preventDefault(), x.stopPropagation();
                const T = ((V = x == null ? void 0 : x.clipboardData) == null ? void 0 : V.getData("Text").slice(0, d.value)) ? ? "";
                E(T) || (u.value = T.split(""), (I = h.value) == null || I[P].blur())
            }

            function _() {
                u.value = []
            }

            function w(P, x) {
                i(), v.value = x
            }

            function k() {
                s(), v.value = -1
            }

            function E(P) {
                return e.type === "number" && /[^0-9]/g.test(P)
            }
            return lt({
                VField: {
                    color: C(() => e.color),
                    bgColor: C(() => e.color),
                    baseColor: C(() => e.baseColor),
                    disabled: C(() => e.disabled),
                    error: C(() => e.error),
                    variant: C(() => e.variant)
                }
            }, {
                scoped: !0
            }), de(u, P => {
                P.length === d.value && a("finish", P.join(""))
            }, {
                deep: !0
            }), de(v, P => {
                P < 0 || Re(() => {
                    var x;
                    (x = h.value[P]) == null || x.select()
                })
            }), ne(() => {
                var T;
                const [P, x] = al(n);
                return m("div", te({
                    class: ["v-otp-input", {
                        "v-otp-input--divided": !!e.divider
                    }, e.class],
                    style: [e.style]
                }, P), [m("div", {
                    ref: g,
                    class: "v-otp-input__content",
                    style: [r.value]
                }, [f.value.map((V, I) => m(ye, null, [e.divider && I !== 0 && m("span", {
                    class: "v-otp-input__divider"
                }, [e.divider]), m(Xr, {
                    focused: o.value && e.focusAll || v.value === I,
                    key: I
                }, { ...l,
                    loader: void 0,
                    default: () => m("input", {
                        ref: R => h.value[I] = R,
                        "aria-label": c(e.label, I + 1),
                        autofocus: I === 0 && e.autofocus,
                        autocomplete: "one-time-code",
                        class: ["v-otp-input__field"],
                        disabled: e.disabled,
                        inputmode: e.type === "number" ? "numeric" : "text",
                        min: e.type === "number" ? 0 : void 0,
                        maxlength: "1",
                        placeholder: e.placeholder,
                        type: e.type === "number" ? "text" : e.type,
                        value: u.value[I],
                        onInput: S,
                        onFocus: R => w(R, I),
                        onBlur: k,
                        onKeydown: b,
                        onPaste: R => p(I, R)
                    }, null)
                })])), m("input", te({
                    class: "v-otp-input-input",
                    type: "hidden"
                }, x, {
                    value: u.value.join("")
                }), null), m(ea, {
                    contained: !0,
                    "content-class": "v-otp-input__loader",
                    "model-value": !!e.loading,
                    persistent: !0
                }, {
                    default: () => {
                        var V;
                        return [((V = l.loader) == null ? void 0 : V.call(l)) ? ? m(Ja, {
                            color: typeof e.loading == "boolean" ? void 0 : e.loading,
                            indeterminate: !0,
                            size: "24",
                            width: "2"
                        }, null)]
                    }
                }), (T = l.default) == null ? void 0 : T.call(l)])])
            }), {
                blur: () => {
                    var P;
                    (P = h.value) == null || P.some(x => x.blur())
                },
                focus: () => {
                    var P;
                    (P = h.value) == null || P[0].focus()
                },
                reset: _,
                isFocused: o
            }
        }
    });

function RH(e) {
    return Math.floor(Math.abs(e)) * Math.sign(e)
}
const DH = W({
        scale: {
            type: [Number, String],
            default: .5
        },
        ...Se()
    }, "VParallax"),
    MH = Z()({
        name: "VParallax",
        props: DH(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                intersectionRef: a,
                isIntersecting: l
            } = Au(), {
                resizeRef: r,
                contentRect: o
            } = Hn(), {
                height: i
            } = On(), s = Q();
            st(() => {
                var v;
                a.value = r.value = (v = s.value) == null ? void 0 : v.$el
            });
            let u;
            de(l, v => {
                v ? (u = Nv(a.value), u = u === document.scrollingElement ? document : u, u.addEventListener("scroll", f, {
                    passive: !0
                }), f()) : u.removeEventListener("scroll", f)
            }), Ct(() => {
                u == null || u.removeEventListener("scroll", f)
            }), de(i, f), de(() => {
                var v;
                return (v = o.value) == null ? void 0 : v.height
            }, f);
            const c = C(() => 1 - ot(+e.scale));
            let d = -1;

            function f() {
                l.value && (cancelAnimationFrame(d), d = requestAnimationFrame(() => {
                    var w;
                    const v = ((w = s.value) == null ? void 0 : w.$el).querySelector(".v-img__img");
                    if (!v) return;
                    const g = u instanceof Document ? document.documentElement.clientHeight : u.clientHeight,
                        h = u instanceof Document ? window.scrollY : u.scrollTop,
                        y = a.value.getBoundingClientRect().top + h,
                        S = o.value.height,
                        b = y + (S - g) / 2,
                        p = RH((h - b) * c.value),
                        _ = Math.max(1, (c.value * (g - S) + S) / S);
                    v.style.setProperty("transform", `translateY(${p}px) scale(${_})`)
                }))
            }
            return ne(() => m(Ca, {
                class: ["v-parallax", {
                    "v-parallax--active": l.value
                }, e.class],
                style: e.style,
                ref: s,
                cover: !0,
                onLoadstart: f,
                onLoad: f
            }, n)), {}
        }
    }),
    NH = W({ ...Du({
            falseIcon: "$radioOff",
            trueIcon: "$radioOn"
        })
    }, "VRadio"),
    $H = Z()({
        name: "VRadio",
        props: NH(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            return ne(() => {
                const a = Za.filterProps(e);
                return m(Za, te(a, {
                    class: ["v-radio", e.class],
                    style: e.style,
                    type: "radio"
                }), n)
            }), {}
        }
    }),
    BH = W({
        height: {
            type: [Number, String],
            default: "auto"
        },
        ...Ta(),
        ...We(Yv(), ["multiple"]),
        trueIcon: {
            type: Pe,
            default: "$radioOn"
        },
        falseIcon: {
            type: Pe,
            default: "$radioOff"
        },
        type: {
            type: String,
            default: "radio"
        }
    }, "VRadioGroup"),
    FH = Z()({
        name: "VRadioGroup",
        inheritAttrs: !1,
        props: BH(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                attrs: n,
                slots: a
            } = t;
            const l = Rt(),
                r = C(() => e.id || `radio-group-${l}`),
                o = Ce(e, "modelValue");
            return ne(() => {
                const [i, s] = al(n), u = $t.filterProps(e), c = Za.filterProps(e), d = a.label ? a.label({
                    label: e.label,
                    props: {
                        for: r.value
                    }
                }) : e.label;
                return m($t, te({
                    class: ["v-radio-group", e.class],
                    style: e.style
                }, i, u, {
                    modelValue: o.value,
                    "onUpdate:modelValue": f => o.value = f,
                    id: r.value
                }), { ...a,
                    default: f => {
                        let {
                            id: v,
                            messagesId: g,
                            isDisabled: h,
                            isReadonly: y
                        } = f;
                        return m(ye, null, [d && m(Yr, {
                            id: v.value
                        }, {
                            default: () => [d]
                        }), m(ew, te(c, {
                            id: v.value,
                            "aria-describedby": g.value,
                            defaultsTarget: "VRadio",
                            trueIcon: e.trueIcon,
                            falseIcon: e.falseIcon,
                            type: e.type,
                            disabled: h.value,
                            readonly: y.value,
                            "aria-labelledby": d ? v.value : void 0,
                            multiple: !1
                        }, s, {
                            modelValue: o.value,
                            "onUpdate:modelValue": S => o.value = S
                        }), a)])
                    }
                })
            }), {}
        }
    }),
    HH = W({ ...qr(),
        ...Ta(),
        ...ek(),
        strict: Boolean,
        modelValue: {
            type: Array,
            default: () => [0, 0]
        }
    }, "VRangeSlider"),
    jH = Z()({
        name: "VRangeSlider",
        props: HH(),
        emits: {
            "update:focused": e => !0,
            "update:modelValue": e => !0,
            end: e => !0,
            start: e => !0
        },
        setup(e, t) {
            let {
                slots: n,
                emit: a
            } = t;
            const l = Q(),
                r = Q(),
                o = Q(),
                {
                    rtlClasses: i
                } = xt();

            function s(T) {
                if (!l.value || !r.value) return;
                const V = Qd(T, l.value.$el, e.direction),
                    I = Qd(T, r.value.$el, e.direction),
                    R = Math.abs(V),
                    B = Math.abs(I);
                return R < B || R === B && V < 0 ? l.value.$el : r.value.$el
            }
            const u = tk(e),
                c = Ce(e, "modelValue", void 0, T => T != null && T.length ? T.map(V => u.roundValue(V)) : [0, 0]),
                {
                    activeThumbRef: d,
                    hasLabels: f,
                    max: v,
                    min: g,
                    mousePressed: h,
                    onSliderMousedown: y,
                    onSliderTouchstart: S,
                    position: b,
                    trackContainerRef: p,
                    readonly: _
                } = nk({
                    props: e,
                    steps: u,
                    onSliderStart: () => {
                        a("start", c.value)
                    },
                    onSliderEnd: T => {
                        var R;
                        let {
                            value: V
                        } = T;
                        const I = d.value === ((R = l.value) == null ? void 0 : R.$el) ? [V, c.value[1]] : [c.value[0], V];
                        !e.strict && I[0] < I[1] && (c.value = I), a("end", c.value)
                    },
                    onSliderMove: T => {
                        var B, $, D, z;
                        let {
                            value: V
                        } = T;
                        const [I, R] = c.value;
                        !e.strict && I === R && I !== g.value && (d.value = V > I ? (B = r.value) == null ? void 0 : B.$el : ($ = l.value) == null ? void 0 : $.$el, (D = d.value) == null || D.focus()), d.value === ((z = l.value) == null ? void 0 : z.$el) ? c.value = [Math.min(V, R), R] : c.value = [I, Math.max(I, V)]
                    },
                    getActiveThumb: s
                }),
                {
                    isFocused: w,
                    focus: k,
                    blur: E
                } = ua(e),
                P = C(() => b(c.value[0])),
                x = C(() => b(c.value[1]));
            return ne(() => {
                const T = $t.filterProps(e),
                    V = !!(e.label || n.label || n.prepend);
                return m($t, te({
                    class: ["v-slider", "v-range-slider", {
                        "v-slider--has-labels": !!n["tick-label"] || f.value,
                        "v-slider--focused": w.value,
                        "v-slider--pressed": h.value,
                        "v-slider--disabled": e.disabled
                    }, i.value, e.class],
                    style: e.style,
                    ref: o
                }, T, {
                    focused: w.value
                }), { ...n,
                    prepend: V ? I => {
                        var R, B;
                        return m(ye, null, [((R = n.label) == null ? void 0 : R.call(n, I)) ? ? (e.label ? m(Yr, {
                            class: "v-slider__label",
                            text: e.label
                        }, null) : void 0), (B = n.prepend) == null ? void 0 : B.call(n, I)])
                    } : void 0,
                    default: I => {
                        var $, D;
                        let {
                            id: R,
                            messagesId: B
                        } = I;
                        return m("div", {
                            class: "v-slider__container",
                            onMousedown: _.value ? void 0 : y,
                            onTouchstartPassive: _.value ? void 0 : S
                        }, [m("input", {
                            id: `${R.value}_start`,
                            name: e.name || R.value,
                            disabled: !!e.disabled,
                            readonly: !!e.readonly,
                            tabindex: "-1",
                            value: c.value[0]
                        }, null), m("input", {
                            id: `${R.value}_stop`,
                            name: e.name || R.value,
                            disabled: !!e.disabled,
                            readonly: !!e.readonly,
                            tabindex: "-1",
                            value: c.value[1]
                        }, null), m(ak, {
                            ref: p,
                            start: P.value,
                            stop: x.value
                        }, {
                            "tick-label": n["tick-label"]
                        }), m(ef, {
                            ref: l,
                            "aria-describedby": B.value,
                            focused: w && d.value === (($ = l.value) == null ? void 0 : $.$el),
                            modelValue: c.value[0],
                            "onUpdate:modelValue": z => c.value = [z, c.value[1]],
                            onFocus: z => {
                                var N, H, F, j;
                                k(), d.value = (N = l.value) == null ? void 0 : N.$el, c.value[0] === c.value[1] && c.value[1] === g.value && z.relatedTarget !== ((H = r.value) == null ? void 0 : H.$el) && ((F = l.value) == null || F.$el.blur(), (j = r.value) == null || j.$el.focus())
                            },
                            onBlur: () => {
                                E(), d.value = void 0
                            },
                            min: g.value,
                            max: c.value[1],
                            position: P.value,
                            ripple: e.ripple
                        }, {
                            "thumb-label": n["thumb-label"]
                        }), m(ef, {
                            ref: r,
                            "aria-describedby": B.value,
                            focused: w && d.value === ((D = r.value) == null ? void 0 : D.$el),
                            modelValue: c.value[1],
                            "onUpdate:modelValue": z => c.value = [c.value[0], z],
                            onFocus: z => {
                                var N, H, F, j;
                                k(), d.value = (N = r.value) == null ? void 0 : N.$el, c.value[0] === c.value[1] && c.value[0] === v.value && z.relatedTarget !== ((H = l.value) == null ? void 0 : H.$el) && ((F = r.value) == null || F.$el.blur(), (j = l.value) == null || j.$el.focus())
                            },
                            onBlur: () => {
                                E(), d.value = void 0
                            },
                            min: c.value[0],
                            max: v.value,
                            position: x.value,
                            ripple: e.ripple
                        }, {
                            "thumb-label": n["thumb-label"]
                        })])
                    }
                })
            }), {}
        }
    }),
    UH = W({
        name: String,
        itemAriaLabel: {
            type: String,
            default: "$vuetify.rating.ariaLabel.item"
        },
        activeColor: String,
        color: String,
        clearable: Boolean,
        disabled: Boolean,
        emptyIcon: {
            type: Pe,
            default: "$ratingEmpty"
        },
        fullIcon: {
            type: Pe,
            default: "$ratingFull"
        },
        halfIncrements: Boolean,
        hover: Boolean,
        length: {
            type: [Number, String],
            default: 5
        },
        readonly: Boolean,
        modelValue: {
            type: [Number, String],
            default: 0
        },
        itemLabels: Array,
        itemLabelPosition: {
            type: String,
            default: "top",
            validator: e => ["top", "bottom"].includes(e)
        },
        ripple: Boolean,
        ...Se(),
        ...Vt(),
        ...sa(),
        ...Ae(),
        ...Ne()
    }, "VRating"),
    WH = Z()({
        name: "VRating",
        props: UH(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                t: a
            } = Qe(), {
                themeClasses: l
            } = je(e), r = Ce(e, "modelValue"), o = C(() => ot(parseFloat(r.value), 0, +e.length)), i = C(() => fn(Number(e.length), 1)), s = C(() => i.value.flatMap(h => e.halfIncrements ? [h - .5, h] : [h])), u = fe(-1), c = C(() => s.value.map(h => {
                const y = e.hover && u.value > -1,
                    S = o.value >= h,
                    b = u.value >= h,
                    _ = (y ? b : S) ? e.fullIcon : e.emptyIcon,
                    w = e.activeColor ? ? e.color,
                    k = S || b ? w : e.color;
                return {
                    isFilled: S,
                    isHovered: b,
                    icon: _,
                    color: k
                }
            })), d = C(() => [0, ...s.value].map(h => {
                function y() {
                    u.value = h
                }

                function S() {
                    u.value = -1
                }

                function b() {
                    e.disabled || e.readonly || (r.value = o.value === h && e.clearable ? 0 : h)
                }
                return {
                    onMouseenter: e.hover ? y : void 0,
                    onMouseleave: e.hover ? S : void 0,
                    onClick: b
                }
            })), f = C(() => e.name ? ? `v-rating-${Rt()}`);

            function v(h) {
                var P, x;
                let {
                    value: y,
                    index: S,
                    showStar: b = !0
                } = h;
                const {
                    onMouseenter: p,
                    onMouseleave: _,
                    onClick: w
                } = d.value[S + 1], k = `${f.value}-${String(y).replace(".","-")}`, E = {
                    color: (P = c.value[S]) == null ? void 0 : P.color,
                    density: e.density,
                    disabled: e.disabled,
                    icon: (x = c.value[S]) == null ? void 0 : x.icon,
                    ripple: e.ripple,
                    size: e.size,
                    variant: "plain"
                };
                return m(ye, null, [m("label", {
                    for: k,
                    class: {
                        "v-rating__item--half": e.halfIncrements && y % 1 > 0, "v-rating__item--full": e.halfIncrements && y % 1 === 0
                    },
                    onMouseenter: p,
                    onMouseleave: _,
                    onClick: w
                }, [m("span", {
                    class: "v-rating__hidden"
                }, [a(e.itemAriaLabel, y, e.length)]), b ? n.item ? n.item({ ...c.value[S],
                    props: E,
                    value: y,
                    index: S,
                    rating: o.value
                }) : m(Le, te({
                    "aria-label": a(e.itemAriaLabel, y, e.length)
                }, E), null) : void 0]), m("input", {
                    class: "v-rating__hidden",
                    name: f.value,
                    id: k,
                    type: "radio",
                    value: y,
                    checked: o.value === y,
                    tabindex: -1,
                    readonly: e.readonly,
                    disabled: e.disabled
                }, null)])
            }

            function g(h) {
                return n["item-label"] ? n["item-label"](h) : h.label ? m("span", null, [h.label]) : m("span", null, [hn(" ")])
            }
            return ne(() => {
                var y;
                const h = !!((y = e.itemLabels) != null && y.length) || n["item-label"];
                return m(e.tag, {
                    class: ["v-rating", {
                        "v-rating--hover": e.hover,
                        "v-rating--readonly": e.readonly
                    }, l.value, e.class],
                    style: e.style
                }, {
                    default: () => [m(v, {
                        value: 0,
                        index: -1,
                        showStar: !1
                    }, null), i.value.map((S, b) => {
                        var p, _;
                        return m("div", {
                            class: "v-rating__wrapper"
                        }, [h && e.itemLabelPosition === "top" ? g({
                            value: S,
                            index: b,
                            label: (p = e.itemLabels) == null ? void 0 : p[b]
                        }) : void 0, m("div", {
                            class: "v-rating__item"
                        }, [e.halfIncrements ? m(ye, null, [m(v, {
                            value: S - .5,
                            index: b * 2
                        }, null), m(v, {
                            value: S,
                            index: b * 2 + 1
                        }, null)]) : m(v, {
                            value: S,
                            index: b
                        }, null)]), h && e.itemLabelPosition === "bottom" ? g({
                            value: S,
                            index: b,
                            label: (_ = e.itemLabels) == null ? void 0 : _[b]
                        }) : void 0])
                    })]
                })
            }), {}
        }
    }),
    zH = {
        actions: "button@2",
        article: "heading, paragraph",
        avatar: "avatar",
        button: "button",
        card: "image, heading",
        "card-avatar": "image, list-item-avatar",
        chip: "chip",
        "date-picker": "list-item, heading, divider, date-picker-options, date-picker-days, actions",
        "date-picker-options": "text, avatar@2",
        "date-picker-days": "avatar@28",
        divider: "divider",
        heading: "heading",
        image: "image",
        "list-item": "text",
        "list-item-avatar": "avatar, text",
        "list-item-two-line": "sentences",
        "list-item-avatar-two-line": "avatar, sentences",
        "list-item-three-line": "paragraph",
        "list-item-avatar-three-line": "avatar, paragraph",
        ossein: "ossein",
        paragraph: "text@3",
        sentences: "text@2",
        subtitle: "text",
        table: "table-heading, table-thead, table-tbody, table-tfoot",
        "table-heading": "chip, text",
        "table-thead": "heading@6",
        "table-tbody": "table-row-divider@6",
        "table-row-divider": "table-row, divider",
        "table-row": "text@6",
        "table-tfoot": "text@2, avatar@2",
        text: "text"
    };

function KH(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return m("div", {
        class: ["v-skeleton-loader__bone", `v-skeleton-loader__${e}`]
    }, [t])
}

function Zy(e) {
    const [t, n] = e.split("@");
    return Array.from({
        length: n
    }).map(() => Xu(t))
}

function Xu(e) {
    let t = [];
    if (!e) return t;
    const n = zH[e];
    if (e !== n) {
        if (e.includes(",")) return Qy(e);
        if (e.includes("@")) return Zy(e);
        n.includes(",") ? t = Qy(n) : n.includes("@") ? t = Zy(n) : n && t.push(Xu(n))
    }
    return [KH(e, t)]
}

function Qy(e) {
    return e.replace(/\s/g, "").split(",").map(Xu)
}
const GH = W({
        boilerplate: Boolean,
        color: String,
        loading: Boolean,
        loadingText: {
            type: String,
            default: "$vuetify.loading"
        },
        type: {
            type: [String, Array],
            default: "ossein"
        },
        ...bt(),
        ...Pt(),
        ...Ne()
    }, "VSkeletonLoader"),
    YH = Z()({
        name: "VSkeletonLoader",
        props: GH(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                backgroundColorClasses: a,
                backgroundColorStyles: l
            } = Ke(Y(e, "color")), {
                dimensionStyles: r
            } = pt(e), {
                elevationClasses: o
            } = Dt(e), {
                themeClasses: i
            } = je(e), {
                t: s
            } = Qe(), u = C(() => Xu(nt(e.type).join(",")));
            return ne(() => {
                var f;
                const c = !n.default || e.loading,
                    d = e.boilerplate || !c ? {} : {
                        ariaLive: "polite",
                        ariaLabel: s(e.loadingText),
                        role: "alert"
                    };
                return m("div", te({
                    class: ["v-skeleton-loader", {
                        "v-skeleton-loader--boilerplate": e.boilerplate
                    }, i.value, a.value, o.value],
                    style: [l.value, c ? r.value : {}]
                }, d), [c ? u.value : (f = n.default) == null ? void 0 : f.call(n)])
            }), {}
        }
    }),
    qH = Z()({
        name: "VSlideGroupItem",
        props: ql(),
        emits: {
            "group:selected": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Xl(e, uw);
            return () => {
                var l;
                return (l = n.default) == null ? void 0 : l.call(n, {
                    isSelected: a.isSelected.value,
                    select: a.select,
                    toggle: a.toggle,
                    selectedClass: a.selectedClass.value
                })
            }
        }
    });

function XH(e) {
    const t = fe(e());
    let n = -1;

    function a() {
        clearInterval(n)
    }

    function l() {
        a(), Re(() => t.value = e())
    }

    function r(o) {
        const i = o ? getComputedStyle(o) : {
                transitionDuration: .2
            },
            s = parseFloat(i.transitionDuration) * 1e3 || 200;
        if (a(), t.value <= 0) return;
        const u = performance.now();
        n = window.setInterval(() => {
            const c = performance.now() - u + s;
            t.value = Math.max(e() - c, 0), t.value <= 0 && a()
        }, s)
    }
    return kt(a), {
        clear: a,
        time: t,
        start: r,
        reset: l
    }
}
const Jk = W({
        multiLine: Boolean,
        text: String,
        timer: [Boolean, String],
        timeout: {
            type: [Number, String],
            default: 5e3
        },
        vertical: Boolean,
        ...Ea({
            location: "bottom"
        }),
        ...zr(),
        ...rt(),
        ...Rn(),
        ...Ne(),
        ...We(yi({
            transition: "v-snackbar-transition"
        }), ["persistent", "noClickAnimation", "scrim", "scrollStrategy"])
    }, "VSnackbar"),
    gf = Z()({
        name: "VSnackbar",
        props: Jk(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Ce(e, "modelValue"),
                {
                    positionClasses: l
                } = Kr(e),
                {
                    scopeId: r
                } = Ql(),
                {
                    themeClasses: o
                } = je(e),
                {
                    colorClasses: i,
                    colorStyles: s,
                    variantClasses: u
                } = Gl(e),
                {
                    roundedClasses: c
                } = ct(e),
                d = XH(() => Number(e.timeout)),
                f = Q(),
                v = Q(),
                g = fe(!1),
                h = fe(0),
                y = Q(),
                S = Te(Ho, void 0);
            Yt(() => !!S, () => {
                const V = AS();
                st(() => {
                    y.value = V.mainStyles.value
                })
            }), de(a, p), de(() => e.timeout, p), it(() => {
                a.value && p()
            });
            let b = -1;

            function p() {
                d.reset(), window.clearTimeout(b);
                const V = Number(e.timeout);
                if (!a.value || V === -1) return;
                const I = Tv(v.value);
                d.start(I), b = window.setTimeout(() => {
                    a.value = !1
                }, V)
            }

            function _() {
                d.reset(), window.clearTimeout(b)
            }

            function w() {
                g.value = !0, _()
            }

            function k() {
                g.value = !1, p()
            }

            function E(V) {
                h.value = V.touches[0].clientY
            }

            function P(V) {
                Math.abs(h.value - V.changedTouches[0].clientY) > 50 && (a.value = !1)
            }

            function x() {
                g.value && k()
            }
            const T = C(() => e.location.split(" ").reduce((V, I) => (V[`v-snackbar--${I}`] = !0, V), {}));
            return ne(() => {
                const V = ea.filterProps(e),
                    I = !!(n.default || n.text || e.text);
                return m(ea, te({
                    ref: f,
                    class: ["v-snackbar", {
                        "v-snackbar--active": a.value,
                        "v-snackbar--multi-line": e.multiLine && !e.vertical,
                        "v-snackbar--timer": !!e.timer,
                        "v-snackbar--vertical": e.vertical
                    }, T.value, l.value, e.class],
                    style: [y.value, e.style]
                }, V, {
                    modelValue: a.value,
                    "onUpdate:modelValue": R => a.value = R,
                    contentProps: te({
                        class: ["v-snackbar__wrapper", o.value, i.value, c.value, u.value],
                        style: [s.value],
                        onPointerenter: w,
                        onPointerleave: k
                    }, V.contentProps),
                    persistent: !0,
                    noClickAnimation: !0,
                    scrim: !1,
                    scrollStrategy: "none",
                    _disableGlobalStack: !0,
                    onTouchstartPassive: E,
                    onTouchend: P,
                    onAfterLeave: x
                }, r), {
                    default: () => {
                        var R, B;
                        return [ll(!1, "v-snackbar"), e.timer && !g.value && m("div", {
                            key: "timer",
                            class: "v-snackbar__timer"
                        }, [m(Lu, {
                            ref: v,
                            color: typeof e.timer == "string" ? e.timer : "info",
                            max: e.timeout,
                            "model-value": d.time.value
                        }, null)]), I && m("div", {
                            key: "content",
                            class: "v-snackbar__content",
                            role: "status",
                            "aria-live": "polite"
                        }, [((R = n.text) == null ? void 0 : R.call(n)) ? ? e.text, (B = n.default) == null ? void 0 : B.call(n)]), n.actions && m(Ve, {
                            defaults: {
                                VBtn: {
                                    variant: "text",
                                    ripple: !1,
                                    slim: !0
                                }
                            }
                        }, {
                            default: () => [m("div", {
                                class: "v-snackbar__actions"
                            }, [n.actions({
                                isActive: a
                            })])]
                        })]
                    },
                    activator: n.activator
                })
            }), wn({}, f)
        }
    }),
    Zk = W({
        autoDraw: Boolean,
        autoDrawDuration: [Number, String],
        autoDrawEasing: {
            type: String,
            default: "ease"
        },
        color: String,
        gradient: {
            type: Array,
            default: () => []
        },
        gradientDirection: {
            type: String,
            validator: e => ["top", "bottom", "left", "right"].includes(e),
            default: "top"
        },
        height: {
            type: [String, Number],
            default: 75
        },
        labels: {
            type: Array,
            default: () => []
        },
        labelSize: {
            type: [Number, String],
            default: 7
        },
        lineWidth: {
            type: [String, Number],
            default: 4
        },
        id: String,
        itemValue: {
            type: String,
            default: "value"
        },
        modelValue: {
            type: Array,
            default: () => []
        },
        min: [String, Number],
        max: [String, Number],
        padding: {
            type: [String, Number],
            default: 8
        },
        showLabels: Boolean,
        smooth: Boolean,
        width: {
            type: [Number, String],
            default: 300
        }
    }, "Line"),
    Qk = W({
        autoLineWidth: Boolean,
        ...Zk()
    }, "VBarline"),
    eb = Z()({
        name: "VBarline",
        props: Qk(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Rt(),
                l = C(() => e.id || `barline-${a}`),
                r = C(() => Number(e.autoDrawDuration) || 500),
                o = C(() => !!(e.showLabels || e.labels.length > 0 || n != null && n.label)),
                i = C(() => parseFloat(e.lineWidth) || 4),
                s = C(() => Math.max(e.modelValue.length * i.value, Number(e.width))),
                u = C(() => ({
                    minX: 0,
                    maxX: s.value,
                    minY: 0,
                    maxY: parseInt(e.height, 10)
                })),
                c = C(() => e.modelValue.map(h => vt(h, e.itemValue, h)));

            function d(h, y) {
                const {
                    minX: S,
                    maxX: b,
                    minY: p,
                    maxY: _
                } = y, w = h.length;
                let k = e.max != null ? Number(e.max) : Math.max(...h),
                    E = e.min != null ? Number(e.min) : Math.min(...h);
                E > 0 && e.min == null && (E = 0), k < 0 && e.max == null && (k = 0);
                const P = b / w,
                    x = (_ - p) / (k - E || 1),
                    T = _ - Math.abs(E * x);
                return h.map((V, I) => {
                    const R = Math.abs(x * V);
                    return {
                        x: S + I * P,
                        y: T - R + +(V < 0) * R,
                        height: R,
                        value: V
                    }
                })
            }
            const f = C(() => {
                    const h = [],
                        y = d(c.value, u.value),
                        S = y.length;
                    for (let b = 0; h.length < S; b++) {
                        const p = y[b];
                        let _ = e.labels[b];
                        _ || (_ = typeof p == "object" ? p.value : p), h.push({
                            x: p.x,
                            value: String(_)
                        })
                    }
                    return h
                }),
                v = C(() => d(c.value, u.value)),
                g = C(() => (Math.abs(v.value[0].x - v.value[1].x) - i.value) / 2);
            ne(() => {
                const h = e.gradient.slice().length ? e.gradient.slice().reverse() : [""];
                return m("svg", {
                    display: "block"
                }, [m("defs", null, [m("linearGradient", {
                    id: l.value,
                    gradientUnits: "userSpaceOnUse",
                    x1: e.gradientDirection === "left" ? "100%" : "0",
                    y1: e.gradientDirection === "top" ? "100%" : "0",
                    x2: e.gradientDirection === "right" ? "100%" : "0",
                    y2: e.gradientDirection === "bottom" ? "100%" : "0"
                }, [h.map((y, S) => m("stop", {
                    offset: S / Math.max(h.length - 1, 1),
                    "stop-color": y || "currentColor"
                }, null))])]), m("clipPath", {
                    id: `${l.value}-clip`
                }, [v.value.map(y => m("rect", {
                    x: y.x + g.value,
                    y: y.y,
                    width: i.value,
                    height: y.height,
                    rx: typeof e.smooth == "number" ? e.smooth : e.smooth ? 2 : 0,
                    ry: typeof e.smooth == "number" ? e.smooth : e.smooth ? 2 : 0
                }, [e.autoDraw && m(ye, null, [m("animate", {
                    attributeName: "y",
                    from: y.y + y.height,
                    to: y.y,
                    dur: `${r.value}ms`,
                    fill: "freeze"
                }, null), m("animate", {
                    attributeName: "height",
                    from: "0",
                    to: y.height,
                    dur: `${r.value}ms`,
                    fill: "freeze"
                }, null)])]))]), o.value && m("g", {
                    key: "labels",
                    style: {
                        textAnchor: "middle",
                        dominantBaseline: "mathematical",
                        fill: "currentColor"
                    }
                }, [f.value.map((y, S) => {
                    var b;
                    return m("text", {
                        x: y.x + g.value + i.value / 2,
                        y: parseInt(e.height, 10) - 2 + (parseInt(e.labelSize, 10) || 7 * .75),
                        "font-size": Number(e.labelSize) || 7
                    }, [((b = n.label) == null ? void 0 : b.call(n, {
                        index: S,
                        value: y.value
                    })) ? ? y.value])
                })]), m("g", {
                    "clip-path": `url(#${l.value}-clip)`,
                    fill: `url(#${l.value})`
                }, [m("rect", {
                    x: 0,
                    y: 0,
                    width: Math.max(e.modelValue.length * i.value, Number(e.width)),
                    height: e.height
                }, null)])])
            })
        }
    });

function JH(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
        a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 75;
    if (e.length === 0) return "";
    const l = e.shift(),
        r = e[e.length - 1];
    return (n ? `M${l.x} ${a-l.x+2} L${l.x} ${l.y}` : `M${l.x} ${l.y}`) + e.map((o, i) => {
        const s = e[i + 1],
            u = e[i - 1] || l,
            c = s && ZH(s, o, u);
        if (!s || c) return `L${o.x} ${o.y}`;
        const d = Math.min(tb(u, o), tb(s, o)),
            v = d / 2 < t ? d / 2 : t,
            g = nb(u, o, v),
            h = nb(s, o, v);
        return `L${g.x} ${g.y}S${o.x} ${o.y} ${h.x} ${h.y}`
    }).join("") + (n ? `L${r.x} ${a-l.x+2} Z` : "")
}

function Wi(e) {
    return parseInt(e, 10)
}

function ZH(e, t, n) {
    return Wi(e.x + n.x) === Wi(2 * t.x) && Wi(e.y + n.y) === Wi(2 * t.y)
}

function tb(e, t) {
    return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2))
}

function nb(e, t, n) {
    const a = {
            x: e.x - t.x,
            y: e.y - t.y
        },
        l = Math.sqrt(a.x * a.x + a.y * a.y),
        r = {
            x: a.x / l,
            y: a.y / l
        };
    return {
        x: t.x + r.x * n,
        y: t.y + r.y * n
    }
}
const eC = W({
        fill: Boolean,
        ...Zk()
    }, "VTrendline"),
    ab = Z()({
        name: "VTrendline",
        props: eC(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Rt(),
                l = C(() => e.id || `trendline-${a}`),
                r = C(() => Number(e.autoDrawDuration) || (e.fill ? 500 : 2e3)),
                o = Q(0),
                i = Q(null);

            function s(y, S) {
                const {
                    minX: b,
                    maxX: p,
                    minY: _,
                    maxY: w
                } = S, k = y.length, E = e.max != null ? Number(e.max) : Math.max(...y), P = e.min != null ? Number(e.min) : Math.min(...y), x = (p - b) / (k - 1), T = (w - _) / (E - P || 1);
                return y.map((V, I) => ({
                    x: b + I * x,
                    y: w - (V - P) * T,
                    value: V
                }))
            }
            const u = C(() => !!(e.showLabels || e.labels.length > 0 || n != null && n.label)),
                c = C(() => parseFloat(e.lineWidth) || 4),
                d = C(() => Number(e.width)),
                f = C(() => {
                    const y = Number(e.padding);
                    return {
                        minX: y,
                        maxX: d.value - y,
                        minY: y,
                        maxY: parseInt(e.height, 10) - y
                    }
                }),
                v = C(() => e.modelValue.map(y => vt(y, e.itemValue, y))),
                g = C(() => {
                    const y = [],
                        S = s(v.value, f.value),
                        b = S.length;
                    for (let p = 0; y.length < b; p++) {
                        const _ = S[p];
                        let w = e.labels[p];
                        w || (w = typeof _ == "object" ? _.value : _), y.push({
                            x: _.x,
                            value: String(w)
                        })
                    }
                    return y
                });
            de(() => e.modelValue, async () => {
                if (await Re(), !e.autoDraw || !i.value) return;
                const y = i.value,
                    S = y.getTotalLength();
                e.fill ? (y.style.transformOrigin = "bottom center", y.style.transition = "none", y.style.transform = "scaleY(0)", y.getBoundingClientRect(), y.style.transition = `transform ${r.value}ms ${e.autoDrawEasing}`, y.style.transform = "scaleY(1)") : (y.style.strokeDasharray = `${S}`, y.style.strokeDashoffset = `${S}`, y.getBoundingClientRect(), y.style.transition = `stroke-dashoffset ${r.value}ms ${e.autoDrawEasing}`, y.style.strokeDashoffset = "0"), o.value = S
            }, {
                immediate: !0
            });

            function h(y) {
                return JH(s(v.value, f.value), e.smooth ? 8 : Number(e.smooth), y, parseInt(e.height, 10))
            }
            ne(() => {
                var S;
                const y = e.gradient.slice().length ? e.gradient.slice().reverse() : [""];
                return m("svg", {
                    display: "block",
                    "stroke-width": parseFloat(e.lineWidth) ? ? 4
                }, [m("defs", null, [m("linearGradient", {
                    id: l.value,
                    gradientUnits: "userSpaceOnUse",
                    x1: e.gradientDirection === "left" ? "100%" : "0",
                    y1: e.gradientDirection === "top" ? "100%" : "0",
                    x2: e.gradientDirection === "right" ? "100%" : "0",
                    y2: e.gradientDirection === "bottom" ? "100%" : "0"
                }, [y.map((b, p) => m("stop", {
                    offset: p / Math.max(y.length - 1, 1),
                    "stop-color": b || "currentColor"
                }, null))])]), u.value && m("g", {
                    key: "labels",
                    style: {
                        textAnchor: "middle",
                        dominantBaseline: "mathematical",
                        fill: "currentColor"
                    }
                }, [g.value.map((b, p) => {
                    var _;
                    return m("text", {
                        x: b.x + c.value / 2 + c.value / 2,
                        y: parseInt(e.height, 10) - 4 + (parseInt(e.labelSize, 10) || 7 * .75),
                        "font-size": Number(e.labelSize) || 7
                    }, [((_ = n.label) == null ? void 0 : _.call(n, {
                        index: p,
                        value: b.value
                    })) ? ? b.value])
                })]), m("path", {
                    ref: i,
                    d: h(e.fill),
                    fill: e.fill ? `url(#${l.value})` : "none",
                    stroke: e.fill ? "none" : `url(#${l.value})`
                }, null), e.fill && m("path", {
                    d: h(!1),
                    fill: "none",
                    stroke: e.color ? ? ((S = e.gradient) == null ? void 0 : S[0])
                }, null)])
            })
        }
    }),
    QH = W({
        type: {
            type: String,
            default: "trend"
        },
        ...Qk(),
        ...eC()
    }, "VSparkline"),
    e4 = Z()({
        name: "VSparkline",
        props: QH(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                textColorClasses: a,
                textColorStyles: l
            } = Ot(Y(e, "color")), r = C(() => !!(e.showLabels || e.labels.length > 0 || n != null && n.label)), o = C(() => {
                let i = parseInt(e.height, 10);
                return r.value && (i += parseInt(e.labelSize, 10) * 1.5), i
            });
            ne(() => {
                const i = e.type === "trend" ? ab : eb,
                    s = e.type === "trend" ? ab.filterProps(e) : eb.filterProps(e);
                return m(i, te({
                    key: e.type,
                    class: a.value,
                    style: l.value,
                    viewBox: `0 0 ${e.width} ${parseInt(o.value,10)}`
                }, s), n)
            })
        }
    }),
    t4 = W({ ...Se(),
        ...Mw({
            offset: 8,
            minWidth: 0,
            openDelay: 0,
            closeDelay: 100,
            location: "top center",
            transition: "scale-transition"
        })
    }, "VSpeedDial"),
    n4 = Z()({
        name: "VSpeedDial",
        props: t4(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Ce(e, "modelValue"),
                l = Q(),
                r = C(() => {
                    var u;
                    const [i, s = "center"] = ((u = e.location) == null ? void 0 : u.split(" ")) ? ? [];
                    return `${i} ${s}`
                }),
                o = C(() => ({
                    [`v-speed-dial__content--${r.value.replace(" ","-")}`]: !0
                }));
            return ne(() => {
                const i = Ol.filterProps(e);
                return m(Ol, te(i, {
                    modelValue: a.value,
                    "onUpdate:modelValue": s => a.value = s,
                    class: e.class,
                    style: e.style,
                    contentClass: ["v-speed-dial__content", o.value, e.contentClass],
                    location: r.value,
                    ref: l,
                    transition: "fade-transition"
                }), { ...n,
                    default: s => m(Ve, {
                        defaults: {
                            VBtn: {
                                size: "small"
                            }
                        }
                    }, {
                        default: () => [m(jt, {
                            appear: !0,
                            group: !0,
                            transition: e.transition
                        }, {
                            default: () => {
                                var u;
                                return [(u = n.default) == null ? void 0 : u.call(n, s)]
                            }
                        })]
                    })
                })
            }), {}
        }
    }),
    Pm = Symbol.for("vuetify:v-stepper"),
    Em = W({
        color: String,
        disabled: {
            type: [Boolean, String],
            default: !1
        },
        prevText: {
            type: String,
            default: "$vuetify.stepper.prev"
        },
        nextText: {
            type: String,
            default: "$vuetify.stepper.next"
        }
    }, "VStepperActions"),
    $s = Z()({
        name: "VStepperActions",
        props: Em(),
        emits: {
            "click:prev": () => !0,
            "click:next": () => !0
        },
        setup(e, t) {
            let {
                emit: n,
                slots: a
            } = t;
            const {
                t: l
            } = Qe();

            function r() {
                n("click:prev")
            }

            function o() {
                n("click:next")
            }
            return ne(() => {
                const i = {
                        onClick: r
                    },
                    s = {
                        onClick: o
                    };
                return m("div", {
                    class: "v-stepper-actions"
                }, [m(Ve, {
                    defaults: {
                        VBtn: {
                            disabled: ["prev", !0].includes(e.disabled),
                            text: l(e.prevText),
                            variant: "text"
                        }
                    }
                }, {
                    default: () => {
                        var u;
                        return [((u = a.prev) == null ? void 0 : u.call(a, {
                            props: i
                        })) ? ? m(Le, i, null)]
                    }
                }), m(Ve, {
                    defaults: {
                        VBtn: {
                            color: e.color,
                            disabled: ["next", !0].includes(e.disabled),
                            text: l(e.nextText),
                            variant: "tonal"
                        }
                    }
                }, {
                    default: () => {
                        var u;
                        return [((u = a.next) == null ? void 0 : u.call(a, {
                            props: s
                        })) ? ? m(Le, s, null)]
                    }
                })])
            }), {}
        }
    }),
    tC = oa("v-stepper-header"),
    nC = W({
        color: String,
        title: String,
        subtitle: String,
        complete: Boolean,
        completeIcon: {
            type: String,
            default: "$complete"
        },
        editable: Boolean,
        editIcon: {
            type: String,
            default: "$edit"
        },
        error: Boolean,
        errorIcon: {
            type: String,
            default: "$error"
        },
        icon: String,
        ripple: {
            type: [Boolean, Object],
            default: !0
        },
        rules: {
            type: Array,
            default: () => []
        }
    }, "StepperItem"),
    a4 = W({ ...nC(),
        ...ql()
    }, "VStepperItem"),
    aC = Z()({
        name: "VStepperItem",
        directives: {
            Ripple: Ia
        },
        props: a4(),
        emits: {
            "group:selected": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Xl(e, Pm, !0),
                l = C(() => (a == null ? void 0 : a.value.value) ? ? e.value),
                r = C(() => e.rules.every(f => f() === !0)),
                o = C(() => !e.disabled && e.editable),
                i = C(() => !e.disabled && e.editable),
                s = C(() => e.error || !r.value),
                u = C(() => e.complete || e.rules.length > 0 && r.value),
                c = C(() => s.value ? e.errorIcon : u.value ? e.completeIcon : a.isSelected.value && e.editable ? e.editIcon : e.icon),
                d = C(() => ({
                    canEdit: i.value,
                    hasError: s.value,
                    hasCompleted: u.value,
                    title: e.title,
                    subtitle: e.subtitle,
                    step: l.value,
                    value: e.value
                }));
            return ne(() => {
                var y, S, b;
                const f = (!a || a.isSelected.value || u.value || i.value) && !s.value && !e.disabled,
                    v = !!(e.title != null || n.title),
                    g = !!(e.subtitle != null || n.subtitle);

                function h() {
                    a == null || a.toggle()
                }
                return at(m("button", {
                    class: ["v-stepper-item", {
                        "v-stepper-item--complete": u.value,
                        "v-stepper-item--disabled": e.disabled,
                        "v-stepper-item--error": s.value
                    }, a == null ? void 0 : a.selectedClass.value],
                    disabled: !e.editable,
                    onClick: h
                }, [o.value && ll(!0, "v-stepper-item"), m(yn, {
                    key: "stepper-avatar",
                    class: "v-stepper-item__avatar",
                    color: f ? e.color : void 0,
                    size: 24
                }, {
                    default: () => {
                        var p;
                        return [((p = n.icon) == null ? void 0 : p.call(n, d.value)) ? ? (c.value ? m(Be, {
                            icon: c.value
                        }, null) : l.value)]
                    }
                }), m("div", {
                    class: "v-stepper-item__content"
                }, [v && m("div", {
                    key: "title",
                    class: "v-stepper-item__title"
                }, [((y = n.title) == null ? void 0 : y.call(n, d.value)) ? ? e.title]), g && m("div", {
                    key: "subtitle",
                    class: "v-stepper-item__subtitle"
                }, [((S = n.subtitle) == null ? void 0 : S.call(n, d.value)) ? ? e.subtitle]), (b = n.default) == null ? void 0 : b.call(n, d.value)])]), [
                    [tn("ripple"), e.ripple && e.editable, null]
                ])
            }), {}
        }
    }),
    l4 = W({ ...We($u(), ["continuous", "nextIcon", "prevIcon", "showArrows", "touch", "mandatory"])
    }, "VStepperWindow"),
    lC = Z()({
        name: "VStepperWindow",
        props: l4(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Te(Pm, null),
                l = Ce(e, "modelValue"),
                r = C({
                    get() {
                        var o;
                        return l.value != null || !a ? l.value : (o = a.items.value.find(i => a.selected.value.includes(i.id))) == null ? void 0 : o.value
                    },
                    set(o) {
                        l.value = o
                    }
                });
            return ne(() => {
                const o = Rl.filterProps(e);
                return m(Rl, te({
                    _as: "VStepperWindow"
                }, o, {
                    modelValue: r.value,
                    "onUpdate:modelValue": i => r.value = i,
                    class: ["v-stepper-window", e.class],
                    style: e.style,
                    mandatory: !1,
                    touch: !1
                }), n)
            }), {}
        }
    }),
    r4 = W({ ...Bu()
    }, "VStepperWindowItem"),
    rC = Z()({
        name: "VStepperWindowItem",
        props: r4(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            return ne(() => {
                const a = Dl.filterProps(e);
                return m(Dl, te({
                    _as: "VStepperWindowItem"
                }, a, {
                    class: ["v-stepper-window-item", e.class],
                    style: e.style
                }), n)
            }), {}
        }
    }),
    oC = W({
        altLabels: Boolean,
        bgColor: String,
        completeIcon: String,
        editIcon: String,
        editable: Boolean,
        errorIcon: String,
        hideActions: Boolean,
        items: {
            type: Array,
            default: () => []
        },
        itemTitle: {
            type: String,
            default: "title"
        },
        itemValue: {
            type: String,
            default: "value"
        },
        nonLinear: Boolean,
        flat: Boolean,
        ...Ul()
    }, "Stepper"),
    o4 = W({ ...oC(),
        ...Yl({
            mandatory: "force",
            selectedClass: "v-stepper-item--selected"
        }),
        ...Fu(),
        ...wu(Em(), ["prevText", "nextText"])
    }, "VStepper"),
    i4 = Z()({
        name: "VStepper",
        props: o4(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                items: a,
                next: l,
                prev: r,
                selected: o
            } = rl(e, Pm), {
                displayClasses: i,
                mobile: s
            } = On(e), {
                completeIcon: u,
                editIcon: c,
                errorIcon: d,
                color: f,
                editable: v,
                prevText: g,
                nextText: h
            } = ta(e), y = C(() => e.items.map((p, _) => {
                const w = vt(p, e.itemTitle, p),
                    k = vt(p, e.itemValue, _ + 1);
                return {
                    title: w,
                    value: k,
                    raw: p
                }
            })), S = C(() => a.value.findIndex(p => o.value.includes(p.id))), b = C(() => e.disabled ? e.disabled : S.value === 0 ? "prev" : S.value === a.value.length - 1 ? "next" : !1);
            return lt({
                VStepperItem: {
                    editable: v,
                    errorIcon: d,
                    completeIcon: u,
                    editIcon: c,
                    prevText: g,
                    nextText: h
                },
                VStepperActions: {
                    color: f,
                    disabled: b,
                    prevText: g,
                    nextText: h
                }
            }), ne(() => {
                const p = Qa.filterProps(e),
                    _ = !!(n.header || e.items.length),
                    w = e.items.length > 0,
                    k = !e.hideActions && !!(w || n.actions);
                return m(Qa, te(p, {
                    color: e.bgColor,
                    class: ["v-stepper", {
                        "v-stepper--alt-labels": e.altLabels,
                        "v-stepper--flat": e.flat,
                        "v-stepper--non-linear": e.nonLinear,
                        "v-stepper--mobile": s.value
                    }, i.value, e.class],
                    style: e.style
                }), {
                    default: () => {
                        var E, P;
                        return [_ && m(tC, {
                            key: "stepper-header"
                        }, {
                            default: () => [y.value.map((x, T) => {
                                let {
                                    raw: V,
                                    ...I
                                } = x;
                                return m(ye, null, [!!T && m(ya, null, null), m(aC, I, {
                                    default: n[`header-item.${I.value}`] ? ? n.header,
                                    icon: n.icon,
                                    title: n.title,
                                    subtitle: n.subtitle
                                })])
                            })]
                        }), w && m(lC, {
                            key: "stepper-window"
                        }, {
                            default: () => [y.value.map(x => m(rC, {
                                value: x.value
                            }, {
                                default: () => {
                                    var T, V;
                                    return ((T = n[`item.${x.value}`]) == null ? void 0 : T.call(n, x)) ? ? ((V = n.item) == null ? void 0 : V.call(n, x))
                                }
                            }))]
                        }), (E = n.default) == null ? void 0 : E.call(n, {
                            prev: r,
                            next: l
                        }), k && (((P = n.actions) == null ? void 0 : P.call(n, {
                            next: l,
                            prev: r
                        })) ? ? m($s, {
                            key: "stepper-actions",
                            "onClick:prev": r,
                            "onClick:next": l
                        }, n))]
                    }
                })
            }), {
                prev: r,
                next: l
            }
        }
    }),
    s4 = W({
        indeterminate: Boolean,
        inset: Boolean,
        flat: Boolean,
        loading: {
            type: [Boolean, String],
            default: !1
        },
        ...Ta(),
        ...Du()
    }, "VSwitch"),
    u4 = Z()({
        name: "VSwitch",
        inheritAttrs: !1,
        props: s4(),
        emits: {
            "update:focused": e => !0,
            "update:modelValue": e => !0,
            "update:indeterminate": e => !0
        },
        setup(e, t) {
            let {
                attrs: n,
                slots: a
            } = t;
            const l = Ce(e, "indeterminate"),
                r = Ce(e, "modelValue"),
                {
                    loaderClasses: o
                } = vi(e),
                {
                    isFocused: i,
                    focus: s,
                    blur: u
                } = ua(e),
                c = Q(),
                d = Ue && window.matchMedia("(forced-colors: active)").matches,
                f = C(() => typeof e.loading == "string" && e.loading !== "" ? e.loading : e.color),
                v = Rt(),
                g = C(() => e.id || `switch-${v}`);

            function h() {
                l.value && (l.value = !1)
            }

            function y(S) {
                var b, p;
                S.stopPropagation(), S.preventDefault(), (p = (b = c.value) == null ? void 0 : b.input) == null || p.click()
            }
            return ne(() => {
                const [S, b] = al(n), p = $t.filterProps(e), _ = Za.filterProps(e);
                return m($t, te({
                    class: ["v-switch", {
                        "v-switch--flat": e.flat
                    }, {
                        "v-switch--inset": e.inset
                    }, {
                        "v-switch--indeterminate": l.value
                    }, o.value, e.class]
                }, S, p, {
                    modelValue: r.value,
                    "onUpdate:modelValue": w => r.value = w,
                    id: g.value,
                    focused: i.value,
                    style: e.style
                }), { ...a,
                    default: w => {
                        let {
                            id: k,
                            messagesId: E,
                            isDisabled: P,
                            isReadonly: x,
                            isValid: T
                        } = w;
                        const V = {
                            model: r,
                            isValid: T
                        };
                        return m(Za, te({
                            ref: c
                        }, _, {
                            modelValue: r.value,
                            "onUpdate:modelValue": [I => r.value = I, h],
                            id: k.value,
                            "aria-describedby": E.value,
                            type: "checkbox",
                            "aria-checked": l.value ? "mixed" : void 0,
                            disabled: P.value,
                            readonly: x.value,
                            onFocus: s,
                            onBlur: u
                        }, b), { ...a,
                            default: I => {
                                let {
                                    backgroundColorClasses: R,
                                    backgroundColorStyles: B
                                } = I;
                                return m("div", {
                                    class: ["v-switch__track", d ? void 0 : R.value],
                                    style: B.value,
                                    onClick: y
                                }, [a["track-true"] && m("div", {
                                    key: "prepend",
                                    class: "v-switch__track-true"
                                }, [a["track-true"](V)]), a["track-false"] && m("div", {
                                    key: "append",
                                    class: "v-switch__track-false"
                                }, [a["track-false"](V)])])
                            },
                            input: I => {
                                let {
                                    inputNode: R,
                                    icon: B,
                                    backgroundColorClasses: $,
                                    backgroundColorStyles: D
                                } = I;
                                return m(ye, null, [R, m("div", {
                                    class: ["v-switch__thumb", {
                                        "v-switch__thumb--filled": B || e.loading
                                    }, e.inset || d ? void 0 : $.value],
                                    style: e.inset ? void 0 : D.value
                                }, [a.thumb ? m(Ve, {
                                    defaults: {
                                        VIcon: {
                                            icon: B,
                                            size: "x-small"
                                        }
                                    }
                                }, {
                                    default: () => [a.thumb({ ...V,
                                        icon: B
                                    })]
                                }) : m(Uv, null, {
                                    default: () => [e.loading ? m(mi, {
                                        name: "v-switch",
                                        active: !0,
                                        color: T.value === !1 ? void 0 : f.value
                                    }, {
                                        default: z => a.loader ? a.loader(z) : m(Ja, {
                                            active: z.isActive,
                                            color: z.color,
                                            indeterminate: !0,
                                            size: "16",
                                            width: "2"
                                        }, null)
                                    }) : B && m(Be, {
                                        key: String(B),
                                        icon: B,
                                        size: "x-small"
                                    }, null)]
                                })])])
                            }
                        })
                    }
                })
            }), {}
        }
    }),
    c4 = W({
        color: String,
        height: [Number, String],
        window: Boolean,
        ...Se(),
        ...Pt(),
        ...Wl(),
        ...rt(),
        ...Ae(),
        ...Ne()
    }, "VSystemBar"),
    d4 = Z()({
        name: "VSystemBar",
        props: c4(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                themeClasses: a
            } = je(e), {
                backgroundColorClasses: l,
                backgroundColorStyles: r
            } = Ke(Y(e, "color")), {
                elevationClasses: o
            } = Dt(e), {
                roundedClasses: i
            } = ct(e), {
                ssrBootStyles: s
            } = Kl(), u = C(() => e.height ? ? (e.window ? 32 : 24)), {
                layoutItemStyles: c
            } = zl({
                id: e.name,
                order: C(() => parseInt(e.order, 10)),
                position: fe("top"),
                layoutSize: u,
                elementSize: u,
                active: C(() => !0),
                absolute: Y(e, "absolute")
            });
            return ne(() => m(e.tag, {
                class: ["v-system-bar", {
                    "v-system-bar--window": e.window
                }, a.value, l.value, o.value, i.value, e.class],
                style: [r.value, c.value, s.value, e.style]
            }, n)), {}
        }
    }),
    Im = Symbol.for("vuetify:v-tabs"),
    f4 = W({
        fixed: Boolean,
        sliderColor: String,
        hideSlider: Boolean,
        direction: {
            type: String,
            default: "horizontal"
        },
        ...We(Ru({
            selectedClass: "v-tab--selected",
            variant: "text"
        }), ["active", "block", "flat", "location", "position", "symbol"])
    }, "VTab"),
    iC = Z()({
        name: "VTab",
        props: f4(),
        setup(e, t) {
            let {
                slots: n,
                attrs: a
            } = t;
            const {
                textColorClasses: l,
                textColorStyles: r
            } = Ot(e, "sliderColor"), o = Q(), i = Q(), s = C(() => e.direction === "horizontal"), u = C(() => {
                var d, f;
                return ((f = (d = o.value) == null ? void 0 : d.group) == null ? void 0 : f.isSelected.value) ? ? !1
            });

            function c(d) {
                var v, g;
                let {
                    value: f
                } = d;
                if (f) {
                    const h = (g = (v = o.value) == null ? void 0 : v.$el.parentElement) == null ? void 0 : g.querySelector(".v-tab--selected .v-tab__slider"),
                        y = i.value;
                    if (!h || !y) return;
                    const S = getComputedStyle(h).color,
                        b = h.getBoundingClientRect(),
                        p = y.getBoundingClientRect(),
                        _ = s.value ? "x" : "y",
                        w = s.value ? "X" : "Y",
                        k = s.value ? "right" : "bottom",
                        E = s.value ? "width" : "height",
                        P = b[_],
                        x = p[_],
                        T = P > x ? b[k] - p[k] : b[_] - p[_],
                        V = Math.sign(T) > 0 ? s.value ? "right" : "bottom" : Math.sign(T) < 0 ? s.value ? "left" : "top" : "center",
                        R = (Math.abs(T) + (Math.sign(T) < 0 ? b[E] : p[E])) / Math.max(b[E], p[E]) || 0,
                        B = b[E] / p[E] || 0,
                        $ = 1.5;
                    yl(y, {
                        backgroundColor: [S, "currentcolor"],
                        transform: [`translate${w}(${T}px) scale${w}(${B})`, `translate${w}(${T/$}px) scale${w}(${(R-1)/$+1})`, "none"],
                        transformOrigin: Array(3).fill(V)
                    }, {
                        duration: 225,
                        easing: $o
                    })
                }
            }
            return ne(() => {
                const d = Le.filterProps(e);
                return m(Le, te({
                    symbol: Im,
                    ref: o,
                    class: ["v-tab", e.class],
                    style: e.style,
                    tabindex: u.value ? 0 : -1,
                    role: "tab",
                    "aria-selected": String(u.value),
                    active: !1
                }, d, a, {
                    block: e.fixed,
                    maxWidth: e.fixed ? 300 : void 0,
                    "onGroup:selected": c
                }), { ...n,
                    default: () => {
                        var f;
                        return m(ye, null, [((f = n.default) == null ? void 0 : f.call(n)) ? ? e.text, !e.hideSlider && m("div", {
                            ref: i,
                            class: ["v-tab__slider", l.value],
                            style: r.value
                        }, null)])
                    }
                })
            }), wn({}, o)
        }
    }),
    v4 = W({ ...We($u(), ["continuous", "nextIcon", "prevIcon", "showArrows", "touch", "mandatory"])
    }, "VTabsWindow"),
    sC = Z()({
        name: "VTabsWindow",
        props: v4(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Te(Im, null),
                l = Ce(e, "modelValue"),
                r = C({
                    get() {
                        var o;
                        return l.value != null || !a ? l.value : (o = a.items.value.find(i => a.selected.value.includes(i.id))) == null ? void 0 : o.value
                    },
                    set(o) {
                        l.value = o
                    }
                });
            return ne(() => {
                const o = Rl.filterProps(e);
                return m(Rl, te({
                    _as: "VTabsWindow"
                }, o, {
                    modelValue: r.value,
                    "onUpdate:modelValue": i => r.value = i,
                    class: ["v-tabs-window", e.class],
                    style: e.style,
                    mandatory: !1,
                    touch: !1
                }), n)
            }), {}
        }
    }),
    m4 = W({ ...Bu()
    }, "VTabsWindowItem"),
    uC = Z()({
        name: "VTabsWindowItem",
        props: m4(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            return ne(() => {
                const a = Dl.filterProps(e);
                return m(Dl, te({
                    _as: "VTabsWindowItem"
                }, a, {
                    class: ["v-tabs-window-item", e.class],
                    style: e.style
                }), n)
            }), {}
        }
    });

function h4(e) {
    return e ? e.map(t => Iv(t) ? t : {
        text: t,
        value: t
    }) : []
}
const g4 = W({
        alignTabs: {
            type: String,
            default: "start"
        },
        color: String,
        fixedTabs: Boolean,
        items: {
            type: Array,
            default: () => []
        },
        stacked: Boolean,
        bgColor: String,
        grow: Boolean,
        height: {
            type: [Number, String],
            default: void 0
        },
        hideSlider: Boolean,
        sliderColor: String,
        ...qv({
            mandatory: "force",
            selectedClass: "v-tab-item--selected"
        }),
        ...Vt(),
        ...Ae()
    }, "VTabs"),
    y4 = Z()({
        name: "VTabs",
        props: g4(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                attrs: n,
                slots: a
            } = t;
            const l = Ce(e, "modelValue"),
                r = C(() => h4(e.items)),
                {
                    densityClasses: o
                } = zt(e),
                {
                    backgroundColorClasses: i,
                    backgroundColorStyles: s
                } = Ke(Y(e, "bgColor")),
                {
                    scopeId: u
                } = Ql();
            return lt({
                VTab: {
                    color: Y(e, "color"),
                    direction: Y(e, "direction"),
                    stacked: Y(e, "stacked"),
                    fixed: Y(e, "fixedTabs"),
                    sliderColor: Y(e, "sliderColor"),
                    hideSlider: Y(e, "hideSlider")
                }
            }), ne(() => {
                const c = Ko.filterProps(e),
                    d = !!(a.window || e.items.length > 0);
                return m(ye, null, [m(Ko, te(c, {
                    modelValue: l.value,
                    "onUpdate:modelValue": f => l.value = f,
                    class: ["v-tabs", `v-tabs--${e.direction}`, `v-tabs--align-tabs-${e.alignTabs}`, {
                        "v-tabs--fixed-tabs": e.fixedTabs,
                        "v-tabs--grow": e.grow,
                        "v-tabs--stacked": e.stacked
                    }, o.value, i.value, e.class],
                    style: [{
                        "--v-tabs-height": ge(e.height)
                    }, s.value, e.style],
                    role: "tablist",
                    symbol: Im
                }, u, n), {
                    default: () => {
                        var f;
                        return [((f = a.default) == null ? void 0 : f.call(a)) ? ? r.value.map(v => {
                            var g;
                            return ((g = a.tab) == null ? void 0 : g.call(a, {
                                item: v
                            })) ? ? m(iC, te(v, {
                                key: v.text,
                                value: v.value
                            }), {
                                default: a[`tab.${v.value}`] ? () => {
                                    var h;
                                    return (h = a[`tab.${v.value}`]) == null ? void 0 : h.call(a, {
                                        item: v
                                    })
                                } : void 0
                            })
                        })]
                    }
                }), d && m(sC, te({
                    modelValue: l.value,
                    "onUpdate:modelValue": f => l.value = f,
                    key: "tabs-window"
                }, u), {
                    default: () => {
                        var f;
                        return [r.value.map(v => {
                            var g;
                            return ((g = a.item) == null ? void 0 : g.call(a, {
                                item: v
                            })) ? ? m(uC, {
                                value: v.value
                            }, {
                                default: () => {
                                    var h;
                                    return (h = a[`item.${v.value}`]) == null ? void 0 : h.call(a, {
                                        item: v
                                    })
                                }
                            })
                        }), (f = a.window) == null ? void 0 : f.call(a)]
                    }
                })])
            }), {}
        }
    }),
    b4 = W({
        autoGrow: Boolean,
        autofocus: Boolean,
        counter: [Boolean, Number, String],
        counterValue: Function,
        prefix: String,
        placeholder: String,
        persistentPlaceholder: Boolean,
        persistentCounter: Boolean,
        noResize: Boolean,
        rows: {
            type: [Number, String],
            default: 5,
            validator: e => !isNaN(parseFloat(e))
        },
        maxRows: {
            type: [Number, String],
            validator: e => !isNaN(parseFloat(e))
        },
        suffix: String,
        modelModifiers: Object,
        ...Ta(),
        ...bi()
    }, "VTextarea"),
    p4 = Z()({
        name: "VTextarea",
        directives: {
            Intersect: fi
        },
        inheritAttrs: !1,
        props: b4(),
        emits: {
            "click:control": e => !0,
            "mousedown:control": e => !0,
            "update:focused": e => !0,
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                attrs: n,
                emit: a,
                slots: l
            } = t;
            const r = Ce(e, "modelValue"),
                {
                    isFocused: o,
                    focus: i,
                    blur: s
                } = ua(e),
                u = C(() => typeof e.counterValue == "function" ? e.counterValue(r.value) : (r.value || "").toString().length),
                c = C(() => {
                    if (n.maxlength) return n.maxlength;
                    if (!(!e.counter || typeof e.counter != "number" && typeof e.counter != "string")) return e.counter
                });

            function d(V, I) {
                var R, B;
                !e.autofocus || !V || (B = (R = I[0].target) == null ? void 0 : R.focus) == null || B.call(R)
            }
            const f = Q(),
                v = Q(),
                g = fe(""),
                h = Q(),
                y = C(() => e.persistentPlaceholder || o.value || e.active);

            function S() {
                var V;
                h.value !== document.activeElement && ((V = h.value) == null || V.focus()), o.value || i()
            }

            function b(V) {
                S(), a("click:control", V)
            }

            function p(V) {
                a("mousedown:control", V)
            }

            function _(V) {
                V.stopPropagation(), S(), Re(() => {
                    r.value = "", Lv(e["onClick:clear"], V)
                })
            }

            function w(V) {
                var R;
                const I = V.target;
                if (r.value = I.value, (R = e.modelModifiers) != null && R.trim) {
                    const B = [I.selectionStart, I.selectionEnd];
                    Re(() => {
                        I.selectionStart = B[0], I.selectionEnd = B[1]
                    })
                }
            }
            const k = Q(),
                E = Q(+e.rows),
                P = C(() => ["plain", "underlined"].includes(e.variant));
            st(() => {
                e.autoGrow || (E.value = +e.rows)
            });

            function x() {
                e.autoGrow && Re(() => {
                    if (!k.value || !v.value) return;
                    const V = getComputedStyle(k.value),
                        I = getComputedStyle(v.value.$el),
                        R = parseFloat(V.getPropertyValue("--v-field-padding-top")) + parseFloat(V.getPropertyValue("--v-input-padding-top")) + parseFloat(V.getPropertyValue("--v-field-padding-bottom")),
                        B = k.value.scrollHeight,
                        $ = parseFloat(V.lineHeight),
                        D = Math.max(parseFloat(e.rows) * $ + R, parseFloat(I.getPropertyValue("--v-input-control-height"))),
                        z = parseFloat(e.maxRows) * $ + R || 1 / 0,
                        N = ot(B ? ? 0, D, z);
                    E.value = Math.floor((N - R) / $), g.value = ge(N)
                })
            }
            it(x), de(r, x), de(() => e.rows, x), de(() => e.maxRows, x), de(() => e.density, x);
            let T;
            return de(k, V => {
                V ? (T = new ResizeObserver(x), T.observe(k.value)) : T == null || T.disconnect()
            }), Ct(() => {
                T == null || T.disconnect()
            }), ne(() => {
                const V = !!(l.counter || e.counter || e.counterValue),
                    I = !!(V || l.details),
                    [R, B] = al(n),
                    {
                        modelValue: $,
                        ...D
                    } = $t.filterProps(e),
                    z = lm(e);
                return m($t, te({
                    ref: f,
                    modelValue: r.value,
                    "onUpdate:modelValue": N => r.value = N,
                    class: ["v-textarea v-text-field", {
                        "v-textarea--prefixed": e.prefix,
                        "v-textarea--suffixed": e.suffix,
                        "v-text-field--prefixed": e.prefix,
                        "v-text-field--suffixed": e.suffix,
                        "v-textarea--auto-grow": e.autoGrow,
                        "v-textarea--no-resize": e.noResize || e.autoGrow,
                        "v-input--plain-underlined": P.value
                    }, e.class],
                    style: e.style
                }, R, D, {
                    centerAffix: E.value === 1 && !P.value,
                    focused: o.value
                }), { ...l,
                    default: N => {
                        let {
                            id: H,
                            isDisabled: F,
                            isDirty: j,
                            isReadonly: ae,
                            isValid: he
                        } = N;
                        return m(Xr, te({
                            ref: v,
                            style: {
                                "--v-textarea-control-height": g.value
                            },
                            onClick: b,
                            onMousedown: p,
                            "onClick:clear": _,
                            "onClick:prependInner": e["onClick:prependInner"],
                            "onClick:appendInner": e["onClick:appendInner"]
                        }, z, {
                            id: H.value,
                            active: y.value || j.value,
                            centerAffix: E.value === 1 && !P.value,
                            dirty: j.value || e.dirty,
                            disabled: F.value,
                            focused: o.value,
                            error: he.value === !1
                        }), { ...l,
                            default: ve => {
                                let {
                                    props: {
                                        class: we,
                                        ...ee
                                    }
                                } = ve;
                                return m(ye, null, [e.prefix && m("span", {
                                    class: "v-text-field__prefix"
                                }, [e.prefix]), at(m("textarea", te({
                                    ref: h,
                                    class: we,
                                    value: r.value,
                                    onInput: w,
                                    autofocus: e.autofocus,
                                    readonly: ae.value,
                                    disabled: F.value,
                                    placeholder: e.placeholder,
                                    rows: e.rows,
                                    name: e.name,
                                    onFocus: S,
                                    onBlur: s
                                }, ee, B), null), [
                                    [tn("intersect"), {
                                        handler: d
                                    }, null, {
                                        once: !0
                                    }]
                                ]), e.autoGrow && at(m("textarea", {
                                    class: [we, "v-textarea__sizer"],
                                    id: `${ee.id}-sizer`,
                                    "onUpdate:modelValue": G => r.value = G,
                                    ref: k,
                                    readonly: !0,
                                    "aria-hidden": "true"
                                }, null), [
                                    [To, r.value]
                                ]), e.suffix && m("span", {
                                    class: "v-text-field__suffix"
                                }, [e.suffix])])
                            }
                        })
                    },
                    details: I ? N => {
                        var H;
                        return m(ye, null, [(H = l.details) == null ? void 0 : H.call(l, N), V && m(ye, null, [m("span", null, null), m(Mu, {
                            active: e.persistentCounter || o.value,
                            value: u.value,
                            max: c.value,
                            disabled: e.disabled
                        }, l.counter)])])
                    } : void 0
                })
            }), wn({}, f, v, h)
        }
    }),
    _4 = W({
        withBackground: Boolean,
        ...Se(),
        ...Ne(),
        ...Ae()
    }, "VThemeProvider"),
    S4 = Z()({
        name: "VThemeProvider",
        props: _4(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                themeClasses: a
            } = je(e);
            return () => {
                var l;
                return e.withBackground ? m(e.tag, {
                    class: ["v-theme-provider", a.value, e.class],
                    style: e.style
                }, {
                    default: () => {
                        var r;
                        return [(r = n.default) == null ? void 0 : r.call(n)]
                    }
                }) : (l = n.default) == null ? void 0 : l.call(n)
            }
        }
    }),
    w4 = W({
        dotColor: String,
        fillDot: Boolean,
        hideDot: Boolean,
        icon: Pe,
        iconColor: String,
        lineColor: String,
        ...Se(),
        ...rt(),
        ...sa(),
        ...Pt()
    }, "VTimelineDivider"),
    k4 = Z()({
        name: "VTimelineDivider",
        props: w4(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                sizeClasses: a,
                sizeStyles: l
            } = Wr(e, "v-timeline-divider__dot"), {
                backgroundColorStyles: r,
                backgroundColorClasses: o
            } = Ke(Y(e, "dotColor")), {
                roundedClasses: i
            } = ct(e, "v-timeline-divider__dot"), {
                elevationClasses: s
            } = Dt(e), {
                backgroundColorClasses: u,
                backgroundColorStyles: c
            } = Ke(Y(e, "lineColor"));
            return ne(() => m("div", {
                class: ["v-timeline-divider", {
                    "v-timeline-divider--fill-dot": e.fillDot
                }, e.class],
                style: e.style
            }, [m("div", {
                class: ["v-timeline-divider__before", u.value],
                style: c.value
            }, null), !e.hideDot && m("div", {
                key: "dot",
                class: ["v-timeline-divider__dot", s.value, i.value, a.value],
                style: l.value
            }, [m("div", {
                class: ["v-timeline-divider__inner-dot", o.value, i.value],
                style: r.value
            }, [n.default ? m(Ve, {
                key: "icon-defaults",
                disabled: !e.icon,
                defaults: {
                    VIcon: {
                        color: e.iconColor,
                        icon: e.icon,
                        size: e.size
                    }
                }
            }, n.default) : m(Be, {
                key: "icon",
                color: e.iconColor,
                icon: e.icon,
                size: e.size
            }, null)])]), m("div", {
                class: ["v-timeline-divider__after", u.value],
                style: c.value
            }, null)])), {}
        }
    }),
    cC = W({
        density: String,
        dotColor: String,
        fillDot: Boolean,
        hideDot: Boolean,
        hideOpposite: {
            type: Boolean,
            default: void 0
        },
        icon: Pe,
        iconColor: String,
        lineInset: [Number, String],
        ...Se(),
        ...bt(),
        ...Pt(),
        ...rt(),
        ...sa(),
        ...Ae()
    }, "VTimelineItem"),
    C4 = Z()({
        name: "VTimelineItem",
        props: cC(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                dimensionStyles: a
            } = pt(e), l = fe(0), r = Q();
            return de(r, o => {
                var i;
                o && (l.value = ((i = o.$el.querySelector(".v-timeline-divider__dot")) == null ? void 0 : i.getBoundingClientRect().width) ? ? 0)
            }, {
                flush: "post"
            }), ne(() => {
                var o, i;
                return m("div", {
                    class: ["v-timeline-item", {
                        "v-timeline-item--fill-dot": e.fillDot
                    }, e.class],
                    style: [{
                        "--v-timeline-dot-size": ge(l.value),
                        "--v-timeline-line-inset": e.lineInset ? `calc(var(--v-timeline-dot-size) / 2 + ${ge(e.lineInset)})` : ge(0)
                    }, e.style]
                }, [m("div", {
                    class: "v-timeline-item__body",
                    style: a.value
                }, [(o = n.default) == null ? void 0 : o.call(n)]), m(k4, {
                    ref: r,
                    hideDot: e.hideDot,
                    icon: e.icon,
                    iconColor: e.iconColor,
                    size: e.size,
                    elevation: e.elevation,
                    dotColor: e.dotColor,
                    fillDot: e.fillDot,
                    rounded: e.rounded
                }, {
                    default: n.icon
                }), e.density !== "compact" && m("div", {
                    class: "v-timeline-item__opposite"
                }, [!e.hideOpposite && ((i = n.opposite) == null ? void 0 : i.call(n))])])
            }), {}
        }
    }),
    x4 = W({
        align: {
            type: String,
            default: "center",
            validator: e => ["center", "start"].includes(e)
        },
        direction: {
            type: String,
            default: "vertical",
            validator: e => ["vertical", "horizontal"].includes(e)
        },
        justify: {
            type: String,
            default: "auto",
            validator: e => ["auto", "center"].includes(e)
        },
        side: {
            type: String,
            validator: e => e == null || ["start", "end"].includes(e)
        },
        lineThickness: {
            type: [String, Number],
            default: 2
        },
        lineColor: String,
        truncateLine: {
            type: String,
            validator: e => ["start", "end", "both"].includes(e)
        },
        ...wu(cC({
            lineInset: 0
        }), ["dotColor", "fillDot", "hideOpposite", "iconColor", "lineInset", "size"]),
        ...Se(),
        ...Vt(),
        ...Ae(),
        ...Ne()
    }, "VTimeline"),
    P4 = Z()({
        name: "VTimeline",
        props: x4(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                themeClasses: a
            } = je(e), {
                densityClasses: l
            } = zt(e), {
                rtlClasses: r
            } = xt();
            lt({
                VTimelineDivider: {
                    lineColor: Y(e, "lineColor")
                },
                VTimelineItem: {
                    density: Y(e, "density"),
                    dotColor: Y(e, "dotColor"),
                    fillDot: Y(e, "fillDot"),
                    hideOpposite: Y(e, "hideOpposite"),
                    iconColor: Y(e, "iconColor"),
                    lineColor: Y(e, "lineColor"),
                    lineInset: Y(e, "lineInset"),
                    size: Y(e, "size")
                }
            });
            const o = C(() => {
                    const s = e.side ? e.side : e.density !== "default" ? "end" : null;
                    return s && `v-timeline--side-${s}`
                }),
                i = C(() => {
                    const s = ["v-timeline--truncate-line-start", "v-timeline--truncate-line-end"];
                    switch (e.truncateLine) {
                        case "both":
                            return s;
                        case "start":
                            return s[0];
                        case "end":
                            return s[1];
                        default:
                            return null
                    }
                });
            return ne(() => m(e.tag, {
                class: ["v-timeline", `v-timeline--${e.direction}`, `v-timeline--align-${e.align}`, `v-timeline--justify-${e.justify}`, i.value, {
                    "v-timeline--inset-line": !!e.lineInset
                }, a.value, l.value, o.value, r.value, e.class],
                style: [{
                    "--v-timeline-line-thickness": ge(e.lineThickness)
                }, e.style]
            }, n)), {}
        }
    }),
    E4 = W({ ...Se(),
        ...Rn({
            variant: "text"
        })
    }, "VToolbarItems"),
    I4 = Z()({
        name: "VToolbarItems",
        props: E4(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            return lt({
                VBtn: {
                    color: Y(e, "color"),
                    height: "inherit",
                    variant: Y(e, "variant")
                }
            }), ne(() => {
                var a;
                return m("div", {
                    class: ["v-toolbar-items", e.class],
                    style: e.style
                }, [(a = n.default) == null ? void 0 : a.call(n)])
            }), {}
        }
    }),
    T4 = W({
        id: String,
        text: String,
        ...We(yi({
            closeOnBack: !1,
            location: "end",
            locationStrategy: "connected",
            eager: !0,
            minWidth: 0,
            offset: 10,
            openOnClick: !1,
            openOnHover: !0,
            origin: "auto",
            scrim: !1,
            scrollStrategy: "reposition",
            transition: !1
        }), ["absolute", "persistent"])
    }, "VTooltip"),
    dC = Z()({
        name: "VTooltip",
        props: T4(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Ce(e, "modelValue"),
                {
                    scopeId: l
                } = Ql(),
                r = Rt(),
                o = C(() => e.id || `v-tooltip-${r}`),
                i = Q(),
                s = C(() => e.location.split(" ").length > 1 ? e.location : e.location + " center"),
                u = C(() => e.origin === "auto" || e.origin === "overlap" || e.origin.split(" ").length > 1 || e.location.split(" ").length > 1 ? e.origin : e.origin + " center"),
                c = C(() => e.transition ? e.transition : a.value ? "scale-transition" : "fade-transition"),
                d = C(() => te({
                    "aria-describedby": o.value
                }, e.activatorProps));
            return ne(() => {
                const f = ea.filterProps(e);
                return m(ea, te({
                    ref: i,
                    class: ["v-tooltip", e.class],
                    style: e.style,
                    id: o.value
                }, f, {
                    modelValue: a.value,
                    "onUpdate:modelValue": v => a.value = v,
                    transition: c.value,
                    absolute: !0,
                    location: s.value,
                    origin: u.value,
                    persistent: !0,
                    role: "tooltip",
                    activatorProps: d.value,
                    _disableGlobalStack: !0
                }, l), {
                    activator: n.activator,
                    default: function() {
                        var y;
                        for (var v = arguments.length, g = new Array(v), h = 0; h < v; h++) g[h] = arguments[h];
                        return ((y = n.default) == null ? void 0 : y.call(n, ...g)) ? ? e.text
                    }
                })
            }), wn({}, i)
        }
    }),
    V4 = Z()({
        name: "VValidation",
        props: rw(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = ow(e, "validation");
            return () => {
                var l;
                return (l = n.default) == null ? void 0 : l.call(n, a)
            }
        }
    }),
    A4 = Object.freeze(Object.defineProperty({
        __proto__: null,
        VAlert: p$,
        VAlertTitle: ZS,
        VApp: IN,
        VAppBar: YN,
        VAppBarNavIcon: h$,
        VAppBarTitle: g$,
        VAutocomplete: MB,
        VAvatar: yn,
        VBadge: Fw,
        VBanner: FB,
        VBannerActions: Hw,
        VBannerText: jw,
        VBottomNavigation: jB,
        VBottomSheet: WB,
        VBreadcrumbs: YB,
        VBreadcrumbsDivider: Ww,
        VBreadcrumbsItem: zw,
        VBtn: Le,
        VBtnGroup: Ud,
        VBtnToggle: e$,
        VCard: QB,
        VCardActions: Kw,
        VCardItem: qw,
        VCardSubtitle: Gw,
        VCardText: Xw,
        VCardTitle: Yw,
        VCarousel: sF,
        VCarouselItem: cF,
        VCheckbox: I$,
        VCheckboxBtn: Qn,
        VChip: Zl,
        VChipGroup: O$,
        VClassIcon: Hv,
        VCode: dF,
        VCol: $2,
        VColorPicker: QF,
        VCombobox: n2,
        VComponentIcon: Fd,
        VConfirmEdit: nf,
        VContainer: R2,
        VCounter: Mu,
        VDataIterator: f2,
        VDataTable: I2,
        VDataTableFooter: qo,
        VDataTableHeaders: Ml,
        VDataTableRow: pm,
        VDataTableRows: Nl,
        VDataTableServer: L2,
        VDataTableVirtual: V2,
        VDatePicker: df,
        VDatePickerControls: rf,
        VDatePickerHeader: of ,
        VDatePickerMonth: sf,
        VDatePickerMonths: uf,
        VDatePickerYears: cf,
        VDefaultsProvider: Ve,
        VDialog: Xd,
        VDialogBottomTransition: LN,
        VDialogTopTransition: ON,
        VDialogTransition: Tu,
        VDivider: ya,
        VEmptyState: Y2,
        VExpandTransition: Vu,
        VExpandXTransition: zv,
        VExpansionPanel: mf,
        VExpansionPanelText: ff,
        VExpansionPanelTitle: vf,
        VExpansionPanels: hf,
        VFab: J2,
        VFabTransition: AN,
        VFadeTransition: jo,
        VField: Xr,
        VFieldLabel: io,
        VFileInput: Q2,
        VFooter: tH,
        VForm: aH,
        VHover: rH,
        VIcon: Be,
        VImg: Ca,
        VInfiniteScroll: iH,
        VInput: $t,
        VItem: cH,
        VItemGroup: uH,
        VKbd: dH,
        VLabel: Yr,
        VLayout: vH,
        VLayoutItem: hH,
        VLazy: yH,
        VLigatureIcon: pN,
        VList: Mr,
        VListGroup: Yo,
        VListImg: Z$,
        VListItem: jn,
        VListItemAction: Iw,
        VListItemMedia: tB,
        VListItemSubtitle: bw,
        VListItemTitle: pw,
        VListSubheader: Sw,
        VLocaleProvider: pH,
        VMain: SH,
        VMenu: Ol,
        VMessages: aw,
        VNavigationDrawer: VH,
        VNoSsr: AH,
        VOtpInput: OH,
        VOverlay: ea,
        VPagination: af,
        VParallax: MH,
        VProgressCircular: Ja,
        VProgressLinear: Lu,
        VRadio: $H,
        VRadioGroup: FH,
        VRangeSlider: jH,
        VRating: WH,
        VResponsive: Hd,
        VRow: z2,
        VScaleTransition: Uv,
        VScrollXReverseTransition: DN,
        VScrollXTransition: RN,
        VScrollYReverseTransition: NN,
        VScrollYTransition: MN,
        VSelect: im,
        VSelectionControl: Za,
        VSelectionControlGroup: ew,
        VSheet: Qa,
        VSkeletonLoader: YH,
        VSlideGroup: Ko,
        VSlideGroupItem: qH,
        VSlideXReverseTransition: BN,
        VSlideXTransition: $N,
        VSlideYReverseTransition: FN,
        VSlideYTransition: Wv,
        VSlider: tf,
        VSnackbar: gf,
        VSpacer: $k,
        VSparkline: e4,
        VSpeedDial: n4,
        VStepper: i4,
        VStepperActions: $s,
        VStepperHeader: tC,
        VStepperItem: aC,
        VStepperWindow: lC,
        VStepperWindowItem: rC,
        VSvgIcon: Fv,
        VSwitch: u4,
        VSystemBar: d4,
        VTab: iC,
        VTable: $l,
        VTabs: y4,
        VTabsWindow: sC,
        VTabsWindowItem: uC,
        VTextField: Un,
        VTextarea: p4,
        VThemeProvider: S4,
        VTimeline: P4,
        VTimelineItem: C4,
        VToolbar: jd,
        VToolbarItems: I4,
        VToolbarTitle: jv,
        VTooltip: dC,
        VValidation: V4,
        VVirtualScroll: Nu,
        VWindow: Rl,
        VWindowItem: Dl
    }, Symbol.toStringTag, {
        value: "Module"
    }));

function L4(e, t) {
    const n = t.modifiers || {},
        a = t.value,
        {
            once: l,
            immediate: r,
            ...o
        } = n,
        i = !Object.keys(o).length,
        {
            handler: s,
            options: u
        } = typeof a == "object" ? a : {
            handler: a,
            options: {
                attributes: (o == null ? void 0 : o.attr) ? ? i,
                characterData: (o == null ? void 0 : o.char) ? ? i,
                childList: (o == null ? void 0 : o.child) ? ? i,
                subtree: (o == null ? void 0 : o.sub) ? ? i
            }
        },
        c = new MutationObserver(function() {
            let d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
                f = arguments.length > 1 ? arguments[1] : void 0;
            s == null || s(d, f), l && fC(e, t)
        });
    r && (s == null || s([], c)), e._mutate = Object(e._mutate), e._mutate[t.instance.$.uid] = {
        observer: c
    }, c.observe(e, u)
}

function fC(e, t) {
    var n;
    (n = e._mutate) != null && n[t.instance.$.uid] && (e._mutate[t.instance.$.uid].observer.disconnect(), delete e._mutate[t.instance.$.uid])
}
const O4 = {
    mounted: L4,
    unmounted: fC
};

function R4(e, t) {
    var l, r;
    const n = t.value,
        a = {
            passive: !((l = t.modifiers) != null && l.active)
        };
    window.addEventListener("resize", n, a), e._onResize = Object(e._onResize), e._onResize[t.instance.$.uid] = {
        handler: n,
        options: a
    }, (r = t.modifiers) != null && r.quiet || n()
}

function D4(e, t) {
    var l;
    if (!((l = e._onResize) != null && l[t.instance.$.uid])) return;
    const {
        handler: n,
        options: a
    } = e._onResize[t.instance.$.uid];
    window.removeEventListener("resize", n, a), delete e._onResize[t.instance.$.uid]
}
const M4 = {
    mounted: R4,
    unmounted: D4
};

function vC(e, t) {
    const {
        self: n = !1
    } = t.modifiers ? ? {}, a = t.value, l = typeof a == "object" && a.options || {
        passive: !0
    }, r = typeof a == "function" || "handleEvent" in a ? a : a.handler, o = n ? e : t.arg ? document.querySelector(t.arg) : window;
    o && (o.addEventListener("scroll", r, l), e._onScroll = Object(e._onScroll), e._onScroll[t.instance.$.uid] = {
        handler: r,
        options: l,
        target: n ? void 0 : o
    })
}

function mC(e, t) {
    var r;
    if (!((r = e._onScroll) != null && r[t.instance.$.uid])) return;
    const {
        handler: n,
        options: a,
        target: l = e
    } = e._onScroll[t.instance.$.uid];
    l.removeEventListener("scroll", n, a), delete e._onScroll[t.instance.$.uid]
}

function N4(e, t) {
    t.value !== t.oldValue && (mC(e, t), vC(e, t))
}
const $4 = {
    mounted: vC,
    unmounted: mC,
    updated: N4
};

function B4(e, t) {
    const n = typeof e == "string" ? Ub(e) : e,
        a = F4(n, t);
    return {
        mounted: a,
        updated: a,
        unmounted(l) {
            Vo(null, l)
        }
    }
}

function F4(e, t) {
    return function(n, a, l) {
        var d, f, v;
        const r = typeof t == "function" ? t(a) : t,
            o = ((d = a.value) == null ? void 0 : d.text) ? ? a.value ? ? (r == null ? void 0 : r.text),
            i = Iv(a.value) ? a.value : {},
            s = () => o ? ? n.innerHTML,
            u = (l.ctx === a.instance.$ ? (f = H4(l, a.instance.$)) == null ? void 0 : f.provides : (v = l.ctx) == null ? void 0 : v.provides) ? ? a.instance.$.provides,
            c = ht(e, te(r, i), s);
        c.appContext = Object.assign(Object.create(null), a.instance.$.appContext, {
            provides: u
        }), Vo(c, n)
    }
}

function H4(e, t) {
    const n = new Set,
        a = r => {
            var o, i;
            for (const s of r) {
                if (!s) continue;
                if (s === e) return !0;
                n.add(s);
                let u;
                if (s.suspense ? u = a([s.ssContent]) : Array.isArray(s.children) ? u = a(s.children) : (o = s.component) != null && o.vnode && (u = a([(i = s.component) == null ? void 0 : i.subTree])), u) return u;
                n.delete(s)
            }
            return !1
        };
    if (!a([t.subTree])) throw new Error("Could not find original vnode");
    const l = Array.from(n).reverse();
    for (const r of l)
        if (r.component) return r.component;
    return t
}
const j4 = B4(dC, e => {
        var t;
        return {
            activator: "parent",
            location: ((t = e.arg) == null ? void 0 : t.replace("-", " ")) ? ? "top",
            text: typeof e.value == "boolean" ? void 0 : e.value
        }
    }),
    U4 = Object.freeze(Object.defineProperty({
        __proto__: null,
        ClickOutside: Dw,
        Intersect: fi,
        Mutate: O4,
        Resize: M4,
        Ripple: Ia,
        Scroll: $4,
        Tooltip: j4,
        Touch: sm
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    W4 = W({
        allDay: Boolean,
        interval: Object,
        intervalDivisions: {
            type: Number,
            required: !0
        },
        intervalDuration: {
            type: Number,
            required: !0
        },
        intervalHeight: {
            type: Number,
            required: !0
        },
        event: Object
    }, "VCalendarIntervalEvent"),
    yf = Z()({
        name: "VCalendarIntervalEvent",
        props: W4(),
        setup(e) {
            const t = ia(),
                n = () => {
                    var a, l, r, o;
                    if (!((a = e.event) != null && a.first) && !((l = e.event) != null && l.last) || t.isEqual((r = e.event) == null ? void 0 : r.start, (o = e.interval) == null ? void 0 : o.start)) return {
                        height: "100%",
                        margin: ge(0)
                    }; {
                        const {
                            height: i,
                            margin: s
                        } = Array.from({
                            length: e.intervalDivisions
                        }, u => u * (e.intervalDuration / e.intervalDivisions)).reduce((u, c, d) => {
                            var f, v;
                            return t.isBefore(t.addMinutes((f = e.interval) == null ? void 0 : f.start, c), (v = e.event) == null ? void 0 : v.start) ? {
                                height: ge(e.intervalHeight / e.intervalDivisions * d),
                                margin: ge(e.intervalHeight / e.intervalDivisions * d)
                            } : {
                                height: u.height,
                                margin: u.margin
                            }
                        }, {
                            height: "",
                            margin: ""
                        });
                        return {
                            height: i,
                            margin: s
                        }
                    }
                };
            return ne(() => {
                var a, l, r, o, i;
                return m(Qa, {
                    height: n().height,
                    density: "comfortable",
                    style: `margin-top: ${n().margin}`,
                    class: "v-calendar-internal-event",
                    color: ((a = e.event) == null ? void 0 : a.color) ? ? void 0,
                    rounded: (l = e.event) != null && l.first && ((r = e.event) != null && r.last) ? !0 : (o = e.event) != null && o.first ? "t" : (i = e.event) != null && i.last ? "b" : !1
                }, {
                    default: () => {
                        var s, u;
                        return [(s = e.event) != null && s.first ? (u = e.event) == null ? void 0 : u.title : ""]
                    }
                })
            }), {}
        }
    }),
    hC = W({
        day: {
            type: Object,
            default: () => ({})
        },
        dayIndex: Number,
        events: Array,
        intervalDivisions: {
            type: Number,
            default: 2
        },
        intervalDuration: {
            type: Number,
            default: 60
        },
        intervalHeight: {
            type: Number,
            default: 48
        },
        intervalFormat: {
            type: [String, Function],
            default: "fullTime12h"
        },
        intervalStart: {
            type: Number,
            default: 0
        }
    }, "VCalendarInterval"),
    bf = Z()({
        name: "VCalendarInterval",
        props: {
            index: {
                type: Number,
                required: !0
            },
            ...hC()
        },
        setup(e, t) {
            const n = ia(),
                a = C(() => {
                    const l = n.addMinutes(n.startOfDay(e.day.date), e.intervalDuration * (e.index + e.intervalStart)),
                        r = n.addMinutes(n.startOfDay(e.day.date), e.intervalDuration * (e.index + e.intervalStart + 1) - 1);
                    return { ...e.day,
                        label: n.format(l, "fullTime24h"),
                        start: l,
                        end: r,
                        events: e.events ? e.events.filter(o => !o.allDay && (n.isEqual(l, o.start) || n.isWithinRange(o.start, [l, r]) || n.isWithinRange(l, [o.start, o.end]) || n.isEqual(r, o.end))).map(o => ({ ...o,
                            first: n.isEqual(l, o.start) || n.isWithinRange(o.start, [l, r]),
                            last: n.isEqual(r, o.end) || n.isWithinRange(o.end, [l, r])
                        })) : []
                    }
                });
            return ne(() => {
                var l, r;
                return e.dayIndex === 0 ? m("div", {
                    class: "v-calendar-day__row-with-label",
                    style: `height: ${ge(e.intervalHeight)}`
                }, [m("div", {
                    class: "v-calendar-day__row-label"
                }, [m("slot", {
                    name: "intervalFormat",
                    interval: a.value
                }, [e.index ? e.intervalFormat ? typeof e.intervalFormat == "string" ? n.format(a.value.start, "hours12h") : e.intervalFormat(a.value) : a.value.label : ""])]), m("div", {
                    class: "v-calendar-day__row-hairline"
                }, null), m("div", {
                    class: ["v-calendar-day__row-content", a.value.events.some(o => !o.last) ? "v-calendar-day__row-content-through" : ""]
                }, [m("slot", {
                    name: "intervalBody",
                    interval: a.value
                }, [(l = a.value.events) == null ? void 0 : l.map(o => m(yf, {
                    event: o,
                    interval: a.value,
                    intervalDivisions: e.intervalDivisions,
                    intervalDuration: e.intervalDuration,
                    intervalHeight: e.intervalHeight
                }, null))])])]) : m("div", {
                    class: "v-calendar-day__row-without-label",
                    style: `height: ${ge(e.intervalHeight)}`
                }, [m("div", {
                    class: ["v-calendar-day__row-content", a.value.events.some(o => !o.last) ? "v-calendar-day__row-content-through" : ""]
                }, [m("slot", {
                    name: "intervalBody",
                    interval: a.value
                }, [(r = a.value.events) == null ? void 0 : r.filter(o => !o.allDay).map(o => m(yf, {
                    event: o,
                    interval: a.value,
                    intervalDivisions: e.intervalDivisions,
                    intervalDuration: e.intervalDuration,
                    intervalHeight: e.intervalHeight
                }, null))])])])
            }), {
                interval: a
            }
        }
    }),
    gC = W({
        hideDayHeader: Boolean,
        intervals: {
            type: Number,
            default: 24
        },
        ...hC()
    }, "VCalendarDay"),
    ns = Z()({
        name: "VCalendarDay",
        props: gC(),
        setup(e) {
            const t = ia(),
                n = C(() => [...Array.from({
                    length: e.intervals
                }, (a, l) => l).filter((a, l) => e.intervalDuration * (l + e.intervalStart) < 1440)]);
            return ne(() => {
                const a = bf.filterProps(e);
                return m("div", {
                    class: "v-calendar-day__container"
                }, [!e.hideDayHeader && m("div", {
                    key: "calender-week-name",
                    class: "v-calendar-weekly__head-weekday"
                }, [t.format(e.day.date, "weekdayShort"), m("div", null, [m(Le, {
                    icon: !0,
                    text: t.format(e.day.date, "dayOfMonth"),
                    variant: "text"
                }, null)])]), n.value.map((l, r) => m(bf, te({
                    index: r
                }, a), null))])
            }), {
                intervals: n
            }
        }
    }),
    yC = W({
        nextIcon: {
            type: String,
            default: "$next"
        },
        prevIcon: {
            type: String,
            default: "$prev"
        },
        title: String,
        text: {
            type: String,
            default: "$vuetify.calendar.today"
        },
        viewMode: {
            type: String,
            default: "month"
        }
    }, "VCalendarHeader"),
    pf = Z()({
        name: "VCalendarHeader",
        props: yC(),
        emits: {
            "click:next": () => !0,
            "click:prev": () => !0,
            "click:toToday": () => !0
        },
        setup(e, t) {
            let {
                emit: n
            } = t;
            const {
                t: a
            } = Qe();

            function l() {
                n("click:prev")
            }

            function r() {
                n("click:next")
            }

            function o() {
                n("click:toToday")
            }
            return ne(() => m("div", {
                class: "v-calendar-header"
            }, [e.text && m(Le, {
                key: "today",
                class: "v-calendar-header__today",
                text: a(e.text),
                variant: "outlined",
                onClick: o
            }, null), m(Le, {
                density: "comfortable",
                icon: e.prevIcon,
                variant: "text",
                onClick: l
            }, null), m(Le, {
                density: "comfortable",
                icon: e.nextIcon,
                variant: "text",
                onClick: r
            }, null), m("div", {
                class: "v-calendar-header__title"
            }, [e.title])])), {}
        }
    }),
    z4 = W({
        allDay: Boolean,
        day: Object,
        event: Object
    }, "VCalendarEvent"),
    lb = Z()({
        name: "VCalendarEvent",
        props: z4(),
        setup(e) {
            return ne(() => m(Zl, {
                color: e.allDay ? "primary" : void 0,
                density: "comfortable",
                label: e.allDay,
                width: "100%"
            }, {
                default: () => {
                    var t, n;
                    return [m(Fw, {
                        inline: !0,
                        dot: !0,
                        color: (t = e.event) == null ? void 0 : t.color
                    }, null), (n = e.event) == null ? void 0 : n.title]
                }
            })), {}
        }
    }),
    K4 = W({
        active: Boolean,
        color: String,
        day: Object,
        disabled: Boolean,
        events: Array,
        title: [Number, String]
    }, "VCalendarMonthDay"),
    bC = Z()({
        name: "VCalendarMonthDay",
        props: K4(),
        setup(e, t) {
            let {
                emit: n,
                slots: a
            } = t;
            return ne(() => {
                var r, o, i, s, u, c, d, f, v, g, h;
                const l = !!(e.title || (r = a.title) != null && r.call(a, {
                    title: e.title
                }));
                return m("div", {
                    class: ["v-calendar-month__day"]
                }, [!((o = e.day) != null && o.isHidden) && l && m("div", {
                    key: "title",
                    class: "v-calendar-weekly__day-label"
                }, [((i = a.title) == null ? void 0 : i.call(a, {
                    title: e.title
                })) ? ? m(Le, {
                    class: (s = e.day) != null && s.isToday ? "v-calendar-weekly__day-label__today" : void 0,
                    color: e.color,
                    disabled: e.disabled,
                    icon: !0,
                    size: "x-small",
                    variant: (u = e.day) != null && u.isToday ? void 0 : "flat"
                }, {
                    default: () => [e.title]
                })]), !((c = e.day) != null && c.isHidden) && m("div", {
                    key: "content",
                    class: "v-calendar-weekly__day-content"
                }, [((d = a.content) == null ? void 0 : d.call(a)) ? ? m("div", null, [m("div", {
                    class: "v-calendar-weekly__day-alldayevents-container"
                }, [(f = e.events) == null ? void 0 : f.filter(y => y.allDay).map(y => a.event ? a.event({
                    day: e.day,
                    allDay: !0,
                    event: y
                }) : m(lb, {
                    day: e.day,
                    event: y,
                    allDay: !0
                }, null))]), m("div", {
                    class: "v-calendar-weekly__day-events-container"
                }, [(v = e.events) == null ? void 0 : v.filter(y => !y.allDay).map(y => a.event ? a.event({
                    day: e.day,
                    event: y,
                    allDay: !1
                }) : m(lb, {
                    day: e.day,
                    event: y
                }, null))])])]), !((g = e.day) != null && g.isHidden) && ((h = a.default) == null ? void 0 : h.call(a))])
            }), {}
        }
    }),
    G4 = W({
        hideHeader: Boolean,
        hideWeekNumber: Boolean,
        ...Fk(),
        ...gC(),
        ...yC()
    }, "VCalender"),
    Y4 = Z()({
        name: "VCalendar",
        props: G4(),
        emits: {
            next: null,
            prev: null,
            "update:modelValue": null
        },
        setup(e, t) {
            let {
                emit: n,
                slots: a
            } = t;
            const l = ia(),
                {
                    daysInMonth: r,
                    daysInWeek: o,
                    genDays: i,
                    model: s,
                    displayValue: u,
                    weekNumbers: c,
                    weekDays: d
                } = Hk(e),
                f = l.getWeekdays();

            function v() {
                e.viewMode === "month" && (s.value = [l.addMonths(u.value, 1)]), e.viewMode === "week" && (s.value = [l.addDays(u.value, 7)]), e.viewMode === "day" && (s.value = [l.addDays(u.value, 1)])
            }

            function g() {
                e.viewMode === "month" && (s.value = [l.addMonths(u.value, -1)]), e.viewMode === "week" && (s.value = [l.addDays(u.value, -7)]), e.viewMode === "day" && (s.value = [l.addDays(u.value, -1)])
            }

            function h() {
                s.value = [l.date()]
            }
            const y = C(() => l.format(u.value, "monthAndYear"));
            return ne(() => {
                var p;
                const S = ns.filterProps(e),
                    b = pf.filterProps(e);
                return m("div", {
                    class: ["v-calendar", {
                        "v-calendar-monthly": e.viewMode === "month",
                        "v-calendar-weekly": e.viewMode === "week",
                        "v-calendar-day": e.viewMode === "day"
                    }]
                }, [m("div", null, [!e.hideHeader && (a.header ? a.header({
                    title: y.value
                }) : m(pf, te({
                    key: "calendar-header"
                }, b, {
                    title: y.value,
                    "onClick:next": v,
                    "onClick:prev": g,
                    "onClick:toToday": h
                }), null))]), m("div", {
                    class: ["v-calendar__container", `days__${d.value.length}`]
                }, [e.viewMode === "month" && !e.hideDayHeader && m("div", {
                    class: ["v-calendar-weekly__head", `days__${d.value.length}`, ...e.hideWeekNumber ? [] : ["v-calendar-weekly__head-weeknumbers"]],
                    key: "calenderWeeklyHead"
                }, [e.hideWeekNumber ? "" : m("div", {
                    key: "weekNumber0",
                    class: "v-calendar-weekly__head-weeknumber"
                }, null), d.value.map(_ => m("div", {
                    class: `v-calendar-weekly__head-weekday${e.hideWeekNumber?"":"-with-weeknumber"}`
                }, [f[_]]))]), e.viewMode === "month" && m("div", {
                    key: "VCalendarMonth",
                    class: ["v-calendar-month__days", `days${e.hideWeekNumber?"":"-with-weeknumbers"}__${d.value.length}`, ...e.hideWeekNumber ? [] : ["v-calendar-month__weeknumbers"]]
                }, [DD(r.value, d.value.length).map((_, w) => [e.hideWeekNumber ? "" : m("div", {
                    class: "v-calendar-month__weeknumber"
                }, [c.value[w]]), _.map(k => {
                    var E;
                    return m(bC, {
                        color: l.isSameDay(l.date(), k.date) ? "primary" : void 0,
                        day: k,
                        title: k ? l.format(k.date, "dayOfMonth") : "NaN",
                        events: (E = e.events) == null ? void 0 : E.filter(P => l.isSameDay(k.date, P.start) || l.isSameDay(k.date, P.end))
                    }, {
                        event: a.event
                    })
                })])]), e.viewMode === "week" && o.value.map((_, w) => {
                    var k;
                    return m(ns, te(S, {
                        day: _,
                        dayIndex: w,
                        events: (k = e.events) == null ? void 0 : k.filter(E => l.isSameDay(E.start, _.date) || l.isSameDay(E.end, _.date))
                    }), null)
                }), e.viewMode === "day" && m(ns, te(S, {
                    day: i([u.value], l.date())[0],
                    dayIndex: 0,
                    events: (p = e.events) == null ? void 0 : p.filter(_ => l.isSameDay(_.start, i([u.value], l.date())[0].date) || l.isSameDay(_.end, i([u.value], l.date())[0].date))
                }), null)])])
            }), {
                daysInMonth: r,
                daysInWeek: o,
                genDays: i
            }
        }
    }),
    q4 = W({
        hideActions: Boolean,
        ...qr(),
        ...lk(),
        ...Jr({
            placeholder: "mm/dd/yyyy",
            prependIcon: "$calendar"
        }),
        ...We(Kk({
            weeksInMonth: "dynamic",
            hideHeader: !0
        }), ["active"])
    }, "VDateInput"),
    X4 = Z()({
        name: "VDateInput",
        props: q4(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                t: a
            } = Qe(), l = ia(), {
                isFocused: r,
                focus: o,
                blur: i
            } = ua(e), s = Ce(e, "modelValue", e.multiple ? [] : null), u = fe(!1), c = C(() => {
                const h = nt(s.value);
                if (!h.length) return null;
                if (e.multiple === !0) return a("$vuetify.datePicker.itemsSelected", h.length);
                if (e.multiple === "range") {
                    const y = h[0],
                        S = h[h.length - 1];
                    return l.isValid(y) && l.isValid(S) ? `${l.format(y,"keyboardDate")} - ${l.format(S,"keyboardDate")}` : ""
                }
                return l.isValid(s.value) ? l.format(s.value, "keyboardDate") : ""
            }), d = C(() => !e.disabled && !e.readonly);

            function f(h) {
                if (h.key !== "Enter") return;
                if (!u.value || !r.value) {
                    u.value = !0;
                    return
                }
                const y = h.target;
                s.value = l.date(y.value)
            }

            function v(h) {
                h.preventDefault(), h.stopPropagation(), u.value = !0
            }

            function g() {
                u.value = !1
            }
            ne(() => {
                const h = nf.filterProps(e),
                    y = df.filterProps(We(e, ["active"])),
                    S = Un.filterProps(e);
                return m(Un, te(S, {
                    class: e.class,
                    style: e.style,
                    modelValue: c.value,
                    onKeydown: d.value ? f : void 0,
                    focused: u.value || r.value,
                    onFocus: o,
                    onBlur: i,
                    "onClick:control": d.value ? v : void 0,
                    "onClick:prepend": d.value ? v : void 0
                }), {
                    default: () => {
                        var b;
                        return [m(Ol, {
                            modelValue: u.value,
                            "onUpdate:modelValue": p => u.value = p,
                            activator: "parent",
                            "min-width": "0",
                            closeOnContentClick: !1,
                            openOnClick: !1
                        }, {
                            default: () => [m(nf, te(h, {
                                modelValue: s.value,
                                "onUpdate:modelValue": p => s.value = p,
                                onSave: g
                            }), {
                                default: p => {
                                    let {
                                        actions: _,
                                        model: w
                                    } = p;
                                    return m(df, te(y, {
                                        modelValue: e.hideActions ? s.value : w.value,
                                        "onUpdate:modelValue": k => {
                                            e.hideActions ? (s.value = k, e.multiple || (u.value = !1)) : w.value = k
                                        },
                                        onMousedown: k => k.preventDefault()
                                    }), {
                                        actions: e.hideActions ? void 0 : () => _
                                    })
                                }
                            })]
                        }), (b = n.default) == null ? void 0 : b.call(n)]
                    }
                })
            })
        }
    }),
    J4 = W({
        controlVariant: {
            type: String,
            default: "default"
        },
        inset: Boolean,
        hideInput: Boolean,
        modelValue: {
            type: Number,
            default: null
        },
        min: {
            type: Number,
            default: Number.MIN_SAFE_INTEGER
        },
        max: {
            type: Number,
            default: Number.MAX_SAFE_INTEGER
        },
        step: {
            type: Number,
            default: 1
        },
        ...We(Jr({}), ["appendInnerIcon", "modelValue", "prependInnerIcon"])
    }, "VNumberInput"),
    Z4 = Z()({
        name: "VNumberInput",
        props: { ...J4()
        },
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Ce(e, "modelValue"),
                l = C({
                    get: () => a.value,
                    set(T) {
                        if (T === null) {
                            a.value = null;
                            return
                        }!isNaN(+T) && +T <= e.max && +T >= e.min && (a.value = +T)
                    }
                }),
                r = Q(),
                o = C(() => Ts(e.step)),
                i = C(() => typeof l.value == "number" ? Ts(l.value) : 0),
                s = gi(),
                u = C(() => e.disabled || e.readonly || (s == null ? void 0 : s.isReadonly.value)),
                c = C(() => u.value ? !1 : (l.value ? ? 0) + e.step <= e.max),
                d = C(() => u.value ? !1 : (l.value ? ? 0) - e.step >= e.min),
                f = C(() => e.hideInput ? "stacked" : e.controlVariant),
                v = C(() => f.value === "split" ? "$plus" : "$collapse"),
                g = C(() => f.value === "split" ? "$minus" : "$expand"),
                h = C(() => f.value === "split" ? "default" : "small"),
                y = C(() => f.value === "stacked" ? "auto" : "100%"),
                S = C(() => ({
                    click: _
                })),
                b = C(() => ({
                    click: w
                }));
            it(() => {
                !e.readonly && !e.disabled && x()
            });

            function p() {
                let T = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
                if (u.value) return;
                if (l.value == null) {
                    l.value = ot(0, e.min, e.max);
                    return
                }
                const V = Math.max(i.value, o.value);
                T ? c.value && (l.value = +(l.value + e.step).toFixed(V)) : d.value && (l.value = +(l.value - e.step).toFixed(V))
            }

            function _(T) {
                T.stopPropagation(), p()
            }

            function w(T) {
                T.stopPropagation(), p(!1)
            }

            function k(T) {
                var $, D, z;
                if (!T.data) return;
                const V = ($ = T.target) == null ? void 0 : $.value,
                    I = (D = T.target) == null ? void 0 : D.selectionStart,
                    R = (z = T.target) == null ? void 0 : z.selectionEnd,
                    B = V ? V.slice(0, I) + T.data + V.slice(R) : T.data;
                /^-?(\d+(\.\d*)?|(\.\d+)|\d*|\.)$/.test(B) || T.preventDefault()
            }
            async function E(T) {
                ["Enter", "ArrowLeft", "ArrowRight", "Backspace", "Delete", "Tab"].includes(T.key) || T.ctrlKey || ["ArrowDown", "ArrowUp"].includes(T.key) && (T.preventDefault(), x(), await Re(), T.key === "ArrowDown" ? p(!1) : p())
            }

            function P(T) {
                T.stopPropagation()
            }

            function x() {
                if (!r.value) return;
                const T = r.value.value;
                T && !isNaN(+T) ? l.value = ot(+T, e.min, e.max) : l.value = null
            }
            return ne(() => {
                const {
                    modelValue: T,
                    ...V
                } = Un.filterProps(e);

                function I() {
                    return n.increment ? m(Ve, {
                        key: "increment-defaults",
                        defaults: {
                            VBtn: {
                                disabled: !c.value,
                                flat: !0,
                                height: y.value,
                                size: h.value,
                                icon: v.value
                            }
                        }
                    }, {
                        default: () => [n.increment(S.value)]
                    }) : m(Le, {
                        disabled: !c.value,
                        flat: !0,
                        key: "increment-btn",
                        height: y.value,
                        name: "increment-btn",
                        icon: v.value,
                        onClick: _,
                        onMousedown: P,
                        size: h.value,
                        tabindex: "-1"
                    }, null)
                }

                function R() {
                    return n.decrement ? m(Ve, {
                        key: "decrement-defaults",
                        defaults: {
                            VBtn: {
                                disabled: !d.value,
                                flat: !0,
                                height: y.value,
                                size: h.value,
                                icon: g.value
                            }
                        }
                    }, {
                        default: () => [n.decrement(b.value)]
                    }) : m(Le, {
                        disabled: !d.value,
                        flat: !0,
                        key: "decrement-btn",
                        height: y.value,
                        name: "decrement-btn",
                        icon: g.value,
                        size: h.value,
                        tabindex: "-1",
                        onClick: w,
                        onMousedown: P
                    }, null)
                }

                function B() {
                    return m("div", {
                        class: "v-number-input__control"
                    }, [R(), m(ya, {
                        vertical: f.value !== "stacked"
                    }, null), I()])
                }

                function $() {
                    return !e.hideInput && !e.inset ? m(ya, {
                        vertical: !0
                    }, null) : void 0
                }
                const D = f.value === "split" ? m("div", {
                        class: "v-number-input__control"
                    }, [m(ya, {
                        vertical: !0
                    }, null), I()]) : e.reverse ? void 0 : m(ye, null, [$(), B()]),
                    z = n["append-inner"] || D,
                    N = f.value === "split" ? m("div", {
                        class: "v-number-input__control"
                    }, [R(), m(ya, {
                        vertical: !0
                    }, null)]) : e.reverse ? m(ye, null, [B(), $()]) : void 0,
                    H = n["prepend-inner"] || N;
                return m(Un, te({
                    ref: r,
                    modelValue: l.value,
                    "onUpdate:modelValue": F => l.value = F,
                    onBeforeinput: k,
                    onChange: x,
                    onKeydown: E,
                    class: ["v-number-input", {
                        "v-number-input--default": f.value === "default",
                        "v-number-input--hide-input": e.hideInput,
                        "v-number-input--inset": e.inset,
                        "v-number-input--reverse": e.reverse,
                        "v-number-input--split": f.value === "split",
                        "v-number-input--stacked": f.value === "stacked"
                    }, e.class]
                }, V, {
                    style: e.style,
                    inputmode: "decimal"
                }), { ...n,
                    "append-inner": z ? function() {
                        var he;
                        for (var F = arguments.length, j = new Array(F), ae = 0; ae < F; ae++) j[ae] = arguments[ae];
                        return m(ye, null, [(he = n["append-inner"]) == null ? void 0 : he.call(n, ...j), D])
                    } : void 0,
                    "prepend-inner": H ? function() {
                        var he;
                        for (var F = arguments.length, j = new Array(F), ae = 0; ae < F; ae++) j[ae] = arguments[ae];
                        return m(ye, null, [N, (he = n["prepend-inner"]) == null ? void 0 : he.call(n, ...j)])
                    } : void 0
                })
            }), wn({}, r)
        }
    }),
    Q4 = W({ ...Em()
    }, "VStepperActions"),
    pC = Z()({
        name: "VStepperVerticalActions",
        props: Q4(),
        emits: {
            "click:prev": () => !0,
            "click:next": () => !0
        },
        setup(e, t) {
            let {
                emit: n,
                slots: a
            } = t;

            function l() {
                n("click:prev")
            }

            function r() {
                n("click:next")
            }
            return ne(() => {
                const o = $s.filterProps(e);
                return m($s, te({
                    class: "v-stepper-vertical-actions"
                }, o, {
                    "onClick:prev": l,
                    "onClick:next": r
                }), a)
            }), {}
        }
    }),
    ej = W({
        hideActions: Boolean,
        ...nC(),
        ...We(xm({
            expandIcon: "",
            collapseIcon: ""
        }), ["hideActions"])
    }, "VStepperVerticalItem"),
    _C = Z()({
        name: "VStepperVerticalItem",
        props: ej(),
        emits: {
            "click:next": () => !0,
            "click:prev": () => !0,
            "click:finish": () => !0
        },
        setup(e, t) {
            let {
                emit: n,
                slots: a
            } = t;
            const l = Q(),
                r = C(() => isNaN(parseInt(e.value)) ? e.value : Number(e.value)),
                o = C(() => {
                    var b;
                    return (b = l.value) == null ? void 0 : b.groupItem
                }),
                i = C(() => {
                    var b;
                    return ((b = o.value) == null ? void 0 : b.isSelected.value) ? ? !1
                }),
                s = C(() => i.value ? e.rules.every(b => b() === !0) : null),
                u = C(() => !e.disabled && e.editable),
                c = C(() => e.error || i.value && !s.value),
                d = C(() => e.complete || e.rules.length > 0 && s.value === !0),
                f = C(() => {
                    var b;
                    return e.disabled ? e.disabled : (b = o.value) != null && b.isFirst.value ? "prev" : !1
                }),
                v = C(() => {
                    var b;
                    return c.value ? e.errorIcon : d.value ? e.completeIcon : (b = o.value) != null && b.isSelected.value && e.editable ? e.editIcon : e.icon
                }),
                g = C(() => ({
                    canEdit: u.value,
                    hasError: c.value,
                    hasCompleted: d.value,
                    title: e.title,
                    subtitle: e.subtitle,
                    step: r.value,
                    value: e.value
                })),
                h = C(() => ({ ...g.value,
                    prev: S,
                    next: y
                }));

            function y() {
                var b;
                n("click:next"), !((b = o.value) != null && b.isLast.value) && o.value.group.next()
            }

            function S() {
                n("click:prev"), o.value.group.prev()
            }
            return ne(() => {
                var w;
                const b = (d.value || ((w = o.value) == null ? void 0 : w.isSelected.value)) && !c.value && !e.disabled,
                    p = !e.hideActions || !!a.actions,
                    _ = mf.filterProps(e);
                return m(mf, te({
                    _as: "VStepperVerticalItem",
                    ref: l
                }, _, {
                    class: ["v-stepper-vertical-item", {
                        "v-stepper-vertical-item--complete": d.value,
                        "v-stepper-vertical-item--disabled": e.disabled,
                        "v-stepper-vertical-item--editable": u.value,
                        "v-stepper-vertical-item--error": c.value
                    }, e.class],
                    readonly: !e.editable,
                    style: e.style,
                    color: "",
                    "hide-actions": !1,
                    value: r.value
                }), {
                    title: () => {
                        var k, E;
                        return m(ye, null, [m(yn, {
                            key: "stepper-avatar",
                            class: "v-stepper-vertical-item__avatar",
                            color: b ? e.color : void 0,
                            size: 24,
                            start: !0
                        }, {
                            default: () => {
                                var P;
                                return [((P = a.icon) == null ? void 0 : P.call(a, g.value)) ? ? (v.value ? m(Be, {
                                    icon: v.value
                                }, null) : r.value)]
                            }
                        }), m("div", null, [m("div", {
                            class: "v-stepper-vertical-item__title"
                        }, [((k = a.title) == null ? void 0 : k.call(a, g.value)) ? ? e.title]), m("div", {
                            class: "v-stepper-vertical-item__subtitle"
                        }, [((E = a.subtitle) == null ? void 0 : E.call(a, g.value)) ? ? e.subtitle])])])
                    },
                    text: () => {
                        var k, E;
                        return m(ye, null, [((k = a.default) == null ? void 0 : k.call(a, g.value)) ? ? e.text, p && m(Ve, {
                            defaults: {
                                VStepperVerticalActions: {
                                    disabled: f.value,
                                    finish: (E = o.value) == null ? void 0 : E.isLast.value
                                }
                            }
                        }, {
                            default: () => {
                                var P;
                                return [((P = a.actions) == null ? void 0 : P.call(a, h.value)) ? ? m(pC, {
                                    "onClick:next": y,
                                    "onClick:prev": S
                                }, {
                                    prev: a.prev ? () => {
                                        var x;
                                        return (x = a.prev) == null ? void 0 : x.call(a, h.value)
                                    } : void 0,
                                    next: a.next ? () => {
                                        var x;
                                        return (x = a.next) == null ? void 0 : x.call(a, h.value)
                                    } : void 0
                                })]
                            }
                        })])
                    }
                })
            }), {}
        }
    }),
    tj = W({
        prevText: {
            type: String,
            default: "$vuetify.stepper.prev"
        },
        nextText: {
            type: String,
            default: "$vuetify.stepper.next"
        },
        ...oC(),
        ...We(qk({
            mandatory: "force",
            variant: "accordion"
        }), ["static"])
    }, "VStepperVertical"),
    nj = Z()({
        name: "VStepperVertical",
        props: tj(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Q(),
                {
                    color: l,
                    eager: r,
                    editable: o,
                    prevText: i,
                    nextText: s,
                    hideActions: u
                } = ta(e),
                c = Ce(e, "modelValue"),
                d = C(() => e.items.map((f, v) => {
                    const g = vt(f, e.itemTitle, f),
                        h = vt(f, e.itemValue, v + 1);
                    return {
                        title: g,
                        value: h,
                        raw: f
                    }
                }));
            return lt({
                VStepperVerticalItem: {
                    color: l,
                    eager: r,
                    editable: o,
                    prevText: i,
                    nextText: s,
                    hideActions: u,
                    static: !0
                },
                VStepperActions: {
                    color: l
                }
            }), ne(() => {
                const f = hf.filterProps(e);
                return m(hf, te(f, {
                    modelValue: c.value,
                    "onUpdate:modelValue": v => c.value = v,
                    ref: a,
                    class: ["v-stepper", {
                        "v-stepper--alt-labels": e.altLabels,
                        "v-stepper--flat": e.flat,
                        "v-stepper--non-linear": e.nonLinear,
                        "v-stepper--mobile": e.mobile
                    }, e.class],
                    style: e.style
                }), { ...n,
                    default: v => {
                        var y;
                        let {
                            prev: g,
                            next: h
                        } = v;
                        return m(ye, null, [d.value.map(S => {
                            let {
                                raw: b,
                                ...p
                            } = S;
                            return m(_C, p, { ...n,
                                default: n[`item.${p.value}`]
                            })
                        }), (y = n.default) == null ? void 0 : y.call(n, {
                            prev: g,
                            next: h,
                            step: c.value
                        })])
                    }
                })
            }), {}
        }
    }),
    aj = Z()({
        name: "VPullToRefresh",
        props: {
            disabled: Boolean,
            pullDownThreshold: {
                type: Number,
                default: 64
            }
        },
        emits: {
            load: e => !0
        },
        setup(e, t) {
            let {
                slots: n,
                emit: a
            } = t, l = 0, r = [];
            const o = fe(0),
                i = Q(),
                s = fe(!1),
                u = fe(!1),
                c = fe(!1),
                d = C(() => o.value >= e.pullDownThreshold && !s.value),
                f = C(() => ot(o.value, 0, e.pullDownThreshold));

            function v(y) {
                s.value || e.disabled || (c.value = !0, l = "clientY" in y ? y.clientY : y.touches[0].clientY)
            }

            function g(y) {
                if (s.value || !c.value || e.disabled) return;
                const S = "clientY" in y ? y.clientY : y.touches[0].clientY;
                r.length && !r[0].scrollTop && (o.value = S - l)
            }

            function h(y) {
                s.value || e.disabled || (c.value = !1, d.value ? (a("load", {
                    done: function() {
                        s.value && (o.value = 0, s.value = !1)
                    }
                }), s.value = !0) : o.value = 0)
            }
            it(() => {
                r = Bo(i.value)
            }), de([f, s], () => {
                if (r.length) {
                    const y = f.value && !s.value;
                    r.forEach(S => S.style.overflow = y ? "hidden" : "auto")
                }
            }), de(f, (y, S) => {
                u.value = y < S
            }), ne(() => {
                var y;
                return m("div", {
                    class: ["v-pull-to-refresh"],
                    onTouchstart: v,
                    onTouchmove: g,
                    onTouchend: h,
                    onMousedown: v,
                    onMouseup: h,
                    onMouseleave: h,
                    onMousemove: g,
                    ref: i
                }, [m("div", {
                    class: ["v-pull-to-refresh__pull-down", {
                        "v-pull-to-refresh__pull-down--touching": c.value
                    }],
                    style: {
                        top: ge(-1 * e.pullDownThreshold + f.value),
                        height: ge(e.pullDownThreshold)
                    }
                }, [n.pullDownPanel ? n.pullDownPanel({
                    canRefresh: d.value,
                    goingUp: u.value,
                    refreshing: s.value
                }) : m("div", {
                    class: ["v-pull-to-refresh__pull-down-default"]
                }, [s.value ? m(Ja, {
                    indeterminate: !0,
                    active: !1
                }, null) : m(Be, {
                    icon: d.value || u.value ? "$sortAsc" : "$sortDesc"
                }, null)])]), m("div", {
                    class: ["v-pull-to-refresh__scroll-container", {
                        "v-pull-to-refresh__scroll-container--touching": c.value
                    }],
                    style: {
                        top: ge(f.value)
                    }
                }, [(y = n.default) == null ? void 0 : y.call(n)])])
            })
        }
    }),
    lj = W({
        closable: [Boolean, String],
        closeText: {
            type: String,
            default: "$vuetify.dismiss"
        },
        modelValue: {
            type: Array,
            default: () => []
        },
        ...We(Jk(), ["modelValue"])
    }, "VSnackbarQueue"),
    rj = Z()({
        name: "VSnackbarQueue",
        props: lj(),
        emits: {
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                emit: n,
                slots: a
            } = t;
            const {
                t: l
            } = Qe(), r = fe(!1), o = fe(!1), i = fe();
            de(() => e.modelValue.length, (f, v) => {
                !o.value && f > v && u()
            }), de(r, f => {
                f && (o.value = !0)
            });

            function s() {
                e.modelValue.length ? u() : (i.value = void 0, o.value = !1)
            }

            function u() {
                const [f, ...v] = e.modelValue;
                n("update:modelValue", v), i.value = typeof f == "string" ? {
                    text: f
                } : f, Re(() => {
                    r.value = !0
                })
            }

            function c() {
                r.value = !1
            }
            const d = C(() => ({
                color: typeof e.closable == "string" ? e.closable : void 0,
                text: l(e.closeText)
            }));
            ne(() => {
                const f = !!(e.closable || a.actions),
                    {
                        modelValue: v,
                        ...g
                    } = gf.filterProps(e);
                return m(ye, null, [o.value && !!i.value && (a.default ? m(Ve, {
                    defaults: {
                        VSnackbar: i.value
                    }
                }, {
                    default: () => [a.default({
                        item: i.value
                    })]
                }) : m(gf, te(g, i.value, {
                    modelValue: r.value,
                    "onUpdate:modelValue": h => r.value = h,
                    onAfterLeave: s
                }), {
                    text: a.text ? () => {
                        var h;
                        return (h = a.text) == null ? void 0 : h.call(a, {
                            item: i.value
                        })
                    } : void 0,
                    actions: f ? () => m(ye, null, [a.actions ? m(Ve, {
                        defaults: {
                            VBtn: d.value
                        }
                    }, {
                        default: () => [a.actions({
                            item: i.value,
                            props: {
                                onClick: c
                            }
                        })]
                    }) : m(Le, te(d.value, {
                        onClick: c
                    }), null)]) : void 0
                }))])
            })
        }
    }),
    oj = W({
        allowedValues: Function,
        ampm: Boolean,
        color: String,
        disabled: Boolean,
        displayedValue: null,
        double: Boolean,
        format: {
            type: Function,
            default: e => e
        },
        max: {
            type: Number,
            required: !0
        },
        min: {
            type: Number,
            required: !0
        },
        scrollable: Boolean,
        readonly: Boolean,
        rotate: {
            type: Number,
            default: 0
        },
        step: {
            type: Number,
            default: 1
        },
        modelValue: {
            type: Number
        }
    }, "VTimePickerClock"),
    _f = Z()({
        name: "VTimePickerClock",
        props: oj(),
        emits: {
            change: e => !0,
            input: e => !0
        },
        setup(e, t) {
            let {
                emit: n
            } = t;
            const a = Q(null),
                l = Q(null),
                r = Q(void 0),
                o = Q(!1),
                i = Q(null),
                s = Q(null),
                {
                    textColorClasses: u,
                    textColorStyles: c
                } = Ot(Y(e, "color")),
                {
                    backgroundColorClasses: d,
                    backgroundColorStyles: f
                } = Ke(Y(e, "color")),
                v = C(() => e.max - e.min + 1),
                g = C(() => e.double ? v.value / 2 : v.value),
                h = C(() => 360 / g.value),
                y = C(() => h.value * Math.PI / 180),
                S = C(() => e.modelValue == null ? e.min : e.modelValue),
                b = C(() => .62),
                p = C(() => {
                    const N = [];
                    for (let H = e.min; H <= e.max; H = H + e.step) N.push(H);
                    return N
                });
            de(() => e.modelValue, N => {
                r.value = N
            });

            function _(N) {
                r.value !== N && (r.value = N), n("input", N)
            }

            function w(N) {
                return !e.allowedValues || e.allowedValues(N)
            }

            function k(N) {
                if (!e.scrollable || e.disabled) return;
                N.preventDefault();
                const H = Math.sign(-N.deltaY || 1);
                let F = S.value;
                do F = F + H, F = (F - e.min + v.value) % v.value + e.min; while (!w(F) && F !== S.value);
                F !== e.displayedValue && _(F)
            }

            function E(N) {
                return e.double && N - e.min >= g.value
            }

            function P(N) {
                return E(N) ? b.value : 1
            }

            function x(N) {
                const H = e.rotate * Math.PI / 180;
                return {
                    x: Math.sin((N - e.min) * y.value + H) * P(N),
                    y: -Math.cos((N - e.min) * y.value + H) * P(N)
                }
            }

            function T(N, H) {
                const F = (Math.round(N / h.value) + (H ? g.value : 0)) % v.value + e.min;
                return N < 360 - h.value / 2 ? F : H ? e.max - g.value + 1 : e.min
            }

            function V(N) {
                const {
                    x: H,
                    y: F
                } = x(N);
                return {
                    left: `${50+H*50}%`,
                    top: `${50+F*50}%`
                }
            }

            function I(N, H) {
                const F = H.x - N.x,
                    j = H.y - N.y;
                return Math.sqrt(F * F + j * j)
            }

            function R(N, H) {
                const F = 2 * Math.atan2(H.y - N.y - I(N, H), H.x - N.x);
                return Math.abs(F * 180 / Math.PI)
            }

            function B(N) {
                i.value === null && (i.value = N), s.value = N, _(N)
            }

            function $(N) {
                var re, pe;
                if (N.preventDefault(), !o.value && N.type !== "click" || !a.value) return;
                const {
                    width: H,
                    top: F,
                    left: j
                } = (re = a.value) == null ? void 0 : re.getBoundingClientRect(), {
                    width: ae
                } = ((pe = l.value) == null ? void 0 : pe.getBoundingClientRect()) ? ? {
                    width: 0
                }, {
                    clientX: he,
                    clientY: ve
                } = "touches" in N ? N.touches[0] : N, we = {
                    x: H / 2,
                    y: -H / 2
                }, ee = {
                    x: he - j,
                    y: F - ve
                }, G = Math.round(R(we, ee) - e.rotate + 360) % 360, le = e.double && I(we, ee) < (ae + ae * b.value) / 4, se = Math.ceil(15 / h.value);
                let ce;
                for (let A = 0; A < se; A++)
                    if (ce = T(G + A * h.value, le), w(ce) || (ce = T(G - A * h.value, le), w(ce))) return B(ce)
            }

            function D(N) {
                e.disabled || (N.preventDefault(), window.addEventListener("mousemove", $), window.addEventListener("touchmove", $), window.addEventListener("mouseup", z), window.addEventListener("touchend", z), i.value = null, s.value = null, o.value = !0, $(N))
            }

            function z(N) {
                N.stopPropagation(), window.removeEventListener("mousemove", $), window.removeEventListener("touchmove", $), window.removeEventListener("mouseup", z), window.removeEventListener("touchend", z), o.value = !1, s.value !== null && w(s.value) && n("change", s.value)
            }
            ne(() => m("div", {
                class: [{
                    "v-time-picker-clock": !0,
                    "v-time-picker-clock--indeterminate": e.modelValue == null,
                    "v-time-picker-clock--readonly": e.readonly
                }],
                onMousedown: D,
                onTouchstart: D,
                onWheel: k,
                ref: a
            }, [m("div", {
                class: "v-time-picker-clock__inner",
                ref: l
            }, [m("div", {
                class: [{
                    "v-time-picker-clock__hand": !0,
                    "v-time-picker-clock__hand--inner": E(e.modelValue)
                }, u.value],
                style: [{
                    transform: `rotate(${e.rotate+h.value*(S.value-e.min)}deg) scaleY(${P(S.value)})`
                }, c.value]
            }, null), p.value.map(N => {
                const H = N === S.value;
                return m("div", {
                    class: [{
                        "v-time-picker-clock__item": !0,
                        "v-time-picker-clock__item--active": H,
                        "v-time-picker-clock__item--disabled": e.disabled || !w(N)
                    }, H && d.value],
                    style: [V(N), H && f.value]
                }, [m("span", null, [e.format(N)])])
            })])]))
        }
    }),
    ij = (e, t, n) => (t = t >> 0, e = String(e), n = String(n), e.length > t ? String(e) : (t = t - e.length, t > n.length && (n += n.repeat(t / n.length)), n.slice(0, t) + String(e))),
    bl = function(e) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
        return ij(e, t, "0")
    };
var ft = function(e) {
    return e[e.Hour = 1] = "Hour", e[e.Minute = 2] = "Minute", e[e.Second = 3] = "Second", e
}(ft || {});
const sj = W({
        ampm: Boolean,
        ampmInTitle: Boolean,
        ampmReadonly: Boolean,
        color: String,
        disabled: Boolean,
        hour: Number,
        minute: Number,
        second: Number,
        period: String,
        readonly: Boolean,
        useSeconds: Boolean,
        selecting: Number,
        value: Number
    }, "VTimePickerControls"),
    Sf = Z()({
        name: "VTimePickerControls",
        props: sj(),
        emits: {
            "update:period": e => !0,
            "update:selecting": e => !0
        },
        setup(e, t) {
            let {
                emit: n,
                slots: a
            } = t;
            const {
                t: l
            } = Qe();
            return ne(() => {
                let r = e.hour;
                return e.ampm && (r = r ? (r - 1) % 12 + 1 : 12), m("div", {
                    class: "v-time-picker-controls"
                }, [m("div", {
                    class: {
                        "v-time-picker-controls__time": !0, "v-time-picker-controls__time--with-seconds": e.useSeconds
                    }
                }, [m(Le, {
                    active: e.selecting === 1,
                    color: e.selecting === 1 ? e.color : void 0,
                    disabled: e.disabled,
                    variant: "tonal",
                    class: {
                        "v-time-picker-controls__time__btn": !0, "v-time-picker-controls__time--with-ampm__btn": e.ampm, "v-time-picker-controls__time--with-seconds__btn": e.useSeconds
                    },
                    text: e.hour == null ? "--" : bl(`${r}`),
                    onClick: () => n("update:selecting", ft.Hour)
                }, null), m("span", {
                    class: ["v-time-picker-controls__time__separator", {
                        "v-time-picker-controls--with-seconds__time__separator": e.useSeconds
                    }]
                }, [hn(":")]), m(Le, {
                    active: e.selecting === 2,
                    color: e.selecting === 2 ? e.color : void 0,
                    class: {
                        "v-time-picker-controls__time__btn": !0, "v-time-picker-controls__time__btn__active": e.selecting === 2, "v-time-picker-controls__time--with-ampm__btn": e.ampm, "v-time-picker-controls__time--with-seconds__btn": e.useSeconds
                    },
                    disabled: e.disabled,
                    variant: "tonal",
                    text: e.minute == null ? "--" : bl(e.minute),
                    onClick: () => n("update:selecting", ft.Minute)
                }, null), e.useSeconds && m("span", {
                    class: ["v-time-picker-controls__time__separator", {
                        "v-time-picker-controls--with-seconds__time__separator": e.useSeconds
                    }],
                    key: "secondsDivider"
                }, [hn(":")]), e.useSeconds && m(Le, {
                    key: "secondsVal",
                    variant: "tonal",
                    onClick: () => n("update:selecting", ft.Second),
                    class: {
                        "v-time-picker-controls__time__btn": !0, "v-time-picker-controls__time__btn__active": e.selecting === 3, "v-time-picker-controls__time--with-seconds__btn": e.useSeconds
                    },
                    disabled: e.disabled,
                    text: e.second == null ? "--" : bl(e.second)
                }, null), e.ampm && e.ampmInTitle && m("div", {
                    class: ["v-time-picker-controls__ampm", {
                        "v-time-picker-controls__ampm--readonly": e.ampmReadonly
                    }]
                }, [m(Le, {
                    active: e.period === "am",
                    color: e.period === "am" ? e.color : void 0,
                    class: {
                        "v-time-picker-controls__ampm__am": !0, "v-time-picker-controls__ampm__btn": !0, "v-time-picker-controls__ampm__btn__active": e.period === "am"
                    },
                    disabled: e.disabled,
                    text: l("$vuetify.timePicker.am"),
                    variant: e.disabled && e.period === "am" ? "elevated" : "tonal",
                    onClick: () => e.period !== "am" ? n("update:period", "am") : null
                }, null), m(Le, {
                    active: e.period === "pm",
                    color: e.period === "pm" ? e.color : void 0,
                    class: {
                        "v-time-picker-controls__ampm__pm": !0, "v-time-picker-controls__ampm__btn": !0, "v-time-picker-controls__ampm__btn__active": e.period === "pm"
                    },
                    disabled: e.disabled,
                    text: l("$vuetify.timePicker.pm"),
                    variant: e.disabled && e.period === "pm" ? "elevated" : "tonal",
                    onClick: () => e.period !== "pm" ? n("update:period", "pm") : null
                }, null)])])])
            }), {}
        }
    }),
    uj = fn(24),
    SC = fn(12),
    cj = SC.map(e => e + 12);
fn(60);
const dj = {
        1: "hour",
        2: "minute",
        3: "second"
    },
    fj = W({
        allowedHours: [Function, Array],
        allowedMinutes: [Function, Array],
        allowedSeconds: [Function, Array],
        ampmInTitle: Boolean,
        disabled: Boolean,
        format: {
            type: String,
            default: "ampm"
        },
        max: String,
        min: String,
        modelValue: null,
        readonly: Boolean,
        scrollable: Boolean,
        useSeconds: Boolean,
        ...We(Cm({
            title: "$vuetify.timePicker.title"
        }), ["landscape"])
    }, "VTimePicker"),
    vj = Z()({
        name: "VTimePicker",
        props: fj(),
        emits: {
            "update:hour": e => !0,
            "update:minute": e => !0,
            "update:period": e => !0,
            "update:second": e => !0,
            "update:modelValue": e => !0
        },
        setup(e, t) {
            let {
                emit: n,
                slots: a
            } = t;
            const {
                t: l
            } = Qe(), r = Q(null), o = Q(null), i = Q(null), s = Q(null), u = Q(null), c = Q(null), d = Q("am"), f = Q(ft.Hour), v = Q(null), g = Q(null), h = C(() => {
                let I;
                if (e.allowedHours instanceof Array ? I = $ => e.allowedHours.includes($) : I = e.allowedHours, !e.min && !e.max) return I;
                const R = e.min ? Number(e.min.split(":")[0]) : 0,
                    B = e.max ? Number(e.max.split(":")[0]) : 23;
                return $ => $ >= R * 1 && $ <= B * 1 && (!I || I($))
            }), y = C(() => {
                let I;
                const R = !h.value || r.value === null || h.value(r.value);
                if (e.allowedMinutes instanceof Array ? I = F => e.allowedMinutes.includes(F) : I = e.allowedMinutes, !e.min && !e.max) return R ? I : () => !1;
                const [B, $] = e.min ? e.min.split(":").map(Number) : [0, 0], [D, z] = e.max ? e.max.split(":").map(Number) : [23, 59], N = B * 60 + $ * 1, H = D * 60 + z * 1;
                return F => {
                    const j = 60 * r.value + F;
                    return j >= N && j <= H && R && (!I || I(F))
                }
            }), S = C(() => {
                let I;
                const B = (!h.value || r.value === null || h.value(r.value)) && (!y.value || o.value === null || y.value(o.value));
                if (e.allowedSeconds instanceof Array ? I = he => e.allowedSeconds.includes(he) : I = e.allowedSeconds, !e.min && !e.max) return B ? I : () => !1;
                const [$, D, z] = e.min ? e.min.split(":").map(Number) : [0, 0, 0], [N, H, F] = e.max ? e.max.split(":").map(Number) : [23, 59, 59], j = $ * 3600 + D * 60 + (z || 0) * 1, ae = N * 3600 + H * 60 + (F || 0) * 1;
                return he => {
                    const ve = 3600 * r.value + 60 * o.value + he;
                    return ve >= j && ve <= ae && B && (!I || I(he))
                }
            }), b = C(() => e.format === "ampm");
            de(() => e.modelValue, I => E(I)), it(() => {
                E(e.modelValue)
            });

            function p() {
                return r.value != null && o.value != null && (!e.useSeconds || i.value != null) ? `${bl(r.value)}:${bl(o.value)}` + (e.useSeconds ? `:${bl(i.value)}` : "") : null
            }

            function _() {
                const I = p();
                I !== null && n("update:modelValue", I)
            }

            function w(I) {
                return I ? (I - 1) % 12 + 1 : 12
            }

            function k(I, R) {
                return I % 12 + (R === "pm" ? 12 : 0)
            }

            function E(I) {
                if (I == null || I === "") r.value = null, o.value = null, i.value = null;
                else if (I instanceof Date) r.value = I.getHours(), o.value = I.getMinutes(), i.value = I.getSeconds();
                else {
                    const [R, , B, , $, D] = I.trim().toLowerCase().match(/^(\d+):(\d+)(:(\d+))?([ap]m)?$/) || new Array(6);
                    r.value = D ? k(parseInt(R, 10), D) : parseInt(R, 10), o.value = parseInt(B, 10), i.value = parseInt($ || 0, 10)
                }
                d.value = r.value == null || r.value < 12 ? "am" : "pm"
            }

            function P(I, R) {
                const B = h.value;
                if (!B) return R;
                const $ = b.value ? R < 12 ? SC : cj : uj;
                return (($.find(z => B((z + R) % $.length + $[0])) || 0) + R) % $.length + $[0]
            }

            function x(I) {
                if (d.value = I, r.value != null) {
                    const R = r.value + (d.value === "am" ? -12 : 12);
                    r.value = P("hour", R)
                }
                return n("update:period", I), _(), !0
            }

            function T(I) {
                f.value === ft.Hour ? r.value = b.value ? k(I, d.value) : I : f.value === ft.Minute ? o.value = I : i.value = I
            }

            function V(I) {
                switch (dj[f.value]) {
                    case "hour":
                        n("update:hour", I);
                        break;
                    case "minute":
                        n("update:minute", I);
                        break;
                    case "second":
                        n("update:second", I);
                        break
                }
                const R = f.value === (e.useSeconds ? ft.Second : ft.Minute);
                f.value === ft.Hour ? f.value = ft.Minute : e.useSeconds && f.value === ft.Minute && (f.value = ft.Second), !(r.value === s.value && o.value === u.value && (!e.useSeconds || i.value === c.value) || p() === null) && (s.value = r.value, u.value = o.value, e.useSeconds && (c.value = i.value), R && _())
            }
            ne(() => {
                const I = Xo.filterProps(e),
                    R = Sf.filterProps(e),
                    B = _f.filterProps(We(e, ["format", "modelValue", "min", "max"]));
                return m(Xo, te(I, {
                    color: void 0,
                    class: ["v-time-picker", e.class],
                    style: e.style
                }), {
                    title: () => {
                        var $;
                        return (($ = a.title) == null ? void 0 : $.call(a)) ? ? m("div", {
                            class: "v-time-picker__title"
                        }, [l(e.title)])
                    },
                    header: () => m(Sf, te(R, {
                        ampm: b.value || e.ampmInTitle,
                        ampmReadonly: b.value && !e.ampmInTitle,
                        hour: r.value,
                        minute: o.value,
                        period: d.value,
                        second: i.value,
                        selecting: f.value,
                        "onUpdate:period": $ => x($),
                        "onUpdate:selecting": $ => f.value = $,
                        ref: v
                    }), null),
                    default: () => m(_f, te(B, {
                        allowedValues: f.value === ft.Hour ? h.value : f.value === ft.Minute ? y.value : S.value,
                        double: f.value === ft.Hour && !b.value,
                        format: f.value === ft.Hour ? b.value ? w : $ => $ : $ => bl($, 2),
                        max: f.value === ft.Hour ? b.value && d.value === "am" ? 11 : 23 : 59,
                        min: f.value === ft.Hour && b.value && d.value === "pm" ? 12 : 0,
                        size: 20,
                        step: f.value === ft.Hour ? 1 : 5,
                        modelValue: f.value === ft.Hour ? r.value : f.value === ft.Minute ? o.value : i.value,
                        onChange: V,
                        onInput: T,
                        ref: g
                    }), null),
                    actions: a.actions
                })
            })
        }
    }),
    mj = W({ ...We(yw({
            collapseIcon: "$treeviewCollapse",
            expandIcon: "$treeviewExpand"
        }), ["subgroup"])
    }, "VTreeviewGroup"),
    wf = Z()({
        name: "VTreeviewGroup",
        props: mj(),
        setup(e, t) {
            let {
                slots: n
            } = t;
            const a = Q(),
                l = C(() => {
                    var o;
                    return (o = a.value) != null && o.isOpen ? e.collapseIcon : e.expandIcon
                }),
                r = C(() => {
                    var o;
                    return {
                        VTreeviewItem: {
                            prependIcon: void 0,
                            appendIcon: void 0,
                            active: (o = a.value) == null ? void 0 : o.isOpen,
                            toggleIcon: l.value
                        }
                    }
                });
            return ne(() => {
                const o = Yo.filterProps(e);
                return m(Yo, te(o, {
                    ref: a,
                    class: ["v-treeview-group", e.class],
                    subgroup: !0
                }), { ...n,
                    activator: n.activator ? i => m(ye, null, [m(Ve, {
                        defaults: r.value
                    }, {
                        default: () => {
                            var s;
                            return [(s = n.activator) == null ? void 0 : s.call(n, i)]
                        }
                    })]) : void 0
                })
            }), {}
        }
    }),
    wC = Symbol.for("vuetify:v-treeview"),
    hj = W({
        loading: Boolean,
        onToggleExpand: It(),
        toggleIcon: Pe,
        ..._w({
            slim: !0
        })
    }, "VTreeviewItem"),
    kf = Z()({
        name: "VTreeviewItem",
        props: hj(),
        setup(e, t) {
            let {
                attrs: n,
                slots: a,
                emit: l
            } = t;
            const r = Gr(e, n),
                o = C(() => e.value === void 0 ? r.href.value : e.value),
                i = Q(),
                {
                    activate: s,
                    isActivated: u,
                    isGroupActivator: c,
                    root: d,
                    id: f
                } = Zv(o, !1),
                v = C(() => d.activatable.value && c),
                g = C(() => {
                    var S;
                    return !e.disabled && e.link !== !1 && (e.link || r.isClickable.value || e.value != null && !!((S = i.value) != null && S.list) || v.value)
                });

            function h(S) {
                var b, p;
                !g.value || !v.value && c || d.activatable.value && (v.value ? s(!u.value, S) : (p = i.value) == null || p.activate(!((b = i.value) != null && b.isActivated), S))
            }
            const y = Te(wC, {
                visibleIds: Q()
            }).visibleIds;
            return ne(() => {
                const S = We(jn.filterProps(e), ["onClick"]),
                    b = a.prepend || e.toggleIcon;
                return m(jn, te(S, {
                    active: u.value,
                    class: ["v-treeview-item", {
                        "v-treeview-item--activatable-group-activator": v.value,
                        "v-treeview-item--filtered": y.value && !y.value.has(f.value)
                    }, e.class],
                    ripple: !1,
                    onClick: e.onClick ? ? h
                }), { ...a,
                    prepend: b ? p => {
                        var _;
                        return m(ye, null, [e.toggleIcon && m(Iw, {
                            start: !1
                        }, {
                            default: () => [m(Le, {
                                density: "compact",
                                icon: e.toggleIcon,
                                loading: e.loading,
                                variant: "text",
                                onClick: e.onToggleExpand
                            }, {
                                loader() {
                                    return m(Ja, {
                                        indeterminate: "disable-shrink",
                                        size: "20",
                                        width: "2"
                                    }, null)
                                }
                            })]
                        }), (_ = a.prepend) == null ? void 0 : _.call(a, p)])
                    } : void 0
                })
            }), {}
        }
    }),
    kC = W({
        loadChildren: Function,
        loadingIcon: {
            type: String,
            default: "$loading"
        },
        items: Array,
        openOnClick: {
            type: Boolean,
            default: void 0
        },
        indeterminateIcon: {
            type: Pe,
            default: "$checkboxIndeterminate"
        },
        falseIcon: Pe,
        trueIcon: Pe,
        returnObject: Boolean,
        selectable: Boolean,
        selectedColor: String,
        selectStrategy: [String, Function, Object]
    }, "VTreeviewChildren"),
    Bs = Z()({
        name: "VTreeviewChildren",
        props: kC(),
        setup(e, t) {
            let {
                emit: n,
                slots: a
            } = t;
            const l = fe(null),
                r = C(() => e.openOnClick != null ? e.openOnClick : e.selectable);

            function o(s) {
                return new Promise(u => {
                    var c, d;
                    if (!((c = e.items) != null && c.length) || !e.loadChildren) return u();
                    if (((d = s == null ? void 0 : s.children) == null ? void 0 : d.length) === 0) {
                        l.value = s.value, e.loadChildren(s).then(u);
                        return
                    }
                    u()
                }).finally(() => {
                    l.value = null
                })
            }

            function i(s, u) {
                e.selectable && s(!u)
            }
            return () => {
                var s, u;
                return ((s = a.default) == null ? void 0 : s.call(a)) ? ? ((u = e.items) == null ? void 0 : u.map(c => {
                    var b;
                    let {
                        children: d,
                        props: f,
                        raw: v
                    } = c;
                    const g = l.value === v.value,
                        h = {
                            prepend: p => {
                                var _;
                                return m(ye, null, [e.selectable && (!d || d && !["leaf", "single-leaf"].includes(e.selectStrategy)) && m("div", null, [m(Qn, {
                                    key: v.value,
                                    modelValue: p.isSelected,
                                    loading: g,
                                    color: e.selectedColor,
                                    indeterminate: p.isIndeterminate,
                                    indeterminateIcon: e.indeterminateIcon,
                                    falseIcon: e.falseIcon,
                                    trueIcon: e.trueIcon,
                                    onClick: ms(() => i(p.select, p.isSelected), ["stop"]),
                                    onKeydown: w => {
                                        ["Enter", "Space"].includes(w.key) && (w.stopPropagation(), i(p.select, p.isSelected))
                                    }
                                }, null)]), (_ = a.prepend) == null ? void 0 : _.call(a, { ...p,
                                    item: v
                                })])
                            },
                            append: a.append ? p => {
                                var _;
                                return (_ = a.append) == null ? void 0 : _.call(a, { ...p,
                                    item: v
                                })
                            } : void 0,
                            title: a.title ? p => {
                                var _;
                                return (_ = a.title) == null ? void 0 : _.call(a, { ...p,
                                    item: v
                                })
                            } : void 0
                        },
                        y = wf.filterProps(f),
                        S = Bs.filterProps(e);
                    return d ? m(wf, te(y, {
                        value: e.returnObject ? v : y == null ? void 0 : y.value
                    }), {
                        activator: p => {
                            let {
                                props: _
                            } = p;
                            const w = { ...f,
                                ..._,
                                value: f == null ? void 0 : f.value,
                                onToggleExpand: _.onClick,
                                onClick: r.value ? [() => o(v), _.onClick] : void 0
                            };
                            return m(kf, te(w, {
                                value: e.returnObject ? xe(v) : f.value,
                                loading: g
                            }), h)
                        },
                        default: () => m(Bs, te(S, {
                            items: d,
                            returnObject: e.returnObject
                        }), a)
                    }) : ((b = a.item) == null ? void 0 : b.call(a, {
                        props: f
                    })) ? ? m(kf, te(f, {
                        value: e.returnObject ? xe(v) : f.value
                    }), h)
                }))
            }
        }
    });

function CC(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    for (const n of e) t.push(n), n.children && CC(n.children, t);
    return t
}
const gj = W({
        openAll: Boolean,
        search: String,
        ...Zr({
            filterKeys: ["title"]
        }),
        ...kC(),
        ...We(Ew({
            collapseIcon: "$treeviewCollapse",
            expandIcon: "$treeviewExpand",
            slim: !0
        }), ["itemType", "nav", "openStrategy"]),
        modelValue: {
            type: Array,
            default: () => []
        }
    }, "VTreeview"),
    yj = Z()({
        name: "VTreeview",
        props: gj(),
        emits: {
            "update:opened": e => !0,
            "update:activated": e => !0,
            "update:selected": e => !0,
            "update:modelValue": e => !0,
            "click:open": e => !0,
            "click:select": e => !0
        },
        setup(e, t) {
            let {
                slots: n
            } = t;
            const {
                items: a
            } = Pw(e), l = Y(e, "activeColor"), r = Y(e, "baseColor"), o = Y(e, "color"), i = Ce(e, "activated"), s = Ce(e, "modelValue"), u = Ce(e, "selected", e.modelValue), c = C({
                get: () => u.value,
                set(_) {
                    u.value = _, s.value = _
                }
            }), d = Q(), f = C(() => e.openAll ? p(a.value) : e.opened), v = C(() => CC(a.value)), g = Y(e, "search"), {
                filteredItems: h
            } = Qr(e, v, g), y = C(() => g.value ? new Set(h.value.flatMap(_ => [...S(_.props.value), ...b(_.props.value)])) : null);

            function S(_) {
                var E;
                const w = [];
                let k = _;
                for (; k != null;) w.unshift(k), k = (E = d.value) == null ? void 0 : E.parents.get(k);
                return w
            }

            function b(_) {
                var E, P;
                const w = [],
                    k = (((E = d.value) == null ? void 0 : E.children.get(_)) ? ? []).slice();
                for (; k.length;) {
                    const x = k.shift();
                    x && (w.push(x), k.push(...(((P = d.value) == null ? void 0 : P.children.get(x)) ? ? []).slice()))
                }
                return w
            }

            function p(_) {
                let w = [];
                for (const k of _) k.children && (w.push(e.returnObject ? xe(k.raw) : k.value), k.children && (w = w.concat(p(k.children))));
                return w
            }
            return He(wC, {
                visibleIds: y
            }), lt({
                VTreeviewGroup: {
                    activeColor: l,
                    baseColor: r,
                    color: o,
                    collapseIcon: Y(e, "collapseIcon"),
                    expandIcon: Y(e, "expandIcon")
                },
                VTreeviewItem: {
                    activeClass: Y(e, "activeClass"),
                    activeColor: l,
                    baseColor: r,
                    color: o,
                    density: Y(e, "density"),
                    disabled: Y(e, "disabled"),
                    lines: Y(e, "lines"),
                    variant: Y(e, "variant")
                }
            }), ne(() => {
                const _ = Mr.filterProps(e),
                    w = Bs.filterProps(e);
                return m(Mr, te({
                    ref: d
                }, _, {
                    class: ["v-treeview", e.class],
                    "open-strategy": "multiple",
                    style: e.style,
                    opened: f.value,
                    activated: i.value,
                    "onUpdate:activated": k => i.value = k,
                    selected: c.value,
                    "onUpdate:selected": k => c.value = k
                }), {
                    default: () => [m(Bs, te(w, {
                        returnObject: e.returnObject,
                        items: a.value
                    }), n)]
                })
            }), {}
        }
    }),
    bj = Object.freeze(Object.defineProperty({
        __proto__: null,
        VCalendar: Y4,
        VCalendarDay: ns,
        VCalendarHeader: pf,
        VCalendarInterval: bf,
        VCalendarIntervalEvent: yf,
        VCalendarMonthDay: bC,
        VDateInput: X4,
        VNumberInput: Z4,
        VPicker: Xo,
        VPickerTitle: zk,
        VPullToRefresh: aj,
        VSnackbarQueue: rj,
        VStepperVertical: nj,
        VStepperVerticalActions: pC,
        VStepperVerticalItem: _C,
        VTimePicker: vj,
        VTimePickerClock: _f,
        VTimePickerControls: Sf,
        VTreeview: yj,
        VTreeviewGroup: wf,
        VTreeviewItem: kf
    }, Symbol.toStringTag, {
        value: "Module"
    }));

function Tc(e, t, n) {
    const a = Ce(e, t);
    return a.value = e[t] ? ? n.value, de(n, l => {
        e[t] == null && (a.value = l)
    }), a
}

function xC(e) {
    return t => {
        const n = Tc(t, "locale", e.current),
            a = Tc(t, "fallback", e.fallback),
            l = Tc(t, "messages", e.messages),
            r = e.useI18n({
                locale: n.value,
                fallbackLocale: a.value,
                messages: l.value,
                useScope: "local",
                legacy: !1,
                inheritLocale: !1
            });
        return de(n, o => {
            r.locale.value = o
        }), {
            name: "vue-i18n",
            current: n,
            fallback: a,
            messages: l,
            t: function(o) {
                for (var i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), u = 1; u < i; u++) s[u - 1] = arguments[u];
                return r.t(o, s)
            },
            n: r.n,
            provide: xC({
                current: n,
                fallback: a,
                messages: l,
                useI18n: e.useI18n
            })
        }
    }
}

function pj(e) {
    let {
        i18n: t,
        useI18n: n
    } = e;
    const a = t.global.locale,
        l = t.global.fallbackLocale,
        r = t.global.messages;
    return {
        name: "vue-i18n",
        current: a,
        fallback: l,
        messages: r,
        t: function(o) {
            for (var i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), u = 1; u < i; u++) s[u - 1] = arguments[u];
            return t.global.t(o, s)
        },
        n: t.global.n,
        provide: xC({
            current: a,
            fallback: l,
            messages: r,
            useI18n: n
        })
    }
}
const _j = {
    badge: "شارة",
    open: "Open",
    close: "إغلاق",
    dismiss: "Dismiss",
    confirmEdit: {
        ok: "OK",
        cancel: "Cancel"
    },
    dataIterator: {
        noResultsText: "لم يتم إيجاد نتائج",
        loadingText: "يتم جلب العناصر..."
    },
    dataTable: {
        itemsPerPageText: "عدد الصفوف لكل صفحة:",
        ariaLabel: {
            sortDescending: "مرتب تنازلياً.",
            sortAscending: "مرتب تصاعدياً.",
            sortNone: "غير مرتب.",
            activateNone: "نشط لإزالة الترتيب.",
            activateDescending: "نشط للترتيب تنازلياً.",
            activateAscending: "نشط للترتيب تصاعدياً."
        },
        sortBy: "رتب حسب"
    },
    dataFooter: {
        itemsPerPageText: "عدد العناصر لكل صفحة:",
        itemsPerPageAll: "الكل",
        nextPage: "الصفحة التالية",
        prevPage: "الصفحة السابقة",
        firstPage: "الصفحة الأولى",
        lastPage: "الصفحة الأخيرة",
        pageText: "{0}-{1} من {2}"
    },
    dateRangeInput: {
        divider: "to"
    },
    datePicker: {
        itemsSelected: "{0} selected",
        range: {
            title: "Select dates",
            header: "Enter dates"
        },
        title: "Select date",
        header: "Enter date",
        input: {
            placeholder: "Enter date"
        }
    },
    noDataText: "لا توجد بيانات",
    carousel: {
        prev: "المعروض السابق",
        next: "المعروض التالي",
        ariaLabel: {
            delimiter: "المعروض رقم {0} من {1}"
        }
    },
    calendar: {
        moreEvents: "{0} أكثر",
        today: "Today"
    },
    input: {
        clear: "Clear {0}",
        prependAction: "{0} prepended action",
        appendAction: "{0} appended action",
        otp: "Please enter OTP character {0}"
    },
    fileInput: {
        counter: "{0} ملفات",
        counterSize: "{0} ملفات ({1} في المجموع)"
    },
    timePicker: {
        am: "صباحاً",
        pm: "مساءً",
        title: "Select Time"
    },
    pagination: {
        ariaLabel: {
            root: "الإنتقال بين الصفحات",
            next: "الصفحة التالية",
            previous: "الصفحة السابقة",
            page: "{0} انتقل إلى الصفحة",
            currentPage: "{0} الصفحة الحالية رقمها",
            first: "First page",
            last: "Last page"
        }
    },
    stepper: {
        next: "Next",
        prev: "Previous"
    },
    rating: {
        ariaLabel: {
            item: "القييم {0} من {1}"
        }
    },
    loading: "Loading...",
    infiniteScroll: {
        loadMore: "Load more",
        empty: "No more"
    }
};
var Fs = (e => (e.ARABIC = "ar-AE", e.ENGLISH = "en-US", e))(Fs || {});
const Sj = {
        dark: !1,
        colors: {
            primary: "#11a56f",
            secondary: "#AA8F00",
            error: "#FF5545",
            info: "#1A9CCA",
            success: "#4CA25B",
            warning: "#C78200",
            background: "#F2F4F0",
            surface: "#FFFFFF"
        }
    },
    wj = Wt(e => {
        const t = e.$i18n;
        t.mergeLocaleMessage("en-US", {
            $vuetify: yS
        }), t.mergeLocaleMessage("ar-AE", {
            $vuetify: _j
        });
        const n = OS({
            ssr: !0,
            theme: {
                defaultTheme: "uaepassDefaultTheme",
                themes: {
                    uaepassDefaultTheme: Sj
                }
            },
            components: { ...A4,
                ...bj
            },
            directives: U4,
            locale: {
                adapter: pj({
                    i18n: {
                        global: e.$i18n
                    },
                    useI18n: ui
                }),
                rtl: {
                    [Fs.ARABIC]: !0
                }
            }
        });
        e.vueApp.use(n)
    }),
    kj = [jT, WT, yA, bA, pA, _A, wA, MA, YA, qA, iL, aD, vD, xD, PD, wj],
    Cj = Ln({
        props: {
            vnode: {
                type: Object,
                required: !0
            },
            route: {
                type: Object,
                required: !0
            },
            vnodeRef: Object,
            renderKey: String,
            trackRootNodes: Boolean
        },
        setup(e) {
            const t = e.renderKey,
                n = e.route,
                a = {};
            for (const l in e.route) Object.defineProperty(a, l, {
                get: () => t === e.renderKey ? e.route[l] : n[l]
            });
            return He(uu, Jn(a)), () => ht(e.vnode, {
                ref: e.vnodeRef
            })
        }
    }),
    xj = Ln({
        name: "NuxtPage",
        inheritAttrs: !1,
        props: {
            name: {
                type: String
            },
            transition: {
                type: [Boolean, Object],
                default: void 0
            },
            keepalive: {
                type: [Boolean, Object],
                default: void 0
            },
            route: {
                type: Object
            },
            pageKey: {
                type: [Function, String],
                default: null
            }
        },
        setup(e, {
            attrs: t,
            slots: n,
            expose: a
        }) {
            const l = Ye(),
                r = Q(),
                o = Te(uu, null);
            let i;
            a({
                pageRef: r
            });
            const s = Te(UI, null);
            let u;
            const c = l.deferHydration();
            if (l.isHydrating) {
                const d = l.hooks.hookOnce("app:error", c);
                Vn().beforeEach(d)
            }
            return e.pageKey && de(() => e.pageKey, (d, f) => {
                d !== f && l.callHook("page:loading:start")
            }), () => ht(H_, {
                name: e.name,
                route: e.route,
                ...t
            }, {
                default: d => {
                    const f = Ej(o, d.route, d.Component),
                        v = o && o.matched.length === d.route.matched.length;
                    if (!d.Component) {
                        if (u && !v) return u;
                        c();
                        return
                    }
                    if (u && s && !s.isCurrent(d.route)) return u;
                    if (f && o && (!s || s != null && s.isCurrent(o))) return v ? u : null;
                    const g = gd(d, e.pageKey);
                    !l.isHydrating && !Ij(o, d.route, d.Component) && i === g && l.callHook("page:loading:end"), i = g;
                    const h = !!(e.transition ? ? d.route.meta.pageTransition ? ? ld),
                        y = h && Pj([e.transition, d.route.meta.pageTransition, ld, {
                            onAfterLeave: () => {
                                l.callHook("page:transition:finish", d.Component)
                            }
                        }].filter(Boolean)),
                        S = e.keepalive ? ? d.route.meta.keepalive ? ? lI;
                    return u = uA(Tn, h && y, qV(S, ht(jf, {
                        suspensible: !0,
                        onPending: () => l.callHook("page:start", d.Component),
                        onResolve: () => {
                            Re(() => l.callHook("page:finish", d.Component).then(() => l.callHook("page:loading:end")).finally(c))
                        }
                    }, {
                        default: () => {
                            const b = ht(Cj, {
                                key: g || void 0,
                                vnode: n.default ? ht(ye, void 0, n.default(d)) : d.Component,
                                route: d.route,
                                renderKey: g || void 0,
                                trackRootNodes: h,
                                vnodeRef: r
                            });
                            return S && (b.type.name = d.Component.type.name || d.Component.type.__name || "RouteProvider"), b
                        }
                    }))).default(), u
                }
            })
        }
    });

function Pj(e) {
    const t = e.map(n => ({ ...n,
        onAfterLeave: n.onAfterLeave ? vv(n.onAfterLeave) : void 0
    }));
    return y_(...t)
}

function Ej(e, t, n) {
    if (!e) return !1;
    const a = t.matched.findIndex(l => {
        var r;
        return ((r = l.components) == null ? void 0 : r.default) === (n == null ? void 0 : n.type)
    });
    return !a || a === -1 ? !1 : t.matched.slice(0, a).some((l, r) => {
        var o, i, s;
        return ((o = l.components) == null ? void 0 : o.default) !== ((s = (i = e.matched[r]) == null ? void 0 : i.components) == null ? void 0 : s.default)
    }) || n && gd({
        route: t,
        Component: n
    }) !== gd({
        route: e,
        Component: n
    })
}

function Ij(e, t, n) {
    return e ? t.matched.findIndex(l => {
        var r;
        return ((r = l.components) == null ? void 0 : r.default) === (n == null ? void 0 : n.type)
    }) < t.matched.length - 1 : !1
}
const Tj = () => {
        const {
            $userWayInstance: e
        } = Ye(), n = Ut().public.isAccessibilityOn;
        return {
            userWayInstance: e,
            accessibilityOn: n,
            openUserWayWidget: () => {
                e.value && e.value.widgetOpen()
            }
        }
    },
    Vj = () => {
        const {
            locale: e
        } = ui(), t = {
            [Fs.ARABIC]: "ar",
            [Fs.ENGLISH]: "en"
        }, n = {
            en: "English",
            ar: "Arabic"
        }, a = C(() => t[e.value]), l = C(() => a.value ? a.value[0].toUpperCase() + a.value[1] : ""), r = C(() => n[a.value]), o = C(() => a.value);
        return {
            langAb: l,
            langName: r,
            langCode: o
        }
    },
    Aj = Ln({
        __name: "app",
        setup(e) {
            const {
                userWayInstance: t,
                accessibilityOn: n
            } = Tj(), a = Q(!1), {
                langCode: l
            } = Vj();
            return de(t, () => {
                t.value && (t.value.iconVisibilityOff(), n && (a.value = !0))
            }), de(l, () => {
                var r;
                t.value && n && ((r = t.value) == null || r.changeWidgetLanguage(l.value))
            }), (r, o) => {
                const i = xj;
                return Cn(), qn(i, {
                    class: Hr([!Ie(a) && "accessibility-btn-hidden"])
                }, null, 8, ["class"])
            }
        }
    }),
    Lj = {
        __name: "nuxt-error-page",
        props: {
            error: Object
        },
        setup(e) {
            const n = e.error;
            n.stack && n.stack.split(`
`).splice(1).map(d => ({
                text: d.replace("webpack:/", "").replace(".vue", ".js").trim(),
                internal: d.includes("node_modules") && !d.includes(".cache") || d.includes("internal") || d.includes("new Promise")
            })).map(d => `<span class="stack${d.internal?" internal":""}">${d.text}</span>`).join(`
`);
            const a = Number(n.statusCode || 500),
                l = a === 404,
                r = n.statusMessage ? ? (l ? "Page Not Found" : "Internal Server Error"),
                o = n.message || n.toString(),
                i = void 0,
                c = l ? mn(() => Je(() =>
                    import ("./DCY82DFH.js"), __vite__mapDeps([53, 33, 2, 54]),
                    import.meta.url).then(d => d.default || d)) : mn(() => Je(() =>
                    import ("./Dr2is14k.js"), __vite__mapDeps([55, 33, 2, 56]),
                    import.meta.url).then(d => d.default || d));
            return (d, f) => (Cn(), qn(Ie(c), Db(Qf({
                statusCode: Ie(a),
                statusMessage: Ie(r),
                description: Ie(o),
                stack: Ie(i)
            })), null, 16))
        }
    },
    Oj = {
        key: 0
    },
    rb = {
        __name: "nuxt-root",
        setup(e) {
            const t = () => null,
                n = Ye(),
                a = n.deferHydration();
            if (n.isHydrating) {
                const s = n.hooks.hookOnce("app:error", a);
                Vn().beforeEach(s)
            }
            const l = !1;
            He(uu, iv()), n.hooks.callHookWith(s => s.map(u => u()), "vue:setup");
            const r = cu(),
                o = !1;
            Yf((s, u, c) => {
                if (n.hooks.callHook("vue:error", s, u, c).catch(d => console.error("[nuxt] Error in `vue:error` hook", d)), qI(s) && (s.fatal || s.unhandled)) return n.runWithContext(() => dr(s)), !1
            });
            const i = !1;
            return (s, u) => (Cn(), qn(jf, {
                onResolve: Ie(a)
            }, {
                default: Js(() => [Ie(o) ? (Cn(), kp("div", Oj)) : Ie(r) ? (Cn(), qn(Ie(Lj), {
                    key: 1,
                    error: Ie(r)
                }, null, 8, ["error"])) : Ie(i) ? (Cn(), qn(Ie(t), {
                    key: 2,
                    context: Ie(i)
                }, null, 8, ["context"])) : Ie(l) ? (Cn(), qn(Ff(Ie(l)), {
                    key: 3
                })) : (Cn(), qn(Ie(Aj), {
                    key: 4
                }))]),
                _: 1
            }, 8, ["onResolve"]))
        }
    };
let ob; {
    let e;
    ob = async function() {
        var o, i;
        if (e) return e;
        const a = !!((o = window.__NUXT__) != null && o.serverRendered || ((i = document.getElementById("__NUXT_DATA__")) == null ? void 0 : i.dataset.ssr) === "true") ? Qp(rb) : Zp(rb),
            l = sI({
                vueApp: a
            });
        async function r(s) {
            await l.callHook("app:error", s), l.payload.error = l.payload.error || du(s)
        }
        a.config.errorHandler = r;
        try {
            await dI(l, kj)
        } catch (s) {
            r(s)
        }
        try {
            await l.hooks.callHook("app:created", a), await l.hooks.callHook("app:beforeMount", a), a.mount(oI), await l.hooks.callHook("app:mounted", a), await Re()
        } catch (s) {
            r(s)
        }
        return a.config.errorHandler === r && (a.config.errorHandler = void 0), a
    }, e = ob().catch(t => {
        throw console.error("Error while mounting app:", t), t
    })
}
export {
    te as $, Js as A, hn as B, O1 as C, R1 as D, s_ as E, qn as F, Ie as G, mx as H, $2 as I, z2 as J, ui as K, Vj as L, ye as M, J1 as N, jn as O, Be as P, pw as Q, Mr as R, Le as S, Ge as T, Un as U, Ca as V, de as W, iC as X, y4 as Y, Ja as Z, iH as _, Ye as a, cd as a$, Nx as a0, hf as a1, mf as a2, vf as a3, ff as a4, Rl as a5, jl as a6, ya as a7, YH as a8, Hr as a9, Yr as aA, p4 as aB, uu as aC, Hj as aD, Mi as aE, Rj as aF, uA as aG, Re as aH, jf as aI, Tn as aJ, UI as aK, Bj as aL, Gw as aM, r1 as aN, $j as aO, Nj as aP, dC as aQ, WH as aR, SH as aS, IN as aT, Tj as aU, tn as aV, Fs as aW, Ol as aX, On as aY, Fj as aZ, st as a_, mt as aa, Xd as ab, Qa as ac, iv as ad, im as ae, bw as af, Y as ag, He as ah, Q1 as ai, Db as aj, Qf as ak, Te as al, Fr as am, Nt as an, QB as ao, Yw as ap, Xw as aq, Kw as ar, $k as as, en as at, at as au, bn as av, R2 as aw, I$ as ax, uD as ay, aH as az, mv as b, Qs as b0, Kf as b1, nn as b2, Uj as b3, Mj as b4, fe as b5, tu as b6, jr as b7, kt as b8, du as b9, $r as ba, rg as c, Ln as d, GI as e, Ct as f, jj as g, ht as h, Ub as i, C as j, aa as k, Ur as l, KI as m, Dj as n, it as o, n_ as p, Ut as q, Q as r, su as s, Cn as t, Vn as u, kp as v, gs as w, Zf as x, Mb as y, m as z
};